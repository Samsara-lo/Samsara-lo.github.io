<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PE文件结构学习</title>
      <link href="/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h2><p>资料来源：《逆向工程核心原理》和<a href="https://www.youtube.com/watch?v=oSpeXGHaKAk&amp;t=15123s">PE文件结构格式详解（完整版）【逆向编程】 (youtube.com)</a></p><h3 id="一、PE文件基础"><a href="#一、PE文件基础" class="headerlink" title="一、PE文件基础"></a>一、PE文件基础</h3><h3 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h3><p>Windows：PE</p><p>Linux:elf</p><h3 id="2-PE文件特征"><a href="#2-PE文件特征" class="headerlink" title="2.PE文件特征"></a>2.PE文件特征</h3><p>PE文件指纹</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011858080.png" alt="1735729100495.png"></p><h3 id="3-PE结构"><a href="#3-PE结构" class="headerlink" title="3.PE结构"></a>3.PE结构</h3><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859756.png" alt="1735729120355.png"></p><h4 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h4><ul><li><strong>DOS MZ头</strong>  <strong>IMAGE_DOS_HEADER(64字节)</strong></li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859938.png" alt="1735729155568.png"></p><p><strong>e_magic</strong>：4D5A是DOS签名，不可改</p><p><strong>e_lfanew</strong>：78指向PE头开始位置，要改要一起改。</p><p>上面两个是<strong>PE指纹</strong>，操作系统用来<strong>识别是否是PE文件</strong>，其他地方可以随便改，因为<em>IMAGE_DOS_HEADER</em>是给16位平台看的，而我们现在的环境大部分是32位或者64位。</p><ul><li><strong>MS_DOS Stu</strong>，DOS存根，用来给链接器插入数据，随便改</li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011900211.png" alt="1735729196266.png"></p><h4 id="NT头-IMAGE-NT-HEADERS"><a href="#NT头-IMAGE-NT-HEADERS" class="headerlink" title="NT头 IMAGE_NT_HEADERS"></a>NT头 IMAGE_NT_HEADERS</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; ``// PE标识 IMAGE_FILE_HEADER FileHeader; ``// 标准PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; ``// 扩展PE头&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PE标识-Signature-4字节"><a href="#PE标识-Signature-4字节" class="headerlink" title="PE标识 Signature 4字节"></a>PE标识 Signature 4字节</h5><p><strong><u>不可改</u></strong>,操作系统启动程序的时候识别这个标识。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011901322.png" alt="1735729196266.png"></p><h5 id="标准PE头-IMAGE-FILE-HEADER-20字节"><a href="#标准PE头-IMAGE-FILE-HEADER-20字节" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER(20字节)"></a>标准PE头 <strong>IMAGE_FILE_HEADER</strong>(20字节)</h5><pre class="line-numbers language-lang-c"><code class="language-lang-c">typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; // 可以运行在什么样的CPU上 WORD NumberOfSections; // 表示节的数量 DWORD TimeDateStamp; // 编译器填写的时间戳 DWORD PointerToSymbolTable; // 调试相关 DWORD NumberOfSymbols; // 调试相关 WORD SizeOfOptionalHeader; // 扩展PE头的大小 WORD Characteristics; // 文件属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902971.png" alt="1735729302371.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902440.png" alt="1735729314190.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902205.png" alt="1735729331600.png"></p><pre><code>64 86 -&gt;8664 代表在x64上运行0F 00 有0x0F个节区84 D7 68 65 编译器写的时间戳，和文件无关，随便改调试不管F0 00 扩展PE头大小，可改22 00-&gt;0022-&gt; 0000 0000 0010 0010 第2位，第6位有值 对应数据位1，5 分别代表文件可执行，应用程序可以处理大于2GB的地址（代表64位）</code></pre><h5 id="扩展PE头-IMAGE-OPTIONAL-HEADER"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="扩展PE头  IMAGE_OPTIONAL_HEADER"></a>扩展PE头  IMAGE_OPTIONAL_HEADER</h5><h6 id="扩展PE头结构-amp-不同编译器上的差异"><a href="#扩展PE头结构-amp-不同编译器上的差异" class="headerlink" title="扩展PE头结构&amp;不同编译器上的差异"></a>扩展PE头结构&amp;不同编译器上的差异</h6><p>32位上是224字节（E0)（可扩展）</p><p>64位是F0</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">//32位为例typedef struct _IMAGE_OPTIONAL_HEADER32 &#123;    WORD    Magic;                  // 标志：PE32 是 0x10B    BYTE    MajorLinkerVersion;     // 链接器的主版本号    BYTE    MinorLinkerVersion;     // 链接器的次版本号    DWORD   SizeOfCode;             // 代码段的大小（没用）    DWORD   SizeOfInitializedData;  // 初始化数据段的大小（没用）    DWORD   SizeOfUninitializedData;// 未初始化数据段的大小（没用）    DWORD   AddressOfEntryPoint;    // 程序入口点的 RVA    DWORD   BaseOfCode;             // 代码段的起始 RVA（没用）    DWORD   BaseOfData;             // 数据段的起始 RVA（没用）    DWORD   ImageBase;              // 内存镜像基址    DWORD   SectionAlignment;       // 内存对齐    DWORD   FileAlignment;          // 文件对齐    WORD    MajorOperatingSystemVersion; // OS 主版本号    WORD    MinorOperatingSystemVersion; // OS 次版本号    DWORD   SizeOfImage;            // 镜像的总大小    DWORD   SizeOfHeaders;          // 头+节表按照文件对齐后的总大小    DWORD   CheckSum;               // 校验和    WORD    Subsystem;              // 子系统（如 GUI、CUI）    WORD    DllCharacteristics;    // DLL 属性    DWORD   SizeOfStackReserve;     // 堆栈保留大小    DWORD   SizeOfStackCommit;      // 堆栈提交大小    DWORD   SizeOfHeapReserve;      // 堆保留大小    DWORD   SizeOfHeapCommit;       // 堆提交大小    DWORD   LoaderFlags;            // 装载器标志（通常为 0）    DWORD   NumberOfRvaAndSizes;    // 数据目录项数    IMAGE_DATA_DIRECTORY DataDirectory[16]; // 表，结构体数组&#125; IMAGE_OPTIONAL_HEADER32;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th><strong>字段名称</strong></th><th><strong>32 位 PE（PE32）</strong></th><th><strong>64 位 PE（PE32+）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>Magic</code></td><td><code>0x10B</code></td><td><code>0x20B</code></td><td>标识 PE 文件是 32 位（PE32）还是 64 位（PE32+）。</td></tr><tr><td><code>AddressOfEntryPoint</code></td><td>存在</td><td>存在</td><td>程序入口点的 RVA（相对虚拟地址）。</td></tr><tr><td><code>BaseOfCode</code></td><td>存在</td><td>存在</td><td>代码段的起始 RVA。</td></tr><tr><td><code>BaseOfData</code></td><td>存在</td><td><strong>不存在</strong></td><td>数据段的起始 RVA，<strong>仅在 PE32 中存在</strong>。</td></tr><tr><td><code>ImageBase</code></td><td>32 位地址（默认 0x00400000）</td><td>64 位地址（默认 0x0000000140000000）</td><td>可执行文件加载到内存中的首地址。</td></tr><tr><td><code>SizeOfStackReserve</code></td><td>32 位值</td><td>64 位值</td><td>为线程的堆栈预留的大小。</td></tr><tr><td><code>SizeOfHeapReserve</code></td><td>32 位值</td><td>64 位值</td><td>为堆分配的保留大小。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011903423.png" alt="1735729389033.png"></p><h6 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a><strong><code>Magic</code></strong></h6><p>2个字节，文件的标志</p><p>32 位：10B</p><p>64 位：20B </p><h6 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint"></a><strong><code>AddressOfEntryPoint</code></strong></h6><p>4个字节，程序的入口点地址，即执行开始的位置。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904115.png" alt="1735729398902.png"></p><h6 id="ImageBase"><a href="#ImageBase" class="headerlink" title="ImageBase"></a><strong><code>ImageBase</code></strong></h6><p>4个字节，程序加载的基地址。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904366.png" alt="1735729409663.png"></p><p>AddressOfEntryPoint：<u>042CE910</u></p><p>imagebase:<u>00000010</u></p><p>程序执行入口：（EIP)042CE910+00000010=042CE920</p><h6 id="SectionAlignment"><a href="#SectionAlignment" class="headerlink" title="SectionAlignment"></a><strong><code>SectionAlignment</code></strong></h6><p>节区的内存对齐大小，节区在<strong>内存</strong>中的最小大小。</p><h6 id="FileAlignment"><a href="#FileAlignment" class="headerlink" title="FileAlignment"></a><strong><code>FileAlignment</code></strong></h6><p>节区的文件对齐大小，节区在<strong>磁盘文件</strong>中的最小单位。</p><h6 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a><strong><code>SizeOfImage</code></strong></h6><p>表示在内存中<strong>整个</strong>PE文件映射的大小（包括所有节区和头信息），可比实际的值大。内存对齐以后是SectionAlignment或者FileAlignment的整数倍。</p><h6 id="SizeOfHeaders"><a href="#SizeOfHeaders" class="headerlink" title="SizeOfHeaders"></a><strong><code>SizeOfHeaders</code></strong></h6><p>PE 文件头的大小。是<strong>FileAlignment的整数倍</strong>。</p><h6 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a><strong><code>CheckSum</code></strong></h6><p>校验和，系统用来检测文件是否被修改</p><h6 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a><strong><code>Subsystem</code></strong></h6><p>程序的子系统类型（例如，Windows GUI 或控制台应用程序），用来表示PE文件的特性。</p><h4 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h4><p><strong>IMAGE_SECTION_HEADER</strong> (40字节)</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">typedef struct _IMAGE_SECTION_HEADER &#123;    BYTE    Name[8];               // 节名称（最多 8 字节，可能没有结束符）    union &#123;        DWORD   PhysicalAddress;   // 实际已弃用，常为 0        DWORD   VirtualSize;       // 节的实际大小（内存中的大小）    &#125; Misc;    DWORD   VirtualAddress;        // 节在内存中的 RVA（相对虚拟地址）    DWORD   SizeOfRawData;         // 节在文件中的大小（以 FileAlignment 对齐）    DWORD   PointerToRawData;      // 节在文件中的偏移（以 FileAlignment 对齐）    DWORD   PointerToRelocations; // 重定位表的文件偏移（通常为 0，已弃用）    DWORD   PointerToLinenumbers; // 调试信息的文件偏移（通常为 0）    WORD    NumberOfRelocations;  // 重定位条目数量（通常为 0）    WORD    NumberOfLinenumbers;  // 调试行号条目数量（通常为 0）    DWORD   Characteristics;      // 节的属性标志（权限、类型等）&#125; IMAGE_SECTION_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红色框出来的是扩展PE头，下面就是节表</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904634.png" alt="1735729466460.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905916.png" alt="1735729479345.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905144.png" alt=""></p><h5 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h5><p>8字节，当前节的名字，可以随意更改。</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106081.png" alt="image"></h5><p>当前这个节未对齐时的大小，即实际大小。</p><p>实际大小有可能会比Size of Raw Data大，因为未初始化的全局变量在文件中是不占空间的，但是在内存里是有位置的。</p><p><strong>Q</strong>：在内存中展开时以什么为基准呢？</p><p><strong>A</strong>：谁大按谁，如果Vitual Size&gt;Size of Raw Data,则按照Vitual Size展开，反之则按照Size of Raw Data。</p><h5 id="VirtualAddress（RVA）"><a href="#VirtualAddress（RVA）" class="headerlink" title="VirtualAddress（RVA）"></a>VirtualAddress（RVA）</h5><p>在内存中的偏移地址，加上ImageBase则是内存中的真实地址。</p><h5 id="Raw-Size-Size-of-Raw-Data"><a href="#Raw-Size-Size-of-Raw-Data" class="headerlink" title="Raw Size(Size of Raw Data)"></a>Raw Size(Size of Raw Data)</h5><p>文件对齐后的大小</p><h5 id="Raw-Address-File-Pointer-to-Raw-Data"><a href="#Raw-Address-File-Pointer-to-Raw-Data" class="headerlink" title="Raw Address(File Pointer to Raw Data)"></a><strong>Raw Address</strong>(File Pointer to Raw Data)</h5><p>当前节在文件中起始位置</p><h5 id="Reloc-Address"><a href="#Reloc-Address" class="headerlink" title="Reloc Address"></a><strong>Reloc Address</strong></h5><p>节的重定位表（如果有的话）在文件中的偏移地址。</p><h5 id="Line-Numbers、Relocation-Number、Line-Number-Numbers"><a href="#Line-Numbers、Relocation-Number、Line-Number-Numbers" class="headerlink" title="Line Numbers、Relocation Number、Line Number Numbers"></a><strong>Line Numbers</strong>、<strong>Relocation Number</strong>、<strong>Line Number Numbers</strong></h5><p>与调试信息和重定位表相关。</p><h5 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h5><p>节区属性</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106048.png" alt="image"></p><h4 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h4><p>文件对齐和内存对齐的差异：</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106850.png" alt="image"></p><h3 id="4、RVA和FOA的转换"><a href="#4、RVA和FOA的转换" class="headerlink" title="4、RVA和FOA的转换"></a>4、RVA和FOA的转换</h3><p><strong>VA</strong>：虚拟内存的绝对地址。</p><p><strong>RVA</strong>：相对虚拟地址，从ImageBase开始的相对地址。</p><p><strong>FOA</strong>：文件偏移地址</p><p><strong>Q</strong>：想改边一个全局变量的初始值，应该怎么做？</p><p><strong>A</strong>：先区分全局变量有无初始值。如果有初始值，全局变量储存在文件中，如果没有初始值，在文件里就没有位置，在内存展开时才会分配位置。</p><p><1>、判断RVA是否在头部，在的话直接返回</p><p>FOA=RVA</p><p><2>、判断RVA在哪一个节</p><p>RVA&gt;=节.VA</p><p>RVA&lt;=节.VA+当前节内存对其后大小</p><p>差值=RVA-节.VA</p><p><4>、FOA=节.PointerToRawData+差值</p><p>看一下书上的例子，实例下面导入表的计算也有提到</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052107891.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108166.png" alt="image"></p><p><strong>算完RAW记得查看是否和内存中在同一节区！！！</strong>如上图Q3</p><h3 id="5、手撕PE文件"><a href="#5、手撕PE文件" class="headerlink" title="5、手撕PE文件"></a>5、手撕PE文件</h3><h4 id="（1）在空白区添加代码"><a href="#（1）在空白区添加代码" class="headerlink" title="（1）在空白区添加代码"></a>（1）在空白区添加代码</h4><h4 id="（2）扩大节"><a href="#（2）扩大节" class="headerlink" title="（2）扩大节"></a>（2）扩大节</h4><h4 id="（3）删除节"><a href="#（3）删除节" class="headerlink" title="（3）删除节"></a>（3）删除节</h4><h4 id="（4）新添节"><a href="#（4）新添节" class="headerlink" title="（4）新添节"></a>（4）新添节</h4><h4 id="（5）合并节"><a href="#（5）合并节" class="headerlink" title="（5）合并节"></a>（5）合并节</h4><h3 id="6、导出表-amp-导入表"><a href="#6、导出表-amp-导入表" class="headerlink" title="6、导出表&amp;导入表"></a>6、导出表&amp;导入表</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>首先明白，一个可执行程序是有<strong>多个pe文件组成</strong>的。</p><p><strong>导入表（IMP)</strong>：PE文件引用了哪些文件</p><p><strong>导出表(EAT)</strong>：当前的PE文件储存了哪些函数给其他文件用。</p><p><strong>Q</strong>：导出表在哪？</p><p><strong>A</strong>：再扩展PE头最后一个成员</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108437.png" alt="image"></p><h5 id="Dll"><a href="#Dll" class="headerlink" title="Dll"></a>Dll</h5><p>动态链接库</p><p>加载DLL的两种方式</p><ul><li><strong>显式链接</strong>：程序使用DLL时候加载，使用完释放内存。</li><li><strong>隐式链接</strong>：程序开始时一同加载DLL，程序终止时释放内存。</li></ul><h4 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052109509.png" alt="image"></h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052110010.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111005.png" alt="image"></p><p>先找到导出表位置</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111830.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111561.png" alt="image"></p><h4 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h4><p>确定依赖的函数</p><p><strong>导入表位置</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112545.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112232.png" alt="image"></p><p><strong>导入表结构</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112548.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113698.png" alt="image"></p><h5 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h5><p>字符串指针，指向导入函数所属的库文件名字。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113795.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113568.png" alt="image"></p><p>RVA要转成FOA，参考下面的实际计算</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114790.png" alt="image"></p><p>因为指向的是assic码的字符串，所以到第一个00结束</p><h5 id="OringinalFirstThunk-INT"><a href="#OringinalFirstThunk-INT" class="headerlink" title="OringinalFirstThunk-INT"></a>OringinalFirstThunk-INT</h5><p>导入名称表<img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114717.png" alt="image"></p><h5 id="FirstThunk-IAT"><a href="#FirstThunk-IAT" class="headerlink" title="FirstThunk-IAT"></a>FirstThunk-IAT</h5><p>导入地址表</p><h4 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052115276.png" alt="image"></p><p>Export Directory RVA：93 5D 82 09-&gt;0x09825D93(imagebase:0x00000010)查了一下再rdata段-&gt;FOA：0x09825D83</p><p>Export Directory Size：00033669</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116225.png" alt="image"></p><p>看了010半天不对，dumpbin /headers看了一下，然后又开了个exe，发现这个爆红的意思是typora.exe没有导入表导出表。。。(也有可能有加壳？die看了一下没有，但是这个地址太大了不正常)</p><pre><code>dumpbin /headers &quot;D:\Typora\Typora\Typora.exe&quot;</code></pre><p>换个文件来</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116588.png" alt="image"></p><p>Import Directory RVA：0x00003824，在.rdata段，rdata段的RVA是0x00003000，所以相对地址就是0x00000824，rdata段的raw address是0x00001A00，所以FOA是0x00002224，大小是C8字节</p><p><strong>Import Directory RVA</strong>：0x00003824</p><p><strong>.rdata段的 RVA</strong>：0x00003000</p><p><strong>.rdata段的 Raw Address</strong>：0x00001A00</p><p><strong>.rdata段的 Raw Size</strong>：C8 字节（即 200 字节）</p><pre class="line-numbers language-lang-mathematica"><code class="language-lang-mathematica">相对地址 = Import Directory RVA - .rdata段的 RVA = 0x00003824 - 0x00003000 = 0x00000824FOA = .rdata段的 Raw Address + 相对地址 =0x00001A00 + 0x00000824 = 0x00002224<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116426.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF</title>
      <link href="/2025/01/05/NSSCTF/"/>
      <url>/2025/01/05/NSSCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h3 id="easyRE（虚函数表-反调试-内联函数）"><a href="#easyRE（虚函数表-反调试-内联函数）" class="headerlink" title="easyRE（虚函数表+反调试+内联函数）"></a>easyRE（虚函数表+反调试+内联函数）</h3><p><a href="https://www.nssctf.cn/problem/43">[SWPU 2019]easyRE | NSSCTF</a></p><p>没做出来，看了佬的wp才理清思路<a href="https://bbs.kanxue.com/thread-271798.htm#msg_header_h3_2">[原创] SWPUCTF 2019 easyRE-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  _DWORD v4[30]; // [esp-6Ch] [ebp-F8h] BYREF  int v5; // [esp+Ch] [ebp-80h]  _DWORD v6[27]; // [esp+10h] [ebp-7Ch] BYREF  int v7; // [esp+88h] [ebp-4h]  if ( sub_40EF90() )    return 1;                                   // 反调试  sub_4026C0(0x6Cu);  sub_401FE0(v6);                               // vftable虚函数表  v7 = 0;  v4[29] = v4;  sub_40F360(v4, v6);  sub_40F080(v4[0], v4[1]);  v4[28] = v4;  sub_40F360(v4, v6);  sub_40F150(argc, (int)argv);  v5 = 0;  v7 = -1;  sub_4021C0(v6);  return v5;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反调试patch掉就行</p><h5 id="sub-401FE0"><a href="#sub-401FE0" class="headerlink" title="sub_401FE0"></a>sub_401FE0</h5><p>这里创建了一个虚函数表，下面的偏移是对比用的。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">_DWORD *__thiscall sub_401FE0(_DWORD *this)&#123;  int i; // [esp+4h] [ebp-14h]  *this = &EASYRE::`vftable';  this[1] = 0;  *((_BYTE *)this + 52) = 8;  *((_BYTE *)this + 53) = 0xEA;  *((_BYTE *)this + 54) = 0x58;  *((_BYTE *)this + 55) = 0xDE;  *((_BYTE *)this + 56) = 0x94;  *((_BYTE *)this + 57) = 0xD0;  *((_BYTE *)this + 58) = 0x3B;  *((_BYTE *)this + 59) = 0xBE;  *((_BYTE *)this + 60) = 0x88;  *((_BYTE *)this + 61) = 0xD4;  *((_BYTE *)this + 62) = 0x32;  *((_BYTE *)this + 63) = 0xB6;  *((_BYTE *)this + 64) = 0x14;  *((_BYTE *)this + 65) = 0x82;  *((_BYTE *)this + 66) = 0xB7;  *((_BYTE *)this + 67) = 0xAF;  *((_BYTE *)this + 68) = 0x14;  *((_BYTE *)this + 69) = 0x54;  *((_BYTE *)this + 70) = 0x7F;  *((_BYTE *)this + 71) = 0xCF;  qmemcpy(this + 0x12, "  03\"3   0 203\"   $ ", 20);  sub_4030A0(this + 0x17);  sub_402DE0(this + 0x1A);  for ( i = 0; i < 40; ++i )    *((_BYTE *)this + i + 12) = 0;  return this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>.rdata:004124E4 90 21 40 00                   ??_7EASYRE@@6B@ dd offset sub_402190    ; DATA XREF: sub_401FE0+2B↑o.rdata:004124E4                                                                       ; sub_4021C0+A↑o.rdata:004124E4                                                                       ; sub_40F360+C↑o.rdata:004124E8 F0 21 40 00                   dd offset sub_4021F0.rdata:004124EC B0 24 40 00                   dd offset sub_4024B0.rdata:004124F0 00 25 40 00                   dd offset sub_402500.rdata:004124F4 F0 22 40 00                   dd offset sub_4022F0.rdata:004124F8 A0 23 40 00                   dd offset sub_4023A0.rdata:004124FC E0 26 40 00                   dd offset sub_4026E0.rdata:00412500 30 27 40 00                   dd offset sub_402730.rdata:00412504 E0 23 40 00                   dd offset sub_4023E0.rdata:00412508 A0 28 40 00                   dd offset sub_4028A0.rdata:0041250C 00 2A 40 00                   dd offset sub_402A00.rdata:00412510 40 24 40 00                   dd offset sub_402440.rdata:00412514 00 00 00 00                   align 8</code></pre><p>​    </p><h4 id="sub-40F150"><a href="#sub-40F150" class="headerlink" title="sub_40F150"></a>sub_40F150</h4><p>找到对比函数</p><p> if ( sub_A124B0(va, input) )输出congratulations说明sub_A124B0是我们主要关注的函数</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int sub_40F150(int a1, int a2, ...)&#123;  int v2; // eax  int v3; // eax  int v5; // eax  int v6[10]; // [esp+Ch] [ebp-38h] BYREF  int v7; // [esp+40h] [ebp-4h]  va_list va; // [esp+54h] [ebp+10h] BYREF  va_start(va, a2);  v7 = 0;  memset(v6, 0, sizeof(v6));  v2 = printf(std::cout, "Please input your flag : ");  std::ostream::operator<<(v2, sub_40F8F0);  sub_40F930(std::cin, v6);  if ( sub_4024B0(v6) )  &#123;    v3 = printf(std::cout, &unk_4122F0);        // congratulations                                                //     std::ostream::operator<<(v3, sub_40F8F0);    v7 = -1;    sub_4021C0(va);    return 1;  &#125;  else  &#123;    v5 = printf(std::cout, &unk_41231C);        // sorry，try again    std::ostream::operator<<(v5, sub_40F8F0);    v7 = -1;    sub_4021C0(va);    return 0;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sub-4024B0"><a href="#sub-4024B0" class="headerlink" title="sub_4024B0"></a>sub_4024B0</h5><p>对照虚函数表</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">BOOL __thiscall sub_D724B0(_DWORD *this, int a2)&#123;  BOOL result; // eax  this[2] = a2;  result = 0;  if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) )// sub_402500 00D72500  &#123;    (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this);// sub_4026E0 00D824FC    if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) )// sub_402A00 00D72A00      return 1;  &#125;  return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化一下就是</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">if sub_402500（）    sub_4026E0（）    if sub_402A00()    return 1return 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sub-D72500"><a href="#sub-D72500" class="headerlink" title="sub_D72500"></a>sub_D72500</h5><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int __thiscall sub_D72500(const char **this)&#123;  int v2; // [esp+Ch] [ebp-B0h]  const char *v3; // [esp+14h] [ebp-A8h]  int i; // [esp+24h] [ebp-98h]  char v6[56]; // [esp+30h] [ebp-8Ch] BYREF  char v7[20]; // [esp+68h] [ebp-54h] BYREF  char v8[48]; // [esp+7Ch] [ebp-40h] BYREF  int v9; // [esp+B8h] [ebp-4h]  v3 = &this[2][strlen(this[2])];  strcpy(v8, "Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm");  sub_D726C0(v6, 0x38u);                        // 初始化v6  sub_D72B00(v6);  v9 = 0;  for ( i = 0; i < 45; ++i )    v8[i] ^= 0x10u;                             // ^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;  sub_D726C0(v7, 0x14u);  sub_D72A70(v8, 1);  LOBYTE(v9) = 1;  v2 = (unsigned __int8)sub_D74260(this[2], v3, v6, v7, 0);  LOBYTE(v9) = 0;  sub_D72A50(v7);  v9 = -1;  sub_D726A0();  return v2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501031630537.png" alt="1735892999415.png"></p><pre><code>^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</code></pre><p>有点像正则表达式，估计是flag格式</p><h5 id="sub-A12730"><a href="#sub-A12730" class="headerlink" title="sub_A12730"></a>sub_A12730</h5><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">int __thiscall sub_A12730(_DWORD *this, int a2)&#123;  int v2; // esi  int v3; // ecx  unsigned __int8 v4; // al  char v6; // cf  char v7; // bl  char v8; // t2  int v10; // [esp+Ch] [ebp-30h]  int i; // [esp+14h] [ebp-28h]  int j; // [esp+1Ch] [ebp-20h]  int v13; // [esp+20h] [ebp-1Ch] BYREF  int v14; // [esp+24h] [ebp-18h]  int v15; // [esp+28h] [ebp-14h]  int v16; // [esp+2Ch] [ebp-10h]  int v17; // [esp+30h] [ebp-Ch]  int v18; // [esp+34h] [ebp-8h]  v13 = 0;  v14 = 0;  v15 = 0;  v16 = 0;  v17 = 0;  v18 = 0;  v10 = this[2] + 5 * a2 + 8;  for ( i = 0; i < 4; ++i )    *(&v13 + i) = *(i + v10);  v2 = 0;  v3 = 4;  do  &#123;    v4 = *(&v13 + v2);                          // 取单个字符    _DL = v4;    __asm &#123; rcl     dl, 1 &#125;                     // 循环左移直到CF为1    *(&v15 + v2) = 1;                           // 将1写入v15 v2个字节的位置    v7 = 0;    v6 = 0;    do                                          // v8=v6左移7位                                                // v6=v4最低位                                                // v4去掉最低有效位    &#123;      v8 = v6 << 7;      v6 = v4 & 1;      v4 = (v4 >> 1) | v8;      ++v7;                                     // v7计算v4中1的个数    &#125;    while ( v6 );                               // 如果v6为1 即v4的当前最低有效位是 1，继续循环，                                                // v6为0则结束循环    *(&v16 + v2++) = v7 - 1;                    // 位宽度v16=v7-1    --v3;  &#125;  while ( v3 );  for ( j = 0; j < 4; ++j )  &#123;    *(&v14 + j) = *(&v16 + j) + *(&v15 + j);    // 右边0的个数+左移至进位个数    *(&v17 + j) = *(&v13 + j) << *(&v15 + j);   // flag<<左移至进位个数    *(&v18 + j) = (*(&v13 + j) << (8 - *(&v16 + j))) | ((*(&v13 + j) >> (8 - *(&v15 + j))) << *(&v15 + j));  &#125;                                             // [flag<<（8-右边0的个数）]|&#123;[flag>>(8-左移至进位个数）]<<左移至进位个数&#125;  return sub_A12F80(&v13);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外面的dowhile其实是在计算左移几位CF为1，里面的dowhile是在计算右边0的个数</p><h5 id="sub-A128A0"><a href="#sub-A128A0" class="headerlink" title="sub_A128A0"></a>sub_A128A0</h5><p>不想看了，大概看看感觉能爆破，不行再回来看</p><p>好吧还是得看</p><p>for循环嵌套if else，大概把上面加密完的flag分为两个部分处理。</p><p>前四次循环走else，对 <code>v15 + i + 20</code> 赋值</p><p>后四次走if，对 <code>v17 + 0x1A</code> 进行操作，更新 <code>v14</code> 并对 <code>v15</code> 执行位操作。</p><pre><code>v17 = this;v15 = this + 3;*v15 |= *(v10 + i + 0x10) &lt;&lt; v14;*v15 |= *(v5 + i + 0x10) &lt;&lt; v14;*(v15 + i + 20) = *(v8 + i + 0xC) | v7;</code></pre><p>因为我们前面得到了flag格式，可以判断出来while走5次。</p><p>一个参与了加密一个没参与</p><p>这里用了佬简化完的加密</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">if &#123;    v9 = sub_402DC0(v17 + 26);    v14 -= *(unsigned __int8 *)(v9 + i); // v14的初始值为0x20    *v15 |= res3 << v14;&#125;   else &#123;    v14 -= 8 - res1;    *v15 |= res2 << v14;    *((_BYTE *)v15 + i + 20) = 0的个数 | (16 * 左移进位位数);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理一下逻辑</p><ul><li>校验flag格式</li><li>加密</li><li>5次循环处理加密，两种结果，一个受字符影响一个独立存在。</li><li>对比</li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">#expimport string# 检查左移进位位数def check_1(c):     num = 0    while True:        c = c << 1        num += 1        if c & 0x100:            return num# 检查右边0的个数def check_0(c):     num = 0    while True:        if c & 1:            return num        num += 1        c = c >> 1# 生成标识符def generate_0(c):    res1 = check_0(c) + check_1(c)    res2 = ((c << check_1(c)) & 0xff) >> res1    res3 = ((c >> (8 - check_1(c))) << check_1(c)) | ((c << (8 - check_0(c)) & 0xff) >> res1)    return [res1, res2, res3]def check_part(c,s2):    """检查字符的分类，并返回符合条件的字符"""    tmp = list(set('  03\"3   0 203\"   $ '))    tmp2=check_0(c) | (16*check_1(c))    for i in set(s2):        if tmp2 ==ord(i):            return i    return ''def classify():    for_each=string.ascii_lowercase+string.ascii_uppercase+string.digits    second_part_res = '  03\"3   0 203\"   $ '    d=dict.fromkeys(list(set(second_part_res)))    for i in list(set(second_part_res)):        d[i]=[]    for i in for_each:        tmp=check_part(ord(i))        if tmp:            d[tmp].append(i)    return ddef test_1(c,v14):    exam=&#123;c:generate_0(ord(c))&#125;    v14=v14-(8-exam[c][0])    tmp=exam[c][1]<<v14    return tmp,v14def test_2(c,v14):    exam=&#123;c:generate_0(ord(c))&#125;    v14=v14-exam[c][0]    tmp=exam[c][2]<<v14    return tmp,v14import string# 检查左移进位位数def check_1(c):     num = 0    while True:        c = c << 1        num += 1        if c & 0x100:            return num# 检查右边0的个数def check_0(c):     num = 0    while True:        if c & 1:            return num        num += 1        c = c >> 1# 生成标识符def generate_0(c):    res1 = check_0(c) + check_1(c)    res2 = ((c << check_1(c)) & 0xff) >> res1    res3 = ((c >> (8 - check_1(c))) << check_1(c)) | ((c << (8 - check_0(c)) & 0xff) >> res1)    return [res1, res2, res3]# 分类检查def check_part(c):    tmp = list(set('  03\"3   0 203\"   $ '))    tmp2 = check_0(c) | (16 * check_1(c))    for i in tmp:        if tmp2 == ord(i):            return i    return ''# 分类函数def classify():    for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits    second_part_res = '  03\"3   0 203\"   $ '    d = dict.fromkeys(list(set(second_part_res)))    for i in list(set(second_part_res)):        d[i] = []    for i in for_each:        tmp = check_part(ord(i))        if tmp:            d[tmp].append(i)    return d# 测试函数1def test_1(c, v14):    exam = &#123;c: generate_0(ord(c))&#125;    v14 = v14 - (8 - exam[c][0])    tmp = exam[c][1] << v14    return tmp, v14# 测试函数2def test_2(c, v14):    exam = &#123;c: generate_0(ord(c))&#125;    v14 = v14 - exam[c][0]    tmp = exam[c][2] << v14    return tmp, v14# 计算第一个部分def calc_first_part(s):    v14 = 0x20    tmp, v14 = test_1(s[0], v14)    tmp2, v14 = test_1(s[1], v14)    tmp3, v14 = test_1(s[2], v14)    tmp4, v14 = test_1(s[3], v14)    tmp5, v14 = test_2(s[0], v14)    tmp6, v14 = test_2(s[1], v14)    tmp7, v14 = test_2(s[2], v14)    tmp8, v14 = test_2(s[3], v14)    return tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8# 检查第一个部分def check_first_part(second_part, first_part, d):    for i in d[second_part[0]]:        for j in d[second_part[1]]:            for k in d[second_part[2]]:                for m in d[second_part[3]]:                    tmp = i + j + k + m                    if calc_first_part(tmp) == first_part:                        return tmp# 主程序d = classify()s2 = '  03\"3   0 203\"   $ 's = ['08', 'EA', '58', 'DE', '94', 'D0', '3B', 'BE', '88', 'D4', '32', 'B6', '14', '82', 'B7', 'AF', '14', '54', '7F', 'CF']flag = 'swpuctf&#123;'for i in range(0, 5):    first_part = int(s[3 + 4 * i] + s[2 + 4 * i] + s[1 + 4 * i] + s[4 * i], 16)    second_part = s2[i * 4:i * 4 + 4]    res = check_first_part(second_part, first_part, d)    if i == 4:        flag += res        break    flag += res + '-'flag += '&#125;'print(flag)#swpuctf&#123;we18-l8co-m1e4-58to-swpu&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="EasiestRe（双进程-自修改-背包加密）"><a href="#EasiestRe（双进程-自修改-背包加密）" class="headerlink" title="EasiestRe（双进程+自修改+背包加密）"></a>EasiestRe（双进程+自修改+背包加密）</h3><p><a href="https://www.nssctf.cn/problem/40">[SWPU 2019]EasiestRe | NSSCTF</a></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><h5 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h5><p>进来先看到IsDebuggerPresent，运行一下发现和直接打开的结果不一样，双进程。</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">  if ( IsDebuggerPresent() )  //调试器进程  .....  if ( CreateProcessA(Filename, 0, 0, 0, 0, 3u, 0, 0, &StartupInfo, &ProcessInformation) )  //正常进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c"><code class="language-lang-c">int __cdecl main_0(int argc, const char **argv, const char **envp)&#123;  PVOID lpBaseAddress; // [esp+18h] [ebp-558h]  char v5; // [esp+1Fh] [ebp-551h]  DWORD dwContinueStatus; // [esp+20h] [ebp-550h]  struct _DEBUG_EVENT DebugEvent; // [esp+28h] [ebp-548h] BYREF  char v8; // [esp+8Fh] [ebp-4E1h]  CONTEXT Context; // [esp+94h] [ebp-4DCh] BYREF  HANDLE hThread; // [esp+364h] [ebp-20Ch]  int i; // [esp+368h] [ebp-208h]  SIZE_T NumberOfBytesRead[3]; // [esp+370h] [ebp-200h] BYREF  SIZE_T NumberOfBytesWritten[3]; // [esp+37Ch] [ebp-1F4h] BYREF  char Buffer[60]; // [esp+388h] [ebp-1E8h] BYREF  char v15[40]; // [esp+3C4h] [ebp-1ACh] BYREF  char v16[16]; // [esp+3ECh] [ebp-184h] BYREF  struct _STARTUPINFOA StartupInfo; // [esp+3FCh] [ebp-174h] BYREF  struct _PROCESS_INFORMATION ProcessInformation; // [esp+448h] [ebp-128h] BYREF  CHAR Filename[267]; // [esp+460h] [ebp-110h] BYREF  memset(&ProcessInformation, 0, sizeof(ProcessInformation));  j__memset(&StartupInfo, 0, sizeof(StartupInfo));  v16[0] = 0x90;  v16[1] = 0x83;  v16[2] = 0x7D;  v16[3] = 0xF8;  v16[4] = 0x18;  v16[5] = 0x7D;  v16[6] = 0x11;  v15[0] = 0x90;  v15[1] = 0xF;  v15[2] = 0xB6;  v15[3] = 0x55;  v15[4] = 0xF7;  v15[5] = 0x8B;  v15[6] = 0x45;  v15[7] = 8;  v15[8] = 0x8B;  v15[9] = 4;  v15[10] = 0x90;  v15[11] = 0xF;  v15[12] = 0xAF;  v15[13] = 0x45;  v15[14] = 0xFC;  v15[15] = 0x33;  v15[16] = 0xD2;  v15[17] = 0xF7;  v15[18] = 0x75;  v15[19] = 0xF8;  v15[20] = 0xF;  v15[21] = 0xB6;  v15[22] = 0x4D;  v15[23] = 0xF7;  v15[24] = 0x8B;  v15[25] = 0x45;  v15[26] = 0xC;  v15[27] = 0x89;  v15[28] = 0x14;  v15[29] = 0x88;  j__memset(Buffer, 0, 0x32u);  NumberOfBytesWritten[0] = 0;  i = 0;  v8 = 1;  if ( IsDebuggerPresent() )                    // 调试器进程  &#123;    GetStartupInfoA(&StartupInfo);    GetModuleFileNameA(0, Filename, 0x104u);    if ( CreateProcessA(Filename, 0, 0, 0, 0, 3u, 0, 0, &StartupInfo, &ProcessInformation) )// 创建新进程    &#123;      v5 = 1;LABEL_6:      while ( v5 )      &#123;        dwContinueStatus = 0x10002;        WaitForDebugEvent(&DebugEvent, 0xFFFFFFFF);        switch ( DebugEvent.dwDebugEventCode )  // 处理调试事件        &#123;          case 1u:            if ( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode == 0x80000003 )// 遇到调试断点            &#123;              v8 = 1;                           // 继续执行程序，跳过当前异常              dwContinueStatus = 0x10002;              lpBaseAddress = DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress;// 保存异常的地址（即断点地址）              ReadProcessMemory(                // 读取 35 字节的内存数据到buffer里                ProcessInformation.hProcess,                DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,                Buffer,                0x23u,                NumberOfBytesRead);              if ( NumberOfBytesRead[0] )              &#123;                for ( i = 1; i < 35 && Buffer[i] == 0x90; ++i )// 检查nop                  ;              &#125;              if ( i == 1 )                v8 = 0;              if ( v8 )                         // v8非0则继续执行，v8为0则跳转到dwContinueStatus = 0x80010001;              &#123;                switch ( i )                &#123;                  case 4:                    Context.ContextFlags = 65543;                    hThread = OpenThread(0x1FFFFFu, 0, DebugEvent.dwThreadId);                    if ( !GetThreadContext(hThread, &Context) )                      goto LABEL_31;                    ++Context.Eip;                    if ( SetThreadContext(hThread, &Context) )                    &#123;                      dwContinueStatus = 0x10002;                      CloseHandle(hThread);                    &#125;                    goto LABEL_33;                  case 5:LABEL_31:                    ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x80010001);                    goto LABEL_6;                  case 7:                       // 将v16的数据写入lpBaseAddress                                                // 然后读取lpBaseAddress 处的数据并存储在 Buffer 中                                                // 成功写入 7 字节数据则继续执行程序                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, 7u, NumberOfBytesWritten);                    if ( NumberOfBytesWritten[0] == 7 )                    &#123;                      ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, 7u, NumberOfBytesRead);                      dwContinueStatus = 65538;                    &#125;                    goto LABEL_33;                  case 30:                      // v15 中的 30 字节数据写入lpBaseAddress                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v15, 0x1Eu, NumberOfBytesWritten);                    if ( NumberOfBytesWritten[0] == 30 )                      dwContinueStatus = 65538;                    goto LABEL_33;                  default:                      // i！=4，5，7，30                    goto LABEL_33;                &#125;              &#125;              dwContinueStatus = 0x80010001;            &#125;            goto LABEL_33;          case 2u:          case 3u:            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x10002u);            break;          case 4u:          case 5u:            v5 = 0;            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x10002u);            break;          case 6u:            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x10002u);            break;          default:LABEL_33:            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinueStatus);            break;        &#125;      &#125;      return 0;    &#125;    else    &#123;      return 0;    &#125;  &#125;  else  &#123;    sub_F53922();    return 0;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sub-F58A40"><a href="#sub-F58A40" class="headerlink" title="sub_F58A40"></a>sub_F58A40</h5><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">text:00F58AF8                 int     3               ; Trap to Debuggertext:00F58AF9                 noptext:00F58AFA                 noptext:00F58AFB                 noptext:00F58AFC                 noptext:00F58AFD                 noptext:00F58AFE                 noptext:00F58AFF                 push    offset aYouAreTooShort ; "you are too short!"text:00F58B04                 call    printf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据上面的分析，遇到int 3会写入v16 7字节的数据</p><pre class="line-numbers language-lang-c"><code class="language-lang-c"> case 7:                                          WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, 7u, NumberOfBytesWritten);                    if ( NumberOfBytesWritten[0] == 7 )                    &#123;                      ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, 7u, NumberOfBytesRead);                      dwContinueStatus = 65538;                    &#125;                    goto LABEL_33;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>paste data就行</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501051651130.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识IDApython&amp;IDC</title>
      <link href="/2024/12/30/%E5%88%9D%E8%AF%86IDApython/"/>
      <url>/2024/12/30/%E5%88%9D%E8%AF%86IDApython/</url>
      
        <content type="html"><![CDATA[<h2 id="IDApython-amp-IDC"><a href="#IDApython-amp-IDC" class="headerlink" title="IDApython&amp;IDC"></a>IDApython&amp;IDC</h2><p>IDApython官方文档：<a href="https://docs.hex-rays.com/developer-guide/idapython">IDAPython | Hex-Rays Docs</a></p><p>IDC官方文档：<a href="https://docs.hex-rays.com/developer-guide/idc">IDC | Hex-Rays Docs</a></p><h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><h4 id="1-IDC"><a href="#1-IDC" class="headerlink" title="1.IDC"></a>1.IDC</h4><p>与IDA命令行进行交互的模块，提供了很多IDA中指令相关的函数。</p><ul><li><strong><code>idc.get_name(ea)</code></strong>：获取地址 <code>ea</code> 处的名称。</li><li><strong><code>idc.get_func_name(ea)</code></strong>：获取函数地址处的函数名称。</li><li><strong><code>idc.set_name(ea, name)</code></strong>：为地址 <code>ea</code> 设置一个新的名称。</li><li><strong><code>idc.add_entry(ea, name, start, end)</code></strong>：在 <code>ea</code> 处添加一个入口点。</li><li><strong><code>idc.get_func(ea)</code></strong>：获取 <code>ea</code> 处的函数结构。</li></ul><h4 id="2-IDAAPI"><a href="#2-IDAAPI" class="headerlink" title="2.IDAAPI"></a>2.IDAAPI</h4><p>与 IDA 的核心 API 交互的主要模块。包括了对 IDA 核心对象的访问，涵盖了地址、函数、节等许多底层操作。</p><ul><li><p><strong><code>idaapi.get_func(ea)</code></strong>：返回地址 <code>ea</code> 处的函数对象。</p></li><li><p><strong><code>idaapi.get_flags(ea)</code></strong>：返回地址 <code>ea</code> 的标志，表示它是代码、数据还是其他类型。</p></li><li><p><strong><code>idaapi.create_data(ea, size, type)</code></strong>：在地址 <code>ea</code> 处创建数据。</p></li><li><p><strong><code>idaapi.get_strlit_contents(ea)</code></strong>：获取 <code>ea</code> 处的字符串内容。</p></li><li><p><strong><code>idaapi.add_func(ea)</code></strong>：将地址 <code>ea</code> 添加为一个函数。</p></li></ul><h4 id="3-IDAUTILS"><a href="#3-IDAUTILS" class="headerlink" title="3.IDAUTILS"></a>3.IDAUTILS</h4><p>工具函数，帮助在反汇编中自动化和简化分析过程。</p><ul><li><p><strong><code>idautils.Functions(start, end)</code></strong>：遍历在 <code>start</code> 到 <code>end</code> 地址范围内的所有函数。</p></li><li><p><strong><code>idautils.DecodeInstruction(ea)</code></strong>：解码地址 <code>ea</code> 处的指令。</p></li><li><p><strong><code>idautils.FindBinary(start, end, pattern, flags)</code></strong>：在指定范围内查找与模式匹配的二进制数据。</p></li><li><p><strong><code>idautils.Heads(start, end)</code></strong>：遍历地址范围内的所有指令地址。</p></li></ul><h4 id="4-ida-bytes"><a href="#4-ida-bytes" class="headerlink" title="4.ida_bytes"></a>4.ida_bytes</h4><p><code>ida_bytes</code> 提供了对内存区域字节级别操作的函数。</p><ul><li><strong><code>ida_bytes.get_byte(ea)</code></strong>：获取 <code>ea</code> 处的一个字节</li><li><strong><code>ida_bytes.get_word(ea)</code></strong>：获取 <code>ea</code> 处的一个字.</li><li><strong><code>ida_bytes.get_dword(ea)</code></strong>：获取 <code>ea</code> 处的一个双字。</li></ul><h4 id="5-ida-struct"><a href="#5-ida-struct" class="headerlink" title="5.ida_struct"></a>5.ida_struct</h4><p><code>ida_struct</code> 处理 IDA 中的结构体。你可以使用它来读取、创建、修改和设置结构体。</p><ul><li><p><strong><code>ida_struct.get_struc_name(struc)</code></strong>：获取结构体的名称。</p></li><li><p><strong><code>ida_struct.add_struc()</code></strong>：添加一个新的结构体。</p></li><li><p><strong><code>ida_struct.set_struc_member()</code></strong>：设置结构体成员的属性。</p></li></ul><h4 id="6-ida-diskio"><a href="#6-ida-diskio" class="headerlink" title="6.ida_diskio"></a>6.ida_diskio</h4><p><code>ida_diskio</code> 提供了与磁盘 IO 操作相关的函数，例如读取或写入文件。</p><ul><li><p><strong><code>ida_diskio.get_input_file_path()</code></strong>：获取当前输入文件的路径。</p></li><li><p><strong><code>ida_diskio.save_input_file()</code></strong>：保存当前输入文件。</p></li></ul><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="创建-删除函数"><a href="#创建-删除函数" class="headerlink" title="创建/删除函数"></a>创建/删除函数</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">idc.add_func(0x401000, 0x401050)  # Create a function starting at 0x401000 and ending at 0x401050idc.del_func(0x401000)  # Delete the function at 0x401000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取函数的名称"><a href="#获取函数的名称" class="headerlink" title="获取函数的名称"></a>获取函数的名称</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">get_func_name(ea)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="遍历所有函数并打印其有效地址和名称"><a href="#遍历所有函数并打印其有效地址和名称" class="headerlink" title="遍历所有函数并打印其有效地址和名称"></a>遍历所有函数并打印其有效地址和名称</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">for func_ea in idautils.Functions(): func_name = idc.get_func_name(func_ea); print(hex(func_ea), func_name)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="列出对地址的交叉引用"><a href="#列出对地址的交叉引用" class="headerlink" title="列出对地址的交叉引用"></a>列出对地址的交叉引用</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">for xref in idautils.XrefsTo(0x401000):    print(f"Xref to 0x401000 from &#123;hex(xref.frm)&#125;")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="列出地址的交叉引用："><a href="#列出地址的交叉引用：" class="headerlink" title="列出地址的交叉引用："></a>列出地址的交叉引用：</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">for xref in idautils.XrefsFrom(0x401000):    print(f"Xref from 0x401000 to &#123;hex(xref.to)&#125;")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="遍历所有交叉引用并打印"><a href="#遍历所有交叉引用并打印" class="headerlink" title="遍历所有交叉引用并打印"></a>遍历所有交叉引用并打印</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">for ref in idautils.XrefsTo(ea):  print(hex(ref.frm))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="文本-指令搜索"><a href="#文本-指令搜索" class="headerlink" title="文本/指令搜索"></a>文本/指令搜索</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">#搜索字符串import idautilsimport idc# 搜索整个内存区域的字符串def search_string(pattern):    for ea in idautils.Strings():        if pattern in ea:            print(f"Found string at &#123;hex(ea)&#125;: &#123;ea&#125;")# 搜索 "Hello" 字符串search_string("Hello")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">#搜索汇编指令import idautilsimport idcdef search_asm_instruction(pattern):    # 遍历整个程序的所有指令    for ea in idautils.Heads(idc.get_segm_by_name(".text"), idc.get_segm_end(idc.get_segm_by_name(".text"))):        disasm = idc.GetDisasm(ea)  # 获取地址处的反汇编指令        if pattern in disasm:            print(f"Found instruction at &#123;hex(ea)&#125;: &#123;disasm&#125;")# 搜索 "mov eax, ebx" 指令search_asm_instruction("mov eax, ebx")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA, Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识TCP</title>
      <link href="/2024/12/27/%E5%88%9D%E8%AF%86TCP/"/>
      <url>/2024/12/27/%E5%88%9D%E8%AF%86TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="一、TCP特点"><a href="#一、TCP特点" class="headerlink" title="一、TCP特点"></a>一、TCP特点</h3><ol><li><p>面向连接的协议，在传输数据前需要建立一条可靠连接</p></li><li><p>流式协议，TCP将数据看作字节流。传输过程中数据是可以被分割为多个数据包在接收端重新组装的。</p></li><li><p>TCP通过校验和\序列号和确认应答来确保数据的可靠传输，出错回重新传输。</p></li><li><p>服务器被动连接，客户端主动连接。</p></li></ol><h3 id="二、TCP编程"><a href="#二、TCP编程" class="headerlink" title="二、TCP编程"></a>二、TCP编程</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><h5 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1.创建套接字socket()"></a>1.创建套接字socket()</h5><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <sys/types.h>#include <sys/socket.h>int socket(int domain, int type, int protocol);功能：    创建一个套接字，返回一个文件描述符参数：    domain：通信域，协议族      AF_UNIX 本地通信      AF_INET ipv4网络协议      AF_INET6 ipv6网络协议      AF_PACKET 底层接口    type：套接字的类型      SOCK_STREAM 流式套接字（tcp）      SOCK_DGRAM 数据报套接字（udp）      SOCK_RAW 原始套接字（用于链路层）    protocol：附加协议，如果不需要，则设置为0返回值：    成功：文件描述符    失败：‐1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-绑定套接字bind"><a href="#2-绑定套接字bind" class="headerlink" title="2.绑定套接字bind()"></a>2.绑定套接字bind()</h5><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);功能：    将套接字与网络信息结构体绑定参数：    sockfd：文件描述符，socket的返回值    addr：网络信息结构体      通用结构体（一般不用）      struct sockaddr      网络信息结构体 sockaddr_in#include &lt;netinet/in.h&gt;struct sockaddr_inaddrlen：    addr的长度返回值：    成功：0    失败：-1</code></pre><h5 id="3-监听套接字listen"><a href="#3-监听套接字listen" class="headerlink" title="3.监听套接字listen()"></a>3.监听套接字listen()</h5><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <sys/types.h> /* See NOTES */#include <sys/socket.h>int listen(int sockfd, int backlog);功能：    将套接字设置为被动监听状态，这样做之后就可以接收到连接请求参数：    sockfd：文件描述符，socket函数返回值    backlog：允许通信连接的主机个数，一般设置为5、10返回值：    成功：0    失败：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-接收连接accept"><a href="#4-接收连接accept" class="headerlink" title="4.接收连接accept()"></a>4.接收连接accept()</h5><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <sys/types.h> /* See NOTES */#include <sys/socket.h>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);功能：    阻塞等待客户端的连接请求参数：    sockfd：文件描述符，socket函数的返回值    addr：接收到的客户端的信息结构体（自动填充，定义变量即可）    addrlen：addr的长度返回值：    成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，这个新的文件描述符专门与指定的客户端进行通信的）    失败：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-通信recv-send"><a href="#5-通信recv-send" class="headerlink" title="5.通信recv()/send()"></a>5.通信recv()/send()</h5><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <sys/types.h>#include <sys/socket.h>ssize_t recv(int sockfd, void *buf, size_t len, int flags);功能：    接收数据参数：    sockfd：文件描述符客户端：socket函数的返回值服务器：accept函数的返回值    buf：保存接收到的数据    len：buf的长度    flags：标志位      0 阻塞      MSG_DONTWAIT 非阻塞返回值：    成功：接收的字节数    失败：-1如果发送端关闭文件描述符或者关闭进程，则recv函数会返回0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <sys/types.h>#include <sys/socket.h>ssize_t send(int sockfd, const void *buf, size_t len, int flags);功能：    发送数据参数：    sockfd：文件描述符客户端：    socket函数的返回值服务器：    accept函数的返回值     buf：发送的数据     len：buf的长度     flags：标志位       0 阻塞       MSG_DONTWAIT 非阻塞返回值：    成功：发送的字节数    失败：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6.关闭套接字()"></a>6.关闭套接字()</h5><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><h5 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket()"></a>1.socket()</h5><h5 id="2-connect"><a href="#2-connect" class="headerlink" title="2.connect()"></a>2.connect()</h5><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <sys/types.h> /* See NOTES */#include <sys/socket.h>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);功能：    给服务器发送客户端的连接请求参数：    sockfd：文件描述符，socket函数的返回值    addr：要连接的服务器的网络信息结构体（需要自己设置）    addrlen：add的长度返回值：    成功：0    失败：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-send-recv"><a href="#3-send-recv" class="headerlink" title="3.send()/recv()"></a>3.send()/recv()</h5><h5 id="4-close"><a href="#4-close" class="headerlink" title="4.close()"></a>4.close()</h5><h3 id="三、OSI模型"><a href="#三、OSI模型" class="headerlink" title="三、OSI模型"></a>三、OSI模型</h3><div class="table-container"><table><thead><tr><th>应用层</th><th>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等等</th></tr></thead><tbody><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP、等等</td></tr><tr><td>会话层</td><td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等等</td></tr><tr><td>传输层</td><td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等等</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等等</td></tr><tr><td>物理层</td><td>例如铜缆、网线、光缆、无线电等等</td></tr></tbody></table></div><p><img src="C:\Users\zmycm\AppData\Roaming\Typora\typora-user-images\image-20241124204619077.png" alt="image-20241124204619077"></p><h2 id="DTLS"><a href="#DTLS" class="headerlink" title="DTLS"></a>DTLS</h2><h3 id="1-1DTLS特点作用"><a href="#1-1DTLS特点作用" class="headerlink" title="1.1DTLS特点作用"></a>1.1DTLS特点作用</h3><p><strong>DTLS</strong>: 是一种面向<strong>无连接</strong>的协议，<strong>基于 UDP</strong>，<strong>作用</strong>为给UDP提供端到端的安全通道，就像SSL/TLS对TCP的作用一样。</p><p>SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。</p><p>没用到，用到再来补充</p>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<hr><p>layout: ‘[layout]’<br>title: X86汇编&amp;内联汇编<br>date: 2024-12-27 01:47:24<br>categories: </p><ul><li>笔记整理<br>tags: </li><li>汇编<br>top_img: <a href="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501021640040.png">https://raw.githubusercontent.com/QYQS1/picture/main/test/202501021640040.png</a><h2 id="X86汇编学习"><a href="#X86汇编学习" class="headerlink" title="X86汇编学习"></a>X86汇编学习</h2></li></ul><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>CPU控制整个计算机运作和运算。要想让CPU工作，就需要向它提供<strong>指令</strong>和<strong>数据</strong>。</p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><h5 id="（1）-汇编指令"><a href="#（1）-汇编指令" class="headerlink" title="（1）.汇编指令"></a>（1）.汇编指令</h5><p>直接被CPU执行的指令</p><h5 id="（2）-伪指令"><a href="#（2）-伪指令" class="headerlink" title="（2）.伪指令"></a>（2）.伪指令</h5><p>指导汇编器工作的指令，不生成机械码。</p><ul><li>段定义指令：如SEGMENT、ENDS，用于定义和结束一个段。</li><li>数据定义指令：如DB、DW，用于定义字节或字数据。</li><li>常量定义指令：如EQU，用于定义常量。</li></ul><h5 id="3-符号指令"><a href="#3-符号指令" class="headerlink" title="(3).符号指令"></a>(3).符号指令</h5><p>用于标识变量、常量、代码段等，在汇编过程中被替换为具体的地址或值。它们没有对应的机器码。</p><ul><li><p><strong>标签</strong>：用于标识代码中的位置。</p><pre class="line-numbers language-lang-css"><code class="language-lang-css">LABEL: ; 定义一个标签LABEL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>宏定义</strong>：如<code>MACRO</code>，用于定义宏，简化代码编写。</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">MYMACRO MACRO ; 宏定义内容 ENDM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="3-CPU对存储器的读写"><a href="#3-CPU对存储器的读写" class="headerlink" title="3.CPU对存储器的读写"></a>3.CPU对存储器的读写</h4><ol><li>存储单元的地址</li><li>控制信息</li><li>读或者写的数据</li></ol><h4 id="4-地址总线"><a href="#4-地址总线" class="headerlink" title="4.地址总线"></a>4.地址总线</h4><p>CPU通过地址总线来<strong>指定存储器单元</strong>。</p><p>一个CPU有N根地址线，则它的地址总线宽度为N，最多可以寻找2的N次方给内存单元。</p><p>CPU通过地址总线传入存储器的必须是一个内存单元的<strong>物理地址</strong>。</p><h4 id="5-数据总线"><a href="#5-数据总线" class="headerlink" title="5.数据总线"></a>5.数据总线</h4><p>CPU与内存或其他器件之间<strong>数据传送</strong>是通过数据总线进行的。</p><h4 id="6-控制总线"><a href="#6-控制总线" class="headerlink" title="6.控制总线"></a>6.控制总线</h4><p>CPU<strong>对外部器件的控制</strong>是通过控制总线进行的。</p><h4 id="7-内存地址空间"><a href="#7-内存地址空间" class="headerlink" title="7.内存地址空间"></a>7.内存地址空间</h4><p>8086CPU地址总线宽度为20，可以定位2的20次方个内存单元，那么内存地址空间为1MB。</p><h3 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h3><h4 id="（一）、通用寄存器"><a href="#（一）、通用寄存器" class="headerlink" title="（一）、通用寄存器"></a>（一）、通用寄存器</h4><h5 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="1.数据寄存器"></a>1.数据寄存器</h5><h6 id="（1）作为完整的32位数据寄存器"><a href="#（1）作为完整的32位数据寄存器" class="headerlink" title="（1）作为完整的32位数据寄存器"></a>（1）作为完整的32位数据寄存器</h6><ul><li>EAX，EBX，ECX，EDX</li></ul><h6 id="（2）下半部分作为16位寄存器"><a href="#（2）下半部分作为16位寄存器" class="headerlink" title="（2）下半部分作为16位寄存器"></a>（2）下半部分作为16位寄存器</h6><ul><li>AX：累加器</li><li>BX：基址寄存器</li><li>CX：计数寄存器</li><li>DX：数据寄存器</li></ul><h6 id="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"><a href="#（3）16位寄存器的下半部分和上半部分再作为8位寄存器" class="headerlink" title="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"></a>（3）16位寄存器的下半部分和上半部分再作为8位寄存器</h6><ul><li>AH,AL,BLH,BL</li><li>CH,CL,DH,DL</li></ul><h5 id="2-指针寄存器"><a href="#2-指针寄存器" class="headerlink" title="2.指针寄存器"></a>2.指针寄存器</h5><ul><li>指令指针（IP）</li><li>堆栈指针（SP）</li><li>基本指针（BP）</li></ul><h5 id="3-索引寄存器"><a href="#3-索引寄存器" class="headerlink" title="3.索引寄存器"></a>3.索引寄存器</h5><ul><li>源索引（SI）</li><li>DI</li></ul><h5 id="4-数据寄存器"><a href="#4-数据寄存器" class="headerlink" title="4.数据寄存器"></a>4.数据寄存器</h5><h4 id="（二）、控制寄存器"><a href="#（二）、控制寄存器" class="headerlink" title="（二）、控制寄存器"></a>（二）、控制寄存器</h4><p>将32位指令指针寄存器和32位标志寄存器组合。</p><h5 id="通用标志位"><a href="#通用标志位" class="headerlink" title="通用标志位"></a>通用标志位</h5><ul><li><strong>溢出标志（OF）</strong> -<u>有符号</u>算术运算后数据的高阶位（最左位）的溢出。</li><li><strong>方向标记（DF）</strong> -DF值为0时，字符串操作为从左至右的方向；当DF值为1时，字符串操作为从右至左的方向。</li><li><strong>中断标志（IF）</strong> -当值为0时，它禁用外部中断，而当值为1时，它使能中断。</li><li><strong>陷阱标志（TF）</strong> -允许在单步模式下设置处理器的操作。我们使用的DEBUG程序设置了陷阱标志，因此我们可以一次逐步执行一条指令。</li><li><strong>符号标志（SF）</strong> -正结果将SF的值清除为0，负结果将其设置为1。</li><li><strong>零标志（ZF）</strong> -非零结果将零标志清零，零结果将其清零。</li><li><strong>辅助进位标志（AF）</strong> -包含经过算术运算后从位3到位4的进位；用于专业算术。当1字节算术运算引起从第3位到第4位的进位时，将设置AF。</li><li><strong>奇偶校验标志（PF）</strong> -偶数个1位将奇偶校验标志清为0，奇数个1位将奇偶校验标志清为1。</li><li><strong>进位标志（CF）</strong> -在算术运算后，它包含一个高位（最左边）的0或1进位。</li></ul><h4 id="（三）、段寄存器"><a href="#（三）、段寄存器" class="headerlink" title="（三）、段寄存器"></a>（三）、段寄存器</h4><ul><li><strong>CS</strong>：<u><strong>代码段寄存器</strong></u>，包含当前正在执行的代码的段基址。</li><li><strong>DS</strong>：<strong><u>数据段寄存器</u></strong>，通常包含程序正在操作的数据的段基址。</li><li><strong>SS</strong>：<strong><u>堆栈段寄存器</u></strong>，包含当前堆栈的段基址。</li><li><strong>ES</strong>：<strong><u>附加段寄存器</u></strong>，用于存储其他数据段的基址。</li><li><strong>FS</strong></li><li><strong>GS</strong></li></ul><h4 id="（四）8086CPU给出物理地址的方法"><a href="#（四）8086CPU给出物理地址的方法" class="headerlink" title="（四）8086CPU给出物理地址的方法"></a>（四）8086CPU给出物理地址的方法</h4><p><strong>物理地址=段地址x16+偏移地址</strong></p><p>用两个16位地址（段地址、偏移地址）合成一个20位物理地址</p><p>段地址 x 16 是十六进制<strong>段地址数据左移一位</strong></p><h3 id="（三）、内存和寻址"><a href="#（三）、内存和寻址" class="headerlink" title="（三）、内存和寻址"></a>（三）、内存和寻址</h3><h4 id="段分布"><a href="#段分布" class="headerlink" title="段分布"></a>段分布</h4><ul><li><strong>text</strong>: 存放的是二进制机器码，用于存储程序中已初始化的全局变量和静态变量，只读</li><li><strong>.data</strong>: 用于存储程序中已初始化的全局变量和静态变量。非默认值</li><li><strong>.bss</strong>：存放未初始化的全局变量，或者默认初始化的全局变量。这一部分在二进制文件中不占硬盘空间，即不会真实存储这些为初始化的变量，而是在程序加载到内存时再分配。当然肯定需要有个标识，告诉该怎么分配内存</li><li><strong>.rodata</strong>：存放只读数据，如常量数据</li></ul><h4 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h4><p>.DATA声明静态数据区</p><p><strong>在汇编中只有一维数组</strong>，只有没有二维和多维数组。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li><strong>立即寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov rax, 123 ; rax = 123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>寄存器寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">add rax, rbx ; rax = rax + rbx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>直接寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, [someVariable] ; eax = contents of memory at address someVariable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>间接寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, [rbx] ; eax = contents of memory at address stored in rbx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>基址寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, [rbx+4] ; eax = contents of memory at address (rbx + 4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>索引寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, [rbx+rcx*4] ; eax = contents of memory at address (rbx + rcx*4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>基址变址寻址</strong></li></ul><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, [rbx+rcx+4] ; eax = contents of memory at address (rbx + rcx + 4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。</p><p>它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt="img"></p><h3 id="（五）、指令"><a href="#（五）、指令" class="headerlink" title="（五）、指令"></a>（五）、指令</h3><h4 id="lea和mov指令"><a href="#lea和mov指令" class="headerlink" title="lea和mov指令"></a>lea和mov指令</h4><p>LEA指令将其第二个操作对象指定的地址放入其第一个操作对象指定的寄存器中。</p><p>MOV指令将其第二操作对象（即寄存器内容、内存内容或常量值）所引用的数据项复制到其第一操作对象（即寄存器或内存）所引用的位置。</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, [ebx]         ; 将EBX中的地址所指向的内存中的4个字节移动到EAX中mov [var], ebx         ; 将EBX的内容移到内存地址var的4个字节中(注意，不加中括号的var是一个32位地址常量，加中括号才是取地址指向的内容)mov eax, [esi-4]     ; 将内存地址ESI+(-4)上的4个字节移入EAXmov [esi+eax], cl     ; 将CL的内容移到地址为ESI+EAX的单字节中mov edx, [esi+4*ebx] ; 将地址为ESI+4*EBX的4字节数据移动到EDX中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ADD、SUB指令"><a href="#ADD、SUB指令" class="headerlink" title="ADD、SUB指令"></a>ADD、SUB指令</h4><p>用于对字节，字和双字大小的二进制数据进行简单的加/减，即分别用于添加或减去8位，16位或32位操作数。</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">add <reg>,<reg>add <reg>,<mem>add <mem>,<reg>add <reg>,<con>add <mem>,<con>sub al, ah ; AL ← AL - AHsub eax, 216 ; 从存储在EAX中的值中减去216<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="INC和DEC指令"><a href="#INC和DEC指令" class="headerlink" title="INC和DEC指令"></a>INC和DEC指令</h4><p>目标操作数可以是8位，16位或32位操作数。</p><p>INC指令用于将操作数加1。</p><p>DEC指令用于将操作数减1。</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">INC EBX      ;  32-bit 寄存器 自增1INC DL       ;  8-bit 寄存器 自增1INC [count]  ;  变量count  自增1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="imul、idiv"><a href="#imul、idiv" class="headerlink" title="imul、idiv"></a>imul、idiv</h4><p>整数乘除</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">imul <reg32>,<reg32>imul <reg32>,<mem>imul <reg32>,<reg32>,<con>imul <reg32>,<mem>,<con>imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中imul esi, edi, 25 ; ESI → EDI * 25idiv <reg32>idiv <mem>idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="and-or-xor指令"><a href="#and-or-xor指令" class="headerlink" title="and, or, xor指令"></a><strong>and, or, xor</strong>指令</h4><p>按位与、或和异或</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">and <reg>,<reg>and <reg>,<mem>and <mem>,<reg>and <reg>,<con>and <mem>,<con>and eax, 0fH ; 清除EAX的除最后4位以外的所有位xor edx, edx ; 将EDX的内容设置为零<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="not、neg指令"><a href="#not、neg指令" class="headerlink" title="not、neg指令"></a>not、neg指令</h4><p>NOT 指令触发（翻转）操作对象中的所有位。其结果被称为反码。</p><p>NEG是汇编指令中的求补指令，对操作对象执行求补运算：用零减去操作对象，然后结果返回操作对象。</p><p>（将操作对象按位取反后加1）</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">not <reg>not <mem>not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="shl-shr指令"><a href="#shl-shr指令" class="headerlink" title="shl, shr指令"></a><strong>shl, shr</strong>指令</h4><p> 左移，右移</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">shl <reg>,<con8>shl <mem>,<con8>shl <reg>,<cl>shl <mem>,<cl>shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JMP及衍生"><a href="#JMP及衍生" class="headerlink" title="JMP及衍生"></a>JMP及衍生</h4><p>无条件跳转</p><div class="table-container"><table><thead><tr><th>JMP</th><th>无条件跳转指令</th></tr></thead><tbody><tr><td><strong>JC</strong></td><td>进位时跳转</td></tr><tr><td><strong>JO</strong></td><td>溢出时跳转</td></tr><tr><td><strong>JE</strong>/<strong>JZ</strong></td><td>相等/零时跳转</td></tr><tr><td><strong>JS</strong></td><td>负数时跳转</td></tr><tr><td><strong>JP</strong>/<strong>JPE</strong></td><td>奇偶校验时跳转</td></tr><tr><td></td></tr></tbody></table></div><h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><p>比较两个操作数。</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">CMP DX, 00  ; 将DX值与0进行比较JE  L7      ; 如果等于，则跳转到标签L7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h4><p>实现循环（计数型循环）</p><p>CX = CX -1</p><p>判断CX中的值，不为0则继续跳转；为0则向下执行</p><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">LOOP    label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="六-、调用约定"><a href="#六-、调用约定" class="headerlink" title="(六)、调用约定"></a>(六)、调用约定</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h4><p>操作系统为用户态运行的进程与硬件设备之间进行交互提供了一组接口。</p><p>实质上就是<strong><em>\</em>函数调用**</strong>，只不过调用的是<strong><em>\</em>系统函数**</strong>，处于内核态而已</p><p>在Linux中，EAX寄存器是负责传递系统调用号的。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="（一）、内联函数"><a href="#（一）、内联函数" class="headerlink" title="（一）、内联函数"></a>（一）、内联函数</h3><p>内联汇编是指在高级语言中嵌入汇编代码，，减少函数调用。</p><h3 id="（二）、内联汇编语法"><a href="#（二）、内联汇编语法" class="headerlink" title="（二）、内联汇编语法"></a>（二）、内联汇编语法</h3><h4 id="1-在-GCC-中"><a href="#1-在-GCC-中" class="headerlink" title="1. 在 GCC 中"></a>1. 在 GCC 中</h4><p>使用 <code>asm</code> 或 <code>__asm__</code> 关键字：</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">asm("assembly-code" : output : input : clobbered_registers);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-c"><code class="language-lang-c">int a = 10, b = 20, result;asm("addl %%ebx, %%eax"    : "=a"(result)           // 输出约束，`a` 表示使用 EAX 寄存器    : "a"(a), "b"(b)         // 输入约束，`b` 表示使用 EBX 寄存器    : "cc");                 // 通知编译器条件码被修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关键约束："><a href="#关键约束：" class="headerlink" title="关键约束："></a>关键约束：</h4><ul><li><strong>操作数约束</strong>：<ul><li><code>&quot;r&quot;</code>：任意寄存器</li><li><code>&quot;m&quot;</code>：内存操作数</li><li><code>&quot;i&quot;</code>：立即数</li><li><code>&quot;a&quot;</code>：EAX</li><li><code>&quot;b&quot;</code>：EBX 等</li></ul></li><li><strong>修饰符</strong>：<ul><li><code>=：</code>：表示写入输出</li><li><code>+：</code>：表示读写操作</li><li><code>&amp;：</code>：表示早期释放寄存器</li></ul></li></ul><h4 id="2-在-MSVC-中"><a href="#2-在-MSVC-中" class="headerlink" title="2. 在 MSVC 中"></a>2. 在 MSVC 中</h4><p>使用 <code>__asm</code> 关键字：</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">__asm &#123;    mov eax, 1    add eax, 2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <stdio.h>int main() &#123;    int a = 5, b = 3, result;    __asm &#123;        mov eax, a        add eax, b        mov result, eax    &#125;    printf("Result: %d\n", result);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三-常用指令示例"><a href="#三-常用指令示例" class="headerlink" title="(三)常用指令示例"></a>(三)常用指令示例</h3><h4 id="1-数据传送"><a href="#1-数据传送" class="headerlink" title="1. 数据传送"></a>1. 数据传送</h4><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">mov eax, 10       ; 将 10 送入 EAX 寄存器mov ebx, eax      ; 将 EAX 的值传给 EBX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-算术运算"><a href="#2-算术运算" class="headerlink" title="2. 算术运算"></a>2. 算术运算</h4><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">add eax, ebx      ; EAX = EAX + EBXsub eax, 5        ; EAX = EAX - 5mul ebx           ; EAX = EAX * EBXdiv ecx           ; EAX = EAX / ECX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-条件跳转"><a href="#3-条件跳转" class="headerlink" title="3. 条件跳转"></a>3. 条件跳转</h4><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">cmp eax, ebx      ; 比较 EAX 和 EBXje equal_label    ; 如果相等，则跳转到 equal_labeljg greater_label  ; 如果大于，则跳转到 greater_label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-栈操作"><a href="#4-栈操作" class="headerlink" title="4. 栈操作"></a>4. 栈操作</h4><pre class="line-numbers language-lang-asm"><code class="language-lang-asm">push eax          ; 将 EAX 压入栈pop ebx           ; 从栈中弹出值到 EBX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
