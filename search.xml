<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IDA使用技巧</title>
      <link href="/2025/03/26/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2025/03/26/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>这两天做题的时候同届的pwn师傅sakura来问有没有可以修改IDA局部变量的方法。研究了一下感觉很有意思，于是单独开一篇文章记录我经常用到的IDA小技巧。</p><h1 id="修改局部变量"><a href="#修改局部变量" class="headerlink" title="修改局部变量"></a>修改局部变量</h1><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>IDA有两种实现方式，我在网上查到可以force new variable，但是我一直没成功。</p><h3 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h3><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260152493.png" alt=""></p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>因为可以观察到都是分开赋值的</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260206208.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260207597.png" alt=""></p><p>我们在var_5那边按U</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260211783.png" alt=""></p><p>我们的目标是分出一个char+int，因为我得需求是让v2[0]单独分出来变成char，v2[1]-v2[4]变成四字节的int，所以我们选择1+4</p><p>在01的地方按N重命名成i，在05的地方选择建立数组（可以按A）在N成opcode</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260220412.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260222223.png" alt=""></p><p>回到executeBrainfuck按F5</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260223664.png" alt=""></p><p>接着来改汇编</p><p>因为IDA在反编译的时候，会根据变量的访问方式和指令来推断变量类型</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260230570.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     dword ptr [rbp+opcode+1], 0  ; 赋值了 4 个字节</span><br></pre></td></tr></table></figure><p>opcode[1]之后是 4 个连续的字节，IDA会推测opcode[5]这样的存储</p><p>我们把它nop掉</p><p>1、<code>opcode+1</code>字节数显着地<code>4</code>初始化，IDA 无法确认它是内存的一部分，因此可能会被拆除<code>int</code>。</p><p>2.IDA偏向于最简单的数据结构，因此<code>[rbp-5h]</code>直接赋值<code>signed __int8 opcode</code>，而<code>[rbp-4h]</code>作为<code>int opcode_1</code>处理。</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260234728.png" alt=""></p><p>在opcode那里按Y转换函数类型+按N重命名i就好了</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260236267.jpg" alt=""></p><h2 id="Ghidra一把梭"><a href="#Ghidra一把梭" class="headerlink" title="Ghidra一把梭"></a>Ghidra一把梭</h2><p>考虑到是pwn的师傅，所以不推荐（）ghidra挺麻烦的但是足够底层，确实好用</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260158257.jpg" alt=""></p><h1 id="伪代码对应汇编"><a href="#伪代码对应汇编" class="headerlink" title="伪代码对应汇编"></a>伪代码对应汇编</h1><p>可以实现点伪代码哪里汇编会相应跳转，汇编同理，patch的时候好用</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260202020.png" alt=""></p><h1 id="修复枚举值"><a href="#修复枚举值" class="headerlink" title="修复枚举值"></a>修复枚举值</h1><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503261654447.png" alt=""></p><p>以ptrace函数为例，这里的12LL表示一个功能号。在12上面按M，点击yes，ctrl+F搜索ptrace，这里是PTRACE_GETREGS</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503261657409.png" alt=""></p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI_agent_zer0_to_one（二）</title>
      <link href="/2025/03/16/AI-agent-zer0-to-one%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/03/16/AI-agent-zer0-to-one%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="AI-Agent-架构设计"><a href="#AI-Agent-架构设计" class="headerlink" title="AI Agent 架构设计"></a><strong>AI Agent 架构设计</strong></h2><h3 id="Agent-架构的基本组件"><a href="#Agent-架构的基本组件" class="headerlink" title="Agent 架构的基本组件"></a><strong>Agent 架构的基本组件</strong></h3><p>AI Agent的架构通常包含以下基本组件：感知模块、推理引擎和行动执行模块。这些组件共同工作，使Agent能够感知环境、做出决策并采取行动。</p><p><strong>感知模块</strong>：负责从环境中收集信息，并将其转换为Agent可以处理的格式。</p><p>关键特点：</p><ol><li>多模态感知：处理视觉、听觉、触觉等多种输入。</li><li>数据预处理：滤波、归一化、特征提取等。</li><li>传感器融合：整合多个传感器的数据。</li></ol><p><strong>推理引擎：</strong>Agent的”大脑”，负责处理感知到的信息，做出决策，并生成行动计划。</p><p>关键特点：</p><ol><li>知识表示：存储和组织Agent的知识和信念。</li><li>推理机制：基于规则、概率或神经网络的推理。</li><li>学习能力：从经验中更新知识和策略。</li></ol><p><strong>行动执行模块：</strong>将推理引擎的决策转化为具体的行动，并与环境进行交互。</p><p>关键特点：</p><ol><li>动作映射：将高级决策转换为低级控制命令。</li><li>反馈控制：根据执行结果调整行动。</li><li>安全机制：确保行动不会危及Agent或环境。</li></ol><h3 id="常见的-Agent-架构"><a href="#常见的-Agent-架构" class="headerlink" title="常见的 Agent 架构"></a><strong>常见的 Agent 架构</strong></h3><p><strong>反应式架构：</strong>直接将感知映射到行动，不需要内部状态或复杂的推理过程。</p><p>特点：</p><ol><li>快速响应</li><li>低计算复杂度</li><li>适合简单、明确的任务环境</li></ol><p><strong>分层架构：</strong>将Agent的功能划分为多个层次，每个层次负责不同抽象级别的任务。</p><p>特点：</p><ol><li>模块化设计</li><li>支持不同时间尺度的决策</li><li><p>适合复杂任务和长期规划</p><p><strong>BDI 架构：</strong>Belief-Desire-Intention，一种基于人类推理的Agent模型，包含信念（对世界的认知）、欲望（目标）和意图（计划）三个关键组件。</p></li></ol><p>特点：</p><ol><li>模拟人类推理过程</li><li>支持复杂的目标导向行为</li><li>适合动态、不确定的环境</li></ol><h3 id="多-Agent-系统MAS设计"><a href="#多-Agent-系统MAS设计" class="headerlink" title="多 Agent 系统MAS设计"></a><strong>多 Agent 系统MAS设计</strong></h3><p>涉及多个交互的智能Agent，这些Agent可以协作或竞争来解决复杂问题。设计多Agent系统需要考虑Agent间的通信、协作机制以及整体系统的组织结构。</p><p><strong>多Agent系统（MAS）架构设计模式</strong></p><p><strong>概述：</strong>一种用于设计和实现复杂分布式系统的架构方法。</p><ul><li>核心概念：<ul><li><strong>智能代理</strong>：智能代理是MAS的基本构建单元。每个代理具有感知、决策和行动的能力。代理可以是软件实体或物理实体，如机器人。</li><li><strong>环境</strong>：环境是代理感知和行动的场所。环境可以是物理世界、虚拟世界或混合世界。</li><li><strong>通信</strong>：代理之间通过通信进行信息交换和协作。通信可以是直接的（如消息传递）或间接的（如通过环境）。</li><li><strong>协作</strong>：代理通过协作来实现共同的目标。协作可以是显式的（如任务分配）或隐式的（如行为协调）。</li><li><strong>自治</strong>：代理具有自主决策的能力，可以根据环境变化和自身目标进行调整。</li></ul></li><li><p>MAS的系统架构：</p><ul><li><strong>感知层</strong>：负责从环境中获取信息。</li><li><strong>决策层</strong>：负责根据感知信息进行决策。</li><li><strong>行动层</strong>：负责执行决策并影响环境。</li><li><p><strong>通信层</strong>：负责代理之间的信息交换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[感知层] --&gt; B[决策层]</span><br><span class="line">    B --&gt; C[行动层]</span><br><span class="line">    B --&gt; D[通信层]</span><br><span class="line">    D --&gt; B</span><br><span class="line"></span><br><span class="line">%% 自定义样式</span><br><span class="line">classDef default fill:#ffffff,stroke:#000000,color:#000000;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>代理架构模式：</p><ul><li><strong>反应式代理</strong>：基于感知-行动规则，快速响应环境变化。</li><li><strong>认知代理</strong>：具有内部状态和推理能力，能够进行复杂决策。</li><li><strong>混合代理</strong>：结合反应式和认知特性，兼具快速响应和复杂决策能力。</li></ul></li><li>协作模式：决定了代理如何协同工作以实现共同目标。<ul><li><strong>合同网协议</strong>：通过竞标和合同机制进行任务分配。</li><li><strong>黑板系统</strong>：代理通过共享的黑板进行信息交换和协作。</li><li><strong>拍卖机制</strong>：通过拍卖方式进行资源分配和任务分配。</li></ul></li><li>通信模式：决定了代理之间的信息交换方式：<ul><li><strong>点对点通信</strong>：代理之间直接进行信息交换。</li><li><strong>广播通信</strong>：代理向所有其他代理发送信息。</li><li><strong>多播通信</strong>：代理向特定组的代理发送信息。</li></ul></li><li>组织模式：决定了代理的组织结构和角色分配。<ul><li><strong>层次结构</strong>：代理按照层次进行组织，上层代理负责协调和管理下层代理。</li><li><strong>平面结构</strong>：所有代理处于同一层次，具有相同的权利和责任。</li><li><strong>团队结构</strong>：代理被组织成多个团队，每个团队负责特定的任务或功能。</li></ul></li><li>适应性模式：决定了代理如何应对环境变化和任务变化。<ul><li><strong>学习机制</strong>：代理通过学习算法（如强化学习）来提高性能。</li><li><strong>进化机制</strong>：代理通过进化算法（如遗传算法）来优化行为。</li><li><strong>自组织机制</strong>：代理通过自组织机制（如蚁群优化）来实现全局协调。</li></ul></li><li>安全与信任模式：确保代理系统的安全性和可靠性。<ul><li><strong>身份认证</strong>：确保代理的身份真实性。</li><li><strong>访问控制</strong>：限制代理对资源的访问权限。</li><li><strong>信任管理</strong>：通过信任模型评估代理的可信度。</li></ul></li><li><p>反应式代理：通过简单的感知-行动规则进行决策。</p><ul><li>响应速度快，适用于动态变化的环境。</li><li><p>缺乏长期规划能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Algorithm ReactiveAgent</span><br><span class="line">  Input: Perception p</span><br><span class="line">  Output: Action a</span><br><span class="line"></span><br><span class="line">  RuleSet R = &#123;r1, r2, ..., rn&#125; // Set of perception-action rules</span><br><span class="line">  for each rule r in R do</span><br><span class="line">    if r.condition(p) is true then</span><br><span class="line">      return r.action</span><br><span class="line">  end for</span><br><span class="line">  return null // No applicable action</span><br></pre></td></tr></table></figure></li></ul></li><li><p>认知代理：具有内部状态和推理能力，能够进行复杂决策</p><ul><li>具有复杂决策能力，适用于复杂任务。</li><li><p>计算复杂度高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Algorithm CognitiveAgent</span><br><span class="line">  Input: Perception p, InternalState s</span><br><span class="line">  Output: Action a</span><br><span class="line"></span><br><span class="line">  BeliefSet B = UpdateBeliefs(p, s)</span><br><span class="line">  DesireSet D = GenerateDesires(B)</span><br><span class="line">  IntentionSet I = SelectIntentions(D)</span><br><span class="line">  Plan P = GeneratePlan(I)</span><br><span class="line">  ExecutePlan(P)</span><br><span class="line">  UpdateState(s, P)</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p>协作算法：实现代理之间的协作。</p><ul><li>灵活性高，适用于动态任务分配。</li><li><p>通信开销大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithm ContractNet</span><br><span class="line">  Input: Task t</span><br><span class="line">  Output: AssignedAgent a</span><br><span class="line"></span><br><span class="line">  AnnounceTask(t)</span><br><span class="line">  Bids = CollectBids()</span><br><span class="line">  BestBid = SelectBestBid(Bids)</span><br><span class="line">  AssignTask(BestBid.agent, t)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通信协议：定义代理之间的信息交换格式</p><p>  KQML优点：</p><ul><li>标准化程度高，适用于异构系统。</li><li><p>缺点是学习曲线陡峭。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message KQMLMessage</span><br><span class="line">  Performative: String // e.g., &quot;ask&quot;, &quot;tell&quot;, &quot;achieve&quot;</span><br><span class="line">  Sender: AgentID</span><br><span class="line">  Receiver: AgentID</span><br><span class="line">  Content: String</span><br><span class="line">  Language: String // e.g., &quot;Prolog&quot;, &quot;LISP&quot;</span><br><span class="line">  Ontology: String</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>代理决策模型</strong></p><p>通常基于马尔可夫决策过程（MDP）。</p><ul><li>状态空间 $S$：代理可能处于的所有状态的集合。</li><li>动作空间 $A$：代理可能采取的所有动作的集合。</li><li>状态转移函数 $P(s’|s,a)$：在状态 $s$ 执行动作 $a$ 后转移到状态 $s’$ 的概率。</li><li>奖励函数 $R(s,a)$：在状态 $s$ 执行动作 $a$ 所获得的即时奖励。</li></ul><p>常见的博弈模型：</p><ul><li><strong>零和博弈</strong>：一个代理的收益等于另一个代理的损失。</li><li><strong>合作博弈</strong>：代理通过合作实现共同利益。</li><li><strong>非合作博弈</strong>：代理独立决策以最大化自身利益。<ul><li>纳什均衡，表示在给定策略组合下，任何代理都无法通过单方面改变策略而获得更高收益。</li></ul></li></ul><p><strong>Agent间通信协议</strong></p><p>定义了Agent之间交换信息的方式和格式。</p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI安全 </tag>
            
            <tag> AI agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI_agent_zer0_to_one（一）</title>
      <link href="/2025/03/14/AI-agent-zer0-to-one%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/03/14/AI-agent-zer0-to-one%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="AI-Agent-概述与理论基础"><a href="#AI-Agent-概述与理论基础" class="headerlink" title="AI Agent 概述与理论基础"></a><strong>AI Agent 概述与理论基础</strong></h2><h3 id="AI-Agent-的定义-amp-特点"><a href="#AI-Agent-的定义-amp-特点" class="headerlink" title="AI Agent 的定义&amp;特点"></a><strong>AI Agent 的定义&amp;特点</strong></h3><p>AI Agent：智能代理，一种能够感知环境并在其中采取行动以实现特定目标的计算系统</p><ol><li>交互方式：<ul><li>传统AI系统：通常是被动的，只在接收到输入时才进行处理。</li><li>AI Agent：主动与环境交互，持续感知和行动。</li></ul></li><li>决策能力：<ul><li>传统AI系统：往往基于预定义的规则或模型进行决策。</li><li>AI Agent：能够根据环境变化动态调整决策策略。</li></ul></li><li>学习能力：<ul><li>传统AI系统：学习能力有限，通常需要人工调整。</li><li>AI Agent：具有持续学习和自我改进的能力。</li></ul></li><li>目标导向：<ul><li>传统AI系统：通常专注于解决特定问题。</li><li>AI Agent：能够处理多个目标，并在目标之间进行权衡。</li></ul></li><li>适应性：<ul><li>传统AI系统：对环境变化的适应能力较弱。</li><li>AI Agent：能够快速适应新环境和新任务。</li></ul></li></ol><h3 id="AI-Agent-的类型与应用领域"><a href="#AI-Agent-的类型与应用领域" class="headerlink" title="AI Agent 的类型与应用领域"></a><strong>AI Agent 的类型与应用领域</strong></h3><h3 id="基于规则的-Agent"><a href="#基于规则的-Agent" class="headerlink" title="基于规则的 Agent"></a><strong>基于规则的 Agent</strong></h3><p>通过预定义的规则来做出决策和执行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RuleBasedAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.rules = &#123;</span><br><span class="line">            <span class="string">&quot;sunny&quot;</span>: <span class="string">&quot;去公园&quot;</span>,</span><br><span class="line">            <span class="string">&quot;rainy&quot;</span>: <span class="string">&quot;待在家&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cloudy&quot;</span>: <span class="string">&quot;去购物中心&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decide</span>(<span class="params">self, weather</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.rules.get(weather, <span class="string">&quot;无法决定&quot;</span>)</span><br><span class="line"></span><br><span class="line">agent = RuleBasedAgent()</span><br><span class="line"><span class="built_in">print</span>(agent.decide(<span class="string">&quot;sunny&quot;</span>))  <span class="comment"># 输出：去公园</span></span><br></pre></td></tr></table></figure><h3 id="学习型-Agent"><a href="#学习型-Agent" class="headerlink" title="学习型 Agent"></a><strong>学习型 Agent</strong></h3><p>从经验中学习，不断改进其性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QLearningAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, states, actions, learning_rate=<span class="number">0.1</span>, discount_factor=<span class="number">0.9</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.q_table = np.zeros((states, actions))</span><br><span class="line">        <span class="variable language_">self</span>.lr = learning_rate</span><br><span class="line">        <span class="variable language_">self</span>.gamma = discount_factor</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, state, action, reward, next_state</span>):</span><br><span class="line">        current_q = <span class="variable language_">self</span>.q_table[state, action]</span><br><span class="line">        next_max_q = np.<span class="built_in">max</span>(<span class="variable language_">self</span>.q_table[next_state])</span><br><span class="line">        new_q = current_q + <span class="variable language_">self</span>.lr * (reward + <span class="variable language_">self</span>.gamma * next_max_q - current_q)</span><br><span class="line">        <span class="variable language_">self</span>.q_table[state, action] = new_q</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_action</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">return</span> np.argmax(<span class="variable language_">self</span>.q_table[state])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">agent = QLearningAgent(states=<span class="number">10</span>, actions=<span class="number">4</span>)</span><br><span class="line">agent.update(state=<span class="number">0</span>, action=<span class="number">1</span>, reward=<span class="number">5</span>, next_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="自主-Agent"><a href="#自主-Agent" class="headerlink" title="自主 Agent"></a><strong>自主 Agent</strong></h3><p>具有高度的独立性，能够在没有直接人类干预的情况下做出决策和执行任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutonomousAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.position = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.goal = (<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">self</span>.obstacles = <span class="built_in">set</span>([(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sense_environment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 模拟环境感知</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;current_position&quot;</span>: <span class="variable language_">self</span>.position,</span><br><span class="line">            <span class="string">&quot;nearby_obstacles&quot;</span>: [obs <span class="keyword">for</span> obs <span class="keyword">in</span> <span class="variable language_">self</span>.obstacles <span class="keyword">if</span> <span class="variable language_">self</span>.distance(obs, <span class="variable language_">self</span>.position) &lt; <span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plan_path</span>(<span class="params">self, env_data</span>):</span><br><span class="line">        <span class="comment"># 简化的路径规划</span></span><br><span class="line">        current_pos = env_data[<span class="string">&quot;current_position&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> current_pos == <span class="variable language_">self</span>.goal:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Goal reached&quot;</span></span><br><span class="line">        </span><br><span class="line">        possible_moves = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">        best_move = <span class="built_in">min</span>(possible_moves, key=<span class="keyword">lambda</span> move: <span class="variable language_">self</span>.distance(</span><br><span class="line">            (current_pos[<span class="number">0</span>] + move[<span class="number">0</span>], current_pos[<span class="number">1</span>] + move[<span class="number">1</span>]),</span><br><span class="line">            <span class="variable language_">self</span>.goal</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> best_move</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_action</span>(<span class="params">self, action</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(action, <span class="built_in">tuple</span>):</span><br><span class="line">            <span class="variable language_">self</span>.position = (<span class="variable language_">self</span>.position[<span class="number">0</span>] + action[<span class="number">0</span>], <span class="variable language_">self</span>.position[<span class="number">1</span>] + action[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.position</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">self, pos1, pos2</span>):</span><br><span class="line">        <span class="keyword">return</span> ((pos1[<span class="number">0</span>] - pos2[<span class="number">0</span>])**<span class="number">2</span> + (pos1[<span class="number">1</span>] - pos2[<span class="number">1</span>])**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            env_data = <span class="variable language_">self</span>.sense_environment()</span><br><span class="line">            action = <span class="variable language_">self</span>.plan_path(env_data)</span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">&quot;Goal reached&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            new_position = <span class="variable language_">self</span>.execute_action(action)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Moved to <span class="subst">&#123;new_position&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">agent = AutonomousAgent()</span><br><span class="line">agent.run()</span><br></pre></td></tr></table></figure><h2 id="AI-Agent-的核心技术"><a href="#AI-Agent-的核心技术" class="headerlink" title=" AI Agent 的核心技术"></a><strong> AI Agent 的核心技术</strong></h2><h3 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a><strong>机器学习基础</strong></h3><p><strong>监督学习：</strong>通过标记数据来训练模型，目标是学习输入到输出的映射，常用于分类和回归问题。</p><p><strong>无监督学习 ：</strong>处理未标记的数据，目标是发现数据中的隐藏结构。目标是发现数据的内在结构，常用于聚类、降维和异常检测。</p><p><strong>强化学习：</strong>通过与环境交互来学习最优策略的方法。目标是最大化累积奖励，适用于序列决策问题。</p><ul><li>关键概念：<ul><li>状态（State）</li><li>动作（Action）</li><li>奖励（Reward）</li><li>策略（Policy）</li><li>价值函数（Value Function）</li></ul></li></ul><h3 id="深度学习技术"><a href="#深度学习技术" class="headerlink" title="深度学习技术"></a><strong>深度学习技术</strong></h3><p>深度学习是机器学习的一个子领域，它使用多层神经网络来学习数据的层次表示。在AI Agent开发中，深度学习技术能够处理高维度、非结构化的数据，如图像、音频和文本。</p><p><strong>神经网络基础：</strong>深度学习的基础，它模仿了人脑的结构和功能。</p><ul><li>关键概念：<ul><li>神经元（Neuron）</li><li>激活函数（Activation Function）</li><li>权重和偏置（Weights and Biases）</li><li>前向传播（Forward Propagation）</li><li>反向传播（Backpropagation）</li></ul></li></ul><p><strong>卷积神经网络 (CNN)</strong>：处理网格结构数据（如图像）时表现出色<strong>，</strong>局部连接、权重共享、空间或时间下采样</p><ul><li>关键组件：<ul><li>卷积层</li><li>池化层</li><li>全连接层</li></ul></li></ul><p><strong>循环神经网络 (RNN)：</strong>适用于处理序列数据，如时间序列或自然语言。能处理变长序列、具有内部状态（记忆）、可以捕捉长期依赖关系。</p><ul><li>变体：<ul><li>长短期记忆网络（LSTM）</li><li>门控循环单元（GRU）</li></ul></li></ul><p><strong>注意力机制与 Transformer：</strong>能偶并行处理序列、捕捉长距离依赖、计算效率高。</p><p>注意力机制允许模型在处理输入时关注最相关的部分。</p><p>Transformer架构基于自注意力机制，在各种NLP任务中取得了突破性进展。</p><h3 id="自然语言处理-NLP"><a href="#自然语言处理-NLP" class="headerlink" title="自然语言处理 (NLP)"></a><strong>自然语言处理 (NLP)</strong></h3><p>自然语言处理是AI Agent与人类进行语言交互的关键技术。它使Agent能够理解、生成和处理人类语言。</p><p><strong>文本分类：</strong>文本分类是NLP的基础任务之一，它将文本分配到预定义的类别中。</p><ul><li>情感分析</li><li>垃圾邮件检测</li><li>新闻分类</li></ul><p><strong>命名实体识别NER：</strong>识别文本中的命名实体（如人名、地名、组织名等）并将其分类的任务。</p><ul><li>情感分析</li><li>垃圾邮件检测</li><li>新闻分类</li></ul><p><strong>情感分析：</strong>旨在确定文本中表达的情感态度（如积极、消极或中性）。</p><ul><li>社交媒体监控</li><li>客户反馈分析</li><li><p>市场研究</p><p><strong>机器翻译：</strong>将文本从一种语言自动翻译成另一种语言的任务。</p></li><li><p>跨语言通信</p></li><li>多语言内容创建</li><li>国际商务</li></ul><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a><strong>计算机视觉</strong></h3><p>计算机视觉使AI Agent能够理解和处理视觉信息。</p><p><strong>图像分类：</strong>识别图像中主要对象或场景的任务。</p><ul><li>医学诊断</li><li>自动标记</li><li>内容过滤</li></ul><p><strong>目标检测：</strong>识别图像中的对象&amp;定位它们的位置。</p><ul><li>自动驾驶</li><li>安全监控</li><li>零售分析</li></ul><p><strong>图像分割：</strong>将图像划分为多个语义区域，为每个像素分配一个类别标签。</p><ul><li>医学图像分析</li><li>自动驾驶场景理解</li><li>增强现实</li></ul><p><strong>人脸识别：</strong>涉及检测、对齐和识别人脸。</p><ul><li>安全系统</li><li>用户认证</li><li>社交媒体标记</li></ul><h3 id="决策与规划"><a href="#决策与规划" class="headerlink" title="决策与规划"></a><strong>决策与规划</strong></h3><p>AI Agent自主行动的核心能力，使其能够在复杂环境中做出明智的选择并制定长期策略。</p><p><strong>决策树：</strong>一种直观的决策模型，适用于分类和回归任务。</p><ul><li>风险评估</li><li>客户分类</li><li>医疗诊断</li></ul><p><strong>蒙特卡洛树搜索（MCTS）</strong>：一种用于决策过程的启发式搜索算法，特别适用于具有大状态空间的问题。</p><ul><li>游戏AI（如围棋）</li><li>路径规划</li><li>资源分配</li></ul><p><strong>A*算法</strong>：一种用于图形搜索和路径规划的启发式算法。</p><ul><li>导航系统</li><li>机器人路径规划</li><li>游戏AI寻路</li></ul><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI安全 </tag>
            
            <tag> AI agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的大模型搭建之旅</title>
      <link href="/2025/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/"/>
      <url>/2025/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h1 id="一、搭建开发环境"><a href="#一、搭建开发环境" class="headerlink" title="一、搭建开发环境"></a>一、搭建开发环境</h1><ul><li><h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a><strong>python3</strong></h2></li><li><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a><strong>pytorch</strong></h2></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy tqdm matplotlib</span><br></pre></td></tr></table></figure><ul><li><h2 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a><strong>依赖库</strong></h2></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy tqdm matplotlib</span><br></pre></td></tr></table></figure><ul><li><h2 id="vscode-Jupyter"><a href="#vscode-Jupyter" class="headerlink" title="vscode / Jupyter"></a><strong>vscode / Jupyter</strong></h2></li></ul><h1 id="二、准备一个数据集"><a href="#二、准备一个数据集" class="headerlink" title="二、准备一个数据集"></a>二、准备一个数据集</h1><ul><li><a href="https://blog.salesforceairesearch.com/the-wikitext-long-term-dependency-language-modeling-dataset/">WikiText</a></li><li><a href="https://github.com/jcpeterson/openwebtext">OpenWebText</a></li><li>anythingelse</li></ul><h2 id="1-准备环境（以openwebtext为例）"><a href="#1-准备环境（以openwebtext为例）" class="headerlink" title="1.准备环境（以openwebtext为例）"></a>1.准备环境（以openwebtext为例）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JCPETERSON/OpenwebText.git</span><br><span class="line"><span class="built_in">cd</span> OpenwebText</span><br></pre></td></tr></table></figure><p>python版本得高一点，我用的3.12，3.8不行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>如果老报错版本问题就直接下（没报错就不改）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4 certifi chardet cssselect feedfinder2 feedparser htmlmin idna jieba3k lxml newspaper3k nltk numpy pandas pillow python-dateutil pytorch-pretrained-bert pytz pyyaml recordtype requests-file requests singledispatch six soupsieve spacy tinysegmenter tldextract tqdm urllib3 urlparse2 pycurl pebble chardet transformers</span><br></pre></td></tr></table></figure><h2 id="2-加载-amp-预处理数据"><a href="#2-加载-amp-预处理数据" class="headerlink" title="2.加载&amp;预处理数据"></a>2.加载&amp;预处理数据</h2><h3 id="1-、直接下载Pushshift-数据"><a href="#1-、直接下载Pushshift-数据" class="headerlink" title="(1)、直接下载Pushshift 数据"></a>(1)、直接下载<a href="https://mega.nz/folder/EZZD0YwJ#9_PlEQzdMVLaNdKv_ICNVQ">Pushshift 数据</a></h3><p>这里面的url是已经去重了的，正常流程如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提取 URL</span><br><span class="line">python extract_urls.py --single_file pushshift_dumps/RS_v2_2005-06.xz</span><br><span class="line"></span><br><span class="line">想提取一个时间范围内的 URL</span><br><span class="line">python extract_urls.py --year_start 2016 --year_end 2018</span><br><span class="line"></span><br><span class="line">去重 URL</span><br><span class="line">python deduplicate_urls.py --input_dir url_dumps</span><br></pre></td></tr></table></figure><h3 id="2-、下载HTML数据"><a href="#2-、下载HTML数据" class="headerlink" title="(2)、下载HTML数据"></a>(2)、下载HTML数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 download.py D:\Tools\openwebtext\URLs\RS_2011-01.bz2.deduped.txt --n_procs 100 --scraper raw --chunk_size 100000 --compress --<span class="built_in">timeout</span> 30</span><br></pre></td></tr></table></figure><p>将抓取的 HTML 页面存储在 <code>scraped</code> 文件夹中，并压缩存档。</p><p>等挺久的，挂着睡觉了。默认它done了就是好了（）</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501281514200.png" alt="1738029502506.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501281515362.png" alt="1738029524605.png"></p><h3 id="3-、从HTML中提取文本"><a href="#3-、从HTML中提取文本" class="headerlink" title="(3)、从HTML中提取文本"></a>(3)、从HTML中提取文本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade newspaper3k</span><br></pre></td></tr></table></figure><p>把extract_text.py里的save_parsed_file改成如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_parsed_file</span>(<span class="params">filename, text, out_dir</span>):</span><br><span class="line">    <span class="comment"># 获取文件的完整路径</span></span><br><span class="line">    file_path = os.path.join(out_dir, filename)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保目录存在，如果不存在则创建</span></span><br><span class="line">    os.makedirs(os.path.dirname(file_path), exist_ok=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">        handle.write(text)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501281514962.png" alt="1738048415160.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 extract_text.py --html_archive scraped/RS_2011-01-1_data.xz --n_procs 100</span><br></pre></td></tr></table></figure><p>从 HTML 中提取出文本内容并保存为 <code>.txt</code> 文件.</p><p>—如果中间有报错重新来的话，记得把原来提取的文件删掉，文件夹在scraped里</p><h3 id="4-、分词处理"><a href="#4-、分词处理" class="headerlink" title="(4)、分词处理"></a>(4)、分词处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download en_core_web_sm</span><br></pre></td></tr></table></figure><p>更改tokenize_text.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_encoding</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检测文件的实际编码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw_data = f.read(<span class="number">1024</span>)  <span class="comment"># 读取文件的前 1KB 数据</span></span><br><span class="line">    result = chardet.detect(raw_data)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&#x27;encoding&#x27;</span>] <span class="keyword">or</span> <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 如果检测失败，默认返回 &#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_tokenized_text</span>(<span class="params">output_dir, filename, text</span>):</span><br><span class="line">    <span class="comment"># 构建完整输出路径</span></span><br><span class="line">    text_file = os.path.join(output_dir, filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保目标目录存在</span></span><br><span class="line">    os.makedirs(os.path.dirname(text_file), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(text_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fo:</span><br><span class="line">        fo.write(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokenizeSpacy</span>(<span class="params">args</span>):</span><br><span class="line">    nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>)  <span class="comment"># 加载 spaCy 模型</span></span><br><span class="line">    extraction_file_paths = glob.glob(args.input_glob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> extraction_file_path <span class="keyword">in</span> extraction_file_paths:</span><br><span class="line">        path, filename = os.path.split(extraction_file_path)</span><br><span class="line">        text_file = os.path.join(</span><br><span class="line">            args.output_dir, filename.replace(<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.tokenized.txt&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保输出目录存在</span></span><br><span class="line">        os.makedirs(os.path.dirname(text_file), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测文件编码</span></span><br><span class="line">        file_encoding = detect_encoding(extraction_file_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 打开输入文件和输出文件</span></span><br><span class="line">            <span class="keyword">with</span> io.<span class="built_in">open</span>(extraction_file_path, <span class="string">&#x27;r&#x27;</span>, encoding=file_encoding) <span class="keyword">as</span> fi, \</span><br><span class="line">                    io.<span class="built_in">open</span>(text_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fo:</span><br><span class="line"></span><br><span class="line">                omitted_line_count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(line.strip()) &gt; <span class="number">0</span>:  <span class="comment"># 忽略空行</span></span><br><span class="line">                        doc = nlp(line)</span><br><span class="line">                        fo.write(<span class="string">&#x27; &#x27;</span>.join([x.text <span class="keyword">for</span> x <span class="keyword">in</span> doc]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        omitted_line_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Omitted <span class="subst">&#123;omitted_line_count&#125;</span> empty lines from <span class="subst">&#123;filename&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Failed to decode <span class="subst">&#123;extraction_file_path&#125;</span> with encoding <span class="subst">&#123;file_encoding&#125;</span>. Skipping this file.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--input_glob&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;*.txt&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--output_dir&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;tokenized&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--tokenizer&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;spacy&#x27;</span>, choices=[<span class="string">&#x27;spacy&#x27;</span>, <span class="string">&#x27;gpt2&#x27;</span>])</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--combine&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1e8</span>, <span class="built_in">help</span>=<span class="string">&quot;min tokens per file in gpt2 mode&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--file_bs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&quot;files per batch in gpt2 mode&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析命令行参数</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    os.makedirs(args.output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据 tokenizer 选择执行的函数</span></span><br><span class="line">    <span class="keyword">if</span> args.tokenizer == <span class="string">&#x27;spacy&#x27;</span>:</span><br><span class="line">        tokenizeSpacy(args)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;GPT-2 tokenizer is not implemented in this version.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 tokenize_text.py --input_glob <span class="string">&quot;parsed/RS_2011-01/*.txt&quot;</span> --output_dir tokenized</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501282028656.png" alt="1738067274379.png"></p><h1 id="三、构建和训练-GPT-类似模型"><a href="#三、构建和训练-GPT-类似模型" class="headerlink" title="三、构建和训练 GPT 类似模型"></a>三、构建和训练 GPT 类似模型</h1><p>下面的文件层级关系如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gpt_project/</span><br><span class="line">├── model/</span><br><span class="line">│   ├── gpt.py</span><br><span class="line">│   ├── transformer_block.py</span><br><span class="line">├── data/</span><br><span class="line">│   ├── dataset.py</span><br><span class="line">│   ├── tokenizer.py  # 可选</span><br><span class="line">│   ├── tokenized/  # 存放所有分词好的 .txt 文件</span><br><span class="line">├── train/</span><br><span class="line">│   ├── train.py  # 训练代码</span><br><span class="line">|——train_model/</span><br><span class="line">|</span><br><span class="line">├── inference.py  # 生成文本</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501292326878.png" alt="1738164364319.png"></p><h2 id="1-dataset-py"><a href="#1-dataset-py" class="headerlink" title="1. dataset.py"></a>1. <strong>dataset.py</strong></h2><p>用于处理数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dataset.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDataset</span>(torch.utils.data.Dataset):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, directory_path, seq_length, tokenizer</span>):</span><br><span class="line">        <span class="variable language_">self</span>.seq_length = seq_length</span><br><span class="line">        <span class="variable language_">self</span>.tokenizer = tokenizer</span><br><span class="line">        <span class="variable language_">self</span>.data = []</span><br><span class="line">        <span class="variable language_">self</span>.vocab = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.inverse_vocab = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步：统计所有单词的频率</span></span><br><span class="line">        word_counter = Counter()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历 directory_path 目录中的所有 .tokenized.txt 文件</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory_path):</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&quot;.tokenized.txt&quot;</span>):</span><br><span class="line">                file_path = os.path.join(directory_path, filename)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    words = f.read().split()</span><br><span class="line">                    word_counter.update(words)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二步：创建词汇表，给每个单词分配一个 ID</span></span><br><span class="line">        <span class="variable language_">self</span>.vocab = &#123;word: idx + <span class="number">1</span> <span class="keyword">for</span> idx, (word, _) <span class="keyword">in</span> <span class="built_in">enumerate</span>(word_counter.items())&#125;</span><br><span class="line">        <span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>] = <span class="number">0</span>  <span class="comment"># 为 padding 添加一个 ID</span></span><br><span class="line">        <span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;unk&gt;&#x27;</span>] = <span class="built_in">len</span>(<span class="variable language_">self</span>.vocab)  <span class="comment"># 为未知单词添加一个 ID</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建逆词汇表</span></span><br><span class="line">        <span class="variable language_">self</span>.inverse_vocab = &#123;idx: word <span class="keyword">for</span> word, idx <span class="keyword">in</span> <span class="variable language_">self</span>.vocab.items()&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第三步：将文本转换为 token ID</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory_path):</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&quot;.tokenized.txt&quot;</span>):</span><br><span class="line">                file_path = os.path.join(directory_path, filename)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    words = f.read().split()</span><br><span class="line">                    <span class="comment"># 将每个单词转换为 token ID，如果不在词汇表中则使用 &lt;unk&gt;</span></span><br><span class="line">                    token_ids = [<span class="variable language_">self</span>.vocab.get(word, <span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;unk&gt;&#x27;</span>]) <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line">                    <span class="variable language_">self</span>.data.append(token_ids)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将数据转化为训练所需的序列形式</span></span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="variable language_">self</span>.pad_sequence(seq) <span class="keyword">for</span> seq <span class="keyword">in</span> <span class="variable language_">self</span>.data]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        input_text = <span class="variable language_">self</span>.data[idx]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 编码输入文本</span></span><br><span class="line">        input_ids = torch.tensor(input_text)  <span class="comment"># 转换为 tensor</span></span><br><span class="line">        target_ids = input_ids.clone()  <span class="comment"># 使用输入作为目标</span></span><br><span class="line">        <span class="keyword">return</span> input_ids, target_ids</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pad_sequence</span>(<span class="params">self, seq</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;填充序列到 seq_length&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(seq) &lt; <span class="variable language_">self</span>.seq_length:</span><br><span class="line">            <span class="comment"># 使用 pad token 填充</span></span><br><span class="line">            seq += [<span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]] * (<span class="variable language_">self</span>.seq_length - <span class="built_in">len</span>(seq))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果超出 seq_length，则截断</span></span><br><span class="line">            seq = seq[:<span class="variable language_">self</span>.seq_length]</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    def __getitem__(self, idx):</span></span><br><span class="line"><span class="string">        input_ids = torch.tensor(self.data[idx], dtype=torch.long)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 如果输入序列长度小于 seq_length，进行填充</span></span><br><span class="line"><span class="string">        padding_length = self.seq_length - input_ids.size(0)</span></span><br><span class="line"><span class="string">        if padding_length &gt; 0:</span></span><br><span class="line"><span class="string">            padding = torch.tensor([self.vocab[&#x27;&lt;pad&gt;&#x27;]] * padding_length, dtype=torch.long)</span></span><br><span class="line"><span class="string">            input_ids = torch.cat([input_ids, padding], dim=0)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 设置 target_ids 为 input_ids 的下一个 token（即语言模型的训练目标）</span></span><br><span class="line"><span class="string">        target_ids = input_ids[1:].clone()</span></span><br><span class="line"><span class="string">        target_ids = torch.cat([target_ids, torch.tensor([self.vocab[&#x27;&lt;pad&gt;&#x27;]], dtype=torch.long)])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return input_ids, target_ids</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-gpt-py"><a href="#2-gpt-py" class="headerlink" title="2.gpt.py"></a>2.gpt.py</h2><p>实现 GPT 模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gpt.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Adding to sys.path:&quot;</span>, project_root)</span><br><span class="line">sys.path.append(project_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.transformer_block <span class="keyword">import</span> TransformerBlock</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, num_layers, num_heads, hidden_dim, max_length</span>):</span><br><span class="line">        <span class="built_in">super</span>(GPT, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.hidden_dim = hidden_dim  <span class="comment"># 添加 hidden_dim 变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, num_heads, num_layers, max_length</span>):</span><br><span class="line">        <span class="built_in">super</span>(GPT, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        <span class="variable language_">self</span>.position_embedding = nn.Embedding(max_length, embed_size)</span><br><span class="line">        <span class="variable language_">self</span>.blocks = nn.ModuleList([</span><br><span class="line">            TransformerBlock(embed_size, num_heads, embed_size * <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_layers)</span><br><span class="line">        ])</span><br><span class="line">        <span class="variable language_">self</span>.fc_out = nn.Linear(embed_size, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        batch_size, seq_length = x.shape</span><br><span class="line">        positions = torch.arange(<span class="number">0</span>, seq_length).expand(batch_size, seq_length)</span><br><span class="line">        x = <span class="variable language_">self</span>.embedding(x) + <span class="variable language_">self</span>.position_embedding(positions)</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">            x = block(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fc_out(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, input_ids, max_length=<span class="number">100</span>, temperature=<span class="number">1.0</span>, top_k=<span class="number">50</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取初始输出</span></span><br><span class="line">        generated_ids = input_ids</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_length):</span><br><span class="line">            outputs = <span class="variable language_">self</span>(generated_ids)</span><br><span class="line">            logits = outputs  <span class="comment"># 假设模型的输出是 logits</span></span><br><span class="line">            logits = logits[:, -<span class="number">1</span>, :]  <span class="comment"># 只关注最新生成的 token</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 应用温度采样</span></span><br><span class="line">            logits = logits / temperature</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Top-K 采样</span></span><br><span class="line">            <span class="keyword">if</span> top_k &gt; <span class="number">0</span>:</span><br><span class="line">                top_k_values, top_k_indices = torch.topk(logits, top_k)</span><br><span class="line">                top_k_probs = F.softmax(top_k_values, dim=-<span class="number">1</span>)</span><br><span class="line">                next_token = torch.multinomial(top_k_probs, <span class="number">1</span>)</span><br><span class="line">                next_token = top_k_indices.gather(-<span class="number">1</span>, next_token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 默认采样</span></span><br><span class="line">                probs = F.softmax(logits, dim=-<span class="number">1</span>)</span><br><span class="line">                next_token = torch.multinomial(probs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加生成的 token 到输入序列</span></span><br><span class="line">            generated_ids = torch.cat([generated_ids, next_token], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generated_ids</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="3-transformer-block-py"><a href="#3-transformer-block-py" class="headerlink" title="3.transformer_block.py"></a>3.transformer_block.py</h2><p>用于实现 GPT 模型的一个基本组件——Transformer 块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># transformer_block.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AttentionHead</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_size, head_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.q = nn.Linear(embed_size, head_size, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.k = nn.Linear(embed_size, head_size, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.v = nn.Linear(embed_size, head_size, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.scale = head_size ** -<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        q = <span class="variable language_">self</span>.q(x)</span><br><span class="line">        k = <span class="variable language_">self</span>.k(x)</span><br><span class="line">        v = <span class="variable language_">self</span>.v(x)</span><br><span class="line">        scores = torch.matmul(q, k.transpose(-<span class="number">2</span>, -<span class="number">1</span>)) * <span class="variable language_">self</span>.scale</span><br><span class="line">        attention = torch.softmax(scores, dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.matmul(attention, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_size, num_heads, feed_forward_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.attention = nn.MultiheadAttention(embed_dim=embed_size, num_heads=num_heads)</span><br><span class="line">        <span class="variable language_">self</span>.ff = nn.Sequential(</span><br><span class="line">            nn.Linear(embed_size, feed_forward_size),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(feed_forward_size, embed_size),</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.norm1 = nn.LayerNorm(embed_size)</span><br><span class="line">        <span class="variable language_">self</span>.norm2 = nn.LayerNorm(embed_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        attention_out, _ = <span class="variable language_">self</span>.attention(x, x, x)</span><br><span class="line">        x = <span class="variable language_">self</span>.norm1(x + attention_out)</span><br><span class="line">        ff_out = <span class="variable language_">self</span>.ff(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.norm2(x + ff_out)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-generate-py"><a href="#4-generate-py" class="headerlink" title="4. generate.py"></a>4. <strong>generate.py</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> model.gpt <span class="keyword">import</span> GPT</span><br><span class="line"><span class="keyword">from</span> data.tokenizer <span class="keyword">import</span> SimpleTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_text</span>(<span class="params">prompt, model, tokenizer, max_length=<span class="number">50</span></span>):</span><br><span class="line">    tokens = tokenizer.encode(prompt)</span><br><span class="line">    input_data = torch.tensor([tokens])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_length):</span><br><span class="line">            output = model(input_data)</span><br><span class="line">            next_token = torch.argmax(output[:, -<span class="number">1</span>, :], dim=-<span class="number">1</span>)</span><br><span class="line">            input_data = torch.cat([input_data, next_token.unsqueeze(<span class="number">0</span>)], dim=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> next_token.item() == tokenizer.word_to_idx[<span class="string">&quot;&lt;END&gt;&quot;</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokenizer.decode(input_data[<span class="number">0</span>].tolist())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    vocab_size = <span class="number">10000</span></span><br><span class="line">    embed_size = <span class="number">128</span></span><br><span class="line">    num_heads = <span class="number">8</span></span><br><span class="line">    num_layers = <span class="number">4</span></span><br><span class="line">    max_length = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load pretrained model</span></span><br><span class="line">    model = GPT(vocab_size, embed_size, num_heads, num_layers, max_length)</span><br><span class="line">    tokenizer = SimpleTokenizer(vocab_size)</span><br><span class="line">    tokenizer.build_vocab(<span class="string">&quot;This is a small test corpus &lt;END&gt;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    prompt = <span class="string">&quot;This is a&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(generate_text(prompt, model, tokenizer))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-train-py"><a href="#5-train-py" class="headerlink" title="5.train.py"></a>5.<strong>train.py</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train/train.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Adding to sys.path:&quot;</span>, project_root)</span><br><span class="line">sys.path.append(project_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> data.dataset <span class="keyword">import</span> TextDataset</span><br><span class="line"><span class="keyword">from</span> model.gpt <span class="keyword">import</span> GPT</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> AdamW</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> StepLR</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> GPT2LMHeadModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在外部加载模型和分词器</span></span><br><span class="line">model = GPT2LMHeadModel.from_pretrained(<span class="string">&#x27;gpt2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="comment"># 加载分词器</span></span><br><span class="line">    tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;gpt2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置设备</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    model.to(device)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 配置数据集</span></span><br><span class="line">    dataset = TextDataset(directory_path=<span class="string">&quot;data/tokenized&quot;</span>, seq_length=<span class="number">128</span>, tokenizer=tokenizer)</span><br><span class="line">    data_loader = DataLoader(dataset, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置优化器</span></span><br><span class="line">    optimizer = AdamW(model.parameters(), lr=<span class="number">1e-5</span>)</span><br><span class="line">    scheduler = StepLR(optimizer, step_size=<span class="number">5</span>, gamma=<span class="number">0.5</span>)  <span class="comment"># 每5个epoch减少学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 假设训练3个epoch</span></span><br><span class="line">        total_loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> batch_idx, (input_ids, target_ids) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            input_ids = input_ids.to(device)</span><br><span class="line">            target_ids = target_ids.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            outputs = model(input_ids, labels=target_ids)</span><br><span class="line">            loss = outputs.loss</span><br><span class="line">            total_loss += loss.item()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反向传播</span></span><br><span class="line">            loss.backward()</span><br><span class="line">            <span class="comment"># 训练过程中添加梯度裁剪</span></span><br><span class="line">            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=<span class="number">1.0</span>)</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出每个 epoch 的损失</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>, Loss: <span class="subst">&#123;total_loss / <span class="built_in">len</span>(data_loader)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 学习率调度</span></span><br><span class="line">        scheduler.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存训练好的模型</span></span><br><span class="line">    torch.save(model.state_dict(), <span class="string">&quot;trained_model/model.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tokenizer.save_pretrained(<span class="string">&quot;trained_model&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-inference-py"><a href="#6-inference-py" class="headerlink" title="6. inference.py"></a>6. <strong>inference.py</strong></h2><p>这是推理脚本，用于加载训练好的模型并进行推理（生成预测）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inference.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Adding to sys.path:&quot;</span>, project_root)</span><br><span class="line">sys.path.append(project_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.gpt <span class="keyword">import</span> GPT</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_model</span>():</span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model = GPT(vocab_size=<span class="number">50000</span>, embed_size=<span class="number">256</span>, num_layers=<span class="number">6</span>, num_heads=<span class="number">8</span>, max_length=<span class="number">512</span>)</span><br><span class="line">    model.load_state_dict(torch.load(<span class="string">&quot;trained_model/model.pth&quot;</span>), strict=<span class="literal">False</span>)</span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载分词器</span></span><br><span class="line">    tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;gpt2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model, tokenizer  <span class="comment"># 返回模型和分词器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat</span>():</span><br><span class="line">    model, tokenizer = load_model()  <span class="comment"># 加载模型和分词器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        text = <span class="built_in">input</span>(<span class="string">&quot;Input: &quot;</span>)  <span class="comment"># 获取用户输入</span></span><br><span class="line">        <span class="keyword">if</span> text.lower() == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对输入文本进行编码</span></span><br><span class="line">        input_ids = tokenizer.encode(text, return_tensors=<span class="string">&#x27;pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成文本</span></span><br><span class="line">        generated_ids = model.generate(input_ids, max_length=<span class="number">100</span>, temperature=<span class="number">1.0</span>, top_k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解码并打印生成的文本</span></span><br><span class="line">        output_text = tokenizer.decode(generated_ids[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;GPT: <span class="subst">&#123;output_text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    chat()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 train/train.py</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501292344755.png" alt="1738165457988.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 inference.py</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501292343248.png" alt="1738165422521.png"></p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-课程总结</title>
      <link href="/2025/01/19/Android-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/19/Android-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>参考</p><p>正己老师的《安卓逆向这档事》</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="与手机建立连接"><a href="#与手机建立连接" class="headerlink" title="与手机建立连接"></a>与手机建立连接</h3><h4 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:端口号</span><br><span class="line">adb devices</span><br><span class="line">adb -s 127.0.0.1:端口号 shell</span><br></pre></td></tr></table></figure><p>注意：我的是mumu模拟器，每次都要到多开器里面查看adb端口建立连接，但是正常应该可以直接adb devices&amp;adb shell。模拟器是这样的TT</p><h4 id="真机"><a href="#真机" class="headerlink" title="真机"></a>真机</h4><p>手机开开发者版本和USB调试，然后通过数据线连接</p><ul><li>有一些数据线只能充电，第一次连接电脑的时候手机上会弹出要求允许 USB 调试访问。确保你点击了“允许”按钮。</li><li>如果没弹出就换一根数据线/重启。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb shell</span><br></pre></td></tr></table></figure><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><h4 id="传文件进windows"><a href="#传文件进windows" class="headerlink" title="传文件进windows"></a>传文件进windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb -s 127.0.0.1:16384 shell pm list packages</span><br><span class="line">adb -s 127.0.0.1:16384 shell pm path com.chaoxing.mobile</span><br><span class="line">adb -s 127.0.0.1:16384 pull /data/app/~~EerlSikM2HRGxvcqMsmfIg==/com.chaoxing.mobile-_E7VgeY662xxYG0tGxtKrQ==/base.apk D:\桌面\xuexitong</span><br></pre></td></tr></table></figure><h4 id="推送文件至模拟器"><a href="#推送文件至模拟器" class="headerlink" title="推送文件至模拟器"></a>推送文件至模拟器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push &quot;D:\LeStoreDownload\网页\frida-clr-16.5.7-windows-x86_64.dll\frida-clr-16.5.7-windows-x86_64.dll&quot; /data/local/tmp/</span><br><span class="line">adb shell ls /data/local/tmp/</span><br></pre></td></tr></table></figure><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install  a.apk</span><br></pre></td></tr></table></figure><h3 id="初识APK"><a href="#初识APK" class="headerlink" title="初识APK"></a>初识APK</h3><p><strong>APK</strong>：全称Android Package，相当于压缩文件，把.apk后缀改为.zip就可以解压</p><ul><li><strong>assets目录 </strong>：存放apk静态资源，视频图片等。</li><li><strong>lib目录</strong>：armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件。</li><li><strong>META-INF目录</strong>：存放签名信息，用来验证APK的完整性。</li><li><strong>res文件</strong>：资源文件，图片字符串等（会转为二进制格式）</li><li><strong>AndroidMainfest.xml文件</strong>：APK的应用清单，描述应用名字版本等</li><li><strong>classes.dex文件</strong>：classes.dex是Java源码编码后的java字节码，<strong>APK运行的主要逻辑</strong></li><li><strong>resources.arsc</strong>：resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</li></ul><p><strong>assets和res有什么不同？</strong></p><p>assets主要存放的是应用内显示出来的图片，不会转为二进制格式</p><p>res是ui设计相关的文件，会转为二进制格式，经过压缩优化</p><h3 id="JVM、Dalvik、ART"><a href="#JVM、Dalvik、ART" class="headerlink" title="JVM、Dalvik、ART"></a>JVM、Dalvik、ART</h3><p>JVM是JAVA虚拟机，运行JAVA字节码程序<br>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)<br>Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异</p><h3 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h3><div class="table-container"><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Activity(活动)</td><td style="text-align:left">在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。</td></tr><tr><td style="text-align:left">Service(服务)</td><td style="text-align:left">Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。</td></tr><tr><td style="text-align:left">Broadcast Receiver(广播接收器)</td><td style="text-align:left">一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。</td></tr><tr><td style="text-align:left">Content Provider(内容提供者)</td><td style="text-align:left">作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等）</td></tr></tbody></table></div><h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><div class="table-container"><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">onCreate()</td><td style="text-align:left">一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td style="text-align:left">onStart()</td><td style="text-align:left">当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td style="text-align:left">onResume()</td><td style="text-align:left">这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td style="text-align:left">onPause()</td><td style="text-align:left">这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td style="text-align:left">onStop()</td><td style="text-align:left">这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td style="text-align:left">onDestroy()</td><td style="text-align:left">这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td style="text-align:left">onRestart()</td><td style="text-align:left">当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501190150532.png" alt="1737222612157.png"></p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><h4 id="1-修改debug权限"><a href="#1-修改debug权限" class="headerlink" title="1.修改debug权限"></a>1.修改debug权限</h4><p><strong>方法一</strong>:在AndroidManifest.xml里添加可调试权限（在application里）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:debuggable=&quot;true&quot;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：XappDebug模块hook对应的app</p><p><a href="https://github.com/Palatis/XAppDebug">XappDebug</a></p><p><strong>方法三</strong>：Magisk命令(重启失效)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>  adb shell #adb进入命令行模式</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span>  su #切换至超级用户</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span>  magisk resetprop ro.debuggable 1</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span>  stop;start; #一定要通过该方式重启</span><br></pre></td></tr></table></figure><p><strong>方法四</strong>:刷入MagiskHide Props Config模块</p><p>一般来说，在4选项中如果有ro.debuggable那就直接修改<br>没有的话就选5<br><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501211617314.png" alt="1737447405593.png"></p><p>修改ro.debuggable的值为1</p><h4 id="2-端口转发以及开启adb权限"><a href="#2-端口转发以及开启adb权限" class="headerlink" title="2.端口转发以及开启adb权限"></a>2.端口转发以及开启adb权限</h4><p>版本号点击七次开启开发者模式并开启adb调试权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:9999 tcp:9999</span><br></pre></td></tr></table></figure><h4 id="3-下段点"><a href="#3-下段点" class="headerlink" title="3.下段点"></a>3.下段点</h4><p>ctrl+b下断点</p><h4 id="4-debug模式启动"><a href="#4-debug模式启动" class="headerlink" title="4.debug模式启动"></a>4.debug模式启动</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n <span class="keyword">com</span>.zj.wuaipojie/.ui.MainActivity</span><br></pre></td></tr></table></figure><p>adb shell am start -D -n<br>adb shell am start -D -n 包名/类名<br>am start -n 表示启动一个activity<br>am start -D 表示将应用设置为可调试模式</p><h4 id="5-Jeb附加调试进程"><a href="#5-Jeb附加调试进程" class="headerlink" title="5.Jeb附加调试进程"></a>5.Jeb附加调试进程</h4><h3 id="Log插桩"><a href="#Log插桩" class="headerlink" title="Log插桩"></a>Log插桩</h3><p>定义：Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;对应寄存器&#125;, <span class="class">Lcom/mtools/LogUtils;</span>-&gt;v(<span class="class">Ljava/lang/Object;</span>)V</span><br></pre></td></tr></table></figure><h2 id="smali及其语法"><a href="#smali及其语法" class="headerlink" title="smali及其语法"></a>smali及其语法</h2><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">.class</td><td style="text-align:left">类名</td></tr><tr><td style="text-align:left">.super</td><td style="text-align:left">父类名，继承的上级类名名称</td></tr><tr><td style="text-align:left">.source</td><td style="text-align:left">源名</td></tr><tr><td style="text-align:left">.field</td><td style="text-align:left">变量</td></tr><tr><td style="text-align:left">.method</td><td style="text-align:left">方法名</td></tr><tr><td style="text-align:left">.register</td><td style="text-align:left">寄存器</td></tr><tr><td style="text-align:left">.end method</td><td style="text-align:left">方法名的结束</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">公有</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">半公开，只有同一家人才能用</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">私有，只能自己使用</td></tr><tr><td style="text-align:left">.parameter</td><td style="text-align:left">方法参数</td></tr><tr><td style="text-align:left">.prologue</td><td style="text-align:left">方法开始</td></tr><tr><td style="text-align:left">.line xxx</td><td style="text-align:left">位于第xxx行</td></tr></tbody></table></div><h3 id="数据类型对应"><a href="#数据类型对应" class="headerlink" title="数据类型对应"></a>数据类型对应</h3><div class="table-container"><table><thead><tr><th style="text-align:left">smali类型</th><th style="text-align:left">java类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">V</td><td style="text-align:left">void</td><td style="text-align:left">无返回值</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">boolean</td><td style="text-align:left">布尔值类型，返回0或1</td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">byte</td><td style="text-align:left">字节类型，返回字节</td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">short</td><td style="text-align:left">短整数类型，返回数字</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">char</td><td style="text-align:left">字符类型，返回字符</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">int</td><td style="text-align:left">整数类型，返回数字</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">long （64位 需要2个寄存器存储）</td><td style="text-align:left">长整数类型，返回数字</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">float</td><td style="text-align:left">单浮点类型，返回数字</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">double （64位 需要2个寄存器存储）</td><td style="text-align:left">双浮点类型，返回数字</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">String</td><td style="text-align:left">文本类型，返回字符串</td></tr><tr><td style="text-align:left">Lxxx/xxx/xxx</td><td style="text-align:left">object</td><td style="text-align:left">对象类型，返回对象</td></tr></tbody></table></div><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container"><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">const</td><td style="text-align:left">重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td style="text-align:left">const-string</td><td style="text-align:left">重写字符串内容</td></tr><tr><td style="text-align:left">const-wide</td><td style="text-align:left">重写长整数类型，多用于修改到期时间。</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">返回指令</td></tr><tr><td style="text-align:left">if-eq</td><td style="text-align:left">全称equal(a=b)，比较寄存器ab内容，相同则跳</td></tr><tr><td style="text-align:left">if-ne</td><td style="text-align:left">全称not equal(a!=b)，ab内容不相同则跳</td></tr><tr><td style="text-align:left">if-eqz</td><td style="text-align:left">全称equal zero(a=0)，z即是0的标记，a等于0则跳</td></tr><tr><td style="text-align:left">if-nez</td><td style="text-align:left">全称not equal zero(a!=0)，a不等于0则跳</td></tr><tr><td style="text-align:left">if-ge</td><td style="text-align:left">全称greater equal(a&gt;=b)，a大于或等于则跳</td></tr><tr><td style="text-align:left">if-le</td><td style="text-align:left">全称little equal(a&lt;=b)，a小于或等于则跳</td></tr><tr><td style="text-align:left">goto</td><td style="text-align:left">强制跳到指定位置</td></tr><tr><td style="text-align:left">switch</td><td style="text-align:left">分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td style="text-align:left">iget</td><td style="text-align:left">获取寄存器数据</td></tr></tbody></table></div><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>在smail里所有操作通过寄存器来进行</p><ul><li><strong>本地寄存器</strong>：v开头数字结尾 v0</li><li><strong>参数寄存器</strong>：p开头数字结尾 p0</li></ul><p><strong>Q</strong> ：p0一定是第一个参数吗？</p><p><strong>A</strong>：在static函数中p0对应第一个参数（因为java语法里没有static语法）</p><p>在非static函数中，p0代指 <strong>“this”</strong>，p1表示函数的第一个参数</p><h2 id="实战原理"><a href="#实战原理" class="headerlink" title="实战原理"></a>实战原理</h2><h3 id="双开原理"><a href="#双开原理" class="headerlink" title="双开原理"></a>双开原理</h3><ul><li><strong>修改包名</strong>：让手机系统认为这是2个APP实现，改变了应用的签名信息，如果有签名校验则可能闪退崩溃</li><li><strong>修改Framework</strong></li><li><strong>通过虚拟化技术实现</strong></li><li><strong>以插件机制运行</strong>：利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。</li></ul><h3 id="去广告"><a href="#去广告" class="headerlink" title="去广告"></a>去广告</h3><p>启动广告流程：</p><ul><li>启动Activity-&gt;广告Activity-&gt;主页Activity</li></ul><p>修改方法：</p><ul><li>修改加载时间</li><li>Acitivity切换定位，修改Intent的Activity类名</li></ul><h3 id="弹窗定位-amp-堆栈分析"><a href="#弹窗定位-amp-堆栈分析" class="headerlink" title="弹窗定位&amp;堆栈分析"></a>弹窗定位&amp;堆栈分析</h3><p>修改方法：<br>1.修改xml中的versiocode<br>2.Hook弹窗(推荐算法助手开启弹窗定位)<br>3.修改dex弹窗代码<br>4.抓包修改响应体(也可以路由器拦截)</p><h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>1.开发者助手抓布局<br>2.MT管理器xml搜索定位<br>3.修改xml代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility=&quot;gone&quot;</span><br></pre></td></tr></table></figure><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件结构学习</title>
      <link href="/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>资料来源：《逆向工程核心原理》和<a href="https://www.youtube.com/watch?v=oSpeXGHaKAk&amp;t=15123s">PE文件结构格式详解（完整版）【逆向编程】 (youtube.com)</a></p><h1 id="一、PE文件基础"><a href="#一、PE文件基础" class="headerlink" title="一、PE文件基础"></a>一、PE文件基础</h1><h2 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h2><p>Windows：PE</p><p>Linux: elf</p><h2 id="2-PE文件特征"><a href="#2-PE文件特征" class="headerlink" title="2.PE文件特征"></a>2.PE文件特征</h2><p>PE文件指纹</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011858080.png" alt="1735729100495.png"></p><h2 id="3-PE结构"><a href="#3-PE结构" class="headerlink" title="3.PE结构"></a>3.PE结构</h2><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859756.png" alt="1735729120355.png"></p><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><ul><li><strong>DOS MZ头</strong>  <strong>IMAGE_DOS_HEADER(64字节)</strong></li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859938.png" alt="1735729155568.png"></p><p><strong>e_magic</strong>：4D5A是DOS签名，不可改</p><p><strong>e_lfanew</strong>：78指向PE头开始位置，要改要一起改。</p><p>上面两个是<strong>PE指纹</strong>，操作系统用来<strong>识别是否是PE文件</strong>，其他地方可以随便改，因为<em>IMAGE_DOS_HEADER</em>是给16位平台看的，而我们现在的环境大部分是32位或者64位。</p><ul><li><strong>MS_DOS Stu</strong>，DOS存根，用来给链接器插入数据，随便改</li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011900211.png" alt="1735729196266.png"></p><h3 id="NT头-IMAGE-NT-HEADERS"><a href="#NT头-IMAGE-NT-HEADERS" class="headerlink" title="NT头 IMAGE_NT_HEADERS"></a>NT头 IMAGE_NT_HEADERS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line"> DWORD Signature; ``<span class="comment">// PE标识</span></span><br><span class="line"> IMAGE_FILE_HEADER FileHeader; ``<span class="comment">// 标准PE头</span></span><br><span class="line"> IMAGE_OPTIONAL_HEADER32 OptionalHeader; ``<span class="comment">// 扩展PE头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h4 id="PE标识-Signature-4字节"><a href="#PE标识-Signature-4字节" class="headerlink" title="PE标识 Signature 4字节"></a>PE标识 Signature 4字节</h4><p><strong><u>不可改</u></strong>,操作系统启动程序的时候识别这个标识。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011901322.png" alt="1735729196266.png"></p><h4 id="标准PE头-IMAGE-FILE-HEADER-20字节"><a href="#标准PE头-IMAGE-FILE-HEADER-20字节" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER(20字节)"></a>标准PE头 <strong>IMAGE_FILE_HEADER</strong>(20字节)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line"> WORD Machine; <span class="comment">// 可以运行在什么样的CPU上</span></span><br><span class="line"> WORD NumberOfSections; <span class="comment">// 表示节的数量</span></span><br><span class="line"> DWORD TimeDateStamp; <span class="comment">// 编译器填写的时间戳</span></span><br><span class="line"> DWORD PointerToSymbolTable; <span class="comment">// 调试相关</span></span><br><span class="line"> DWORD NumberOfSymbols; <span class="comment">// 调试相关</span></span><br><span class="line"> WORD SizeOfOptionalHeader; <span class="comment">// 扩展PE头的大小</span></span><br><span class="line"> WORD Characteristics; <span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902971.png" alt="1735729302371.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902440.png" alt="1735729314190.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902205.png" alt="1735729331600.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">64 86 -&gt;8664 代表在x64上运行</span><br><span class="line">0F 00 有0x0F个节区</span><br><span class="line">84 D7 68 65 编译器写的时间戳，和文件无关，随便改</span><br><span class="line">调试不管</span><br><span class="line">F0 00 扩展PE头大小，可改</span><br><span class="line">22 00-&gt;0022-&gt; 0000 0000 0010 0010 第2位，第6位有值 对应数据位1，5 分别代表文件可执行，应用程序可以处理大于2GB的地址（代表64位）</span><br></pre></td></tr></table></figure><h4 id="扩展PE头-IMAGE-OPTIONAL-HEADER"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="扩展PE头  IMAGE_OPTIONAL_HEADER"></a>扩展PE头  IMAGE_OPTIONAL_HEADER</h4><h5 id="扩展PE头结构-amp-不同编译器上的差异"><a href="#扩展PE头结构-amp-不同编译器上的差异" class="headerlink" title="扩展PE头结构&amp;不同编译器上的差异"></a>扩展PE头结构&amp;不同编译器上的差异</h5><p>32位上是224字节（E0)（可扩展）</p><p>64位是F0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位为例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER32</span> &#123;</span></span><br><span class="line">    WORD    Magic;                  <span class="comment">// 标志：PE32 是 0x10B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;     <span class="comment">// 链接器的主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;     <span class="comment">// 链接器的次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;             <span class="comment">// 代码段的大小（没用）</span></span><br><span class="line">    DWORD   SizeOfInitializedData;  <span class="comment">// 初始化数据段的大小（没用）</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">// 未初始化数据段的大小（没用）</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;    <span class="comment">// 程序入口点的 RVA</span></span><br><span class="line">    DWORD   BaseOfCode;             <span class="comment">// 代码段的起始 RVA（没用）</span></span><br><span class="line">    DWORD   BaseOfData;             <span class="comment">// 数据段的起始 RVA（没用）</span></span><br><span class="line">    DWORD   ImageBase;              <span class="comment">// 内存镜像基址</span></span><br><span class="line">    DWORD   SectionAlignment;       <span class="comment">// 内存对齐</span></span><br><span class="line">    DWORD   FileAlignment;          <span class="comment">// 文件对齐</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion; <span class="comment">// OS 主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion; <span class="comment">// OS 次版本号</span></span><br><span class="line">    DWORD   SizeOfImage;            <span class="comment">// 镜像的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;          <span class="comment">// 头+节表按照文件对齐后的总大小</span></span><br><span class="line">    DWORD   CheckSum;               <span class="comment">// 校验和</span></span><br><span class="line">    WORD    Subsystem;              <span class="comment">// 子系统（如 GUI、CUI）</span></span><br><span class="line">    WORD    DllCharacteristics;    <span class="comment">// DLL 属性</span></span><br><span class="line">    DWORD   SizeOfStackReserve;     <span class="comment">// 堆栈保留大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;      <span class="comment">// 堆栈提交大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;      <span class="comment">// 堆保留大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;       <span class="comment">// 堆提交大小</span></span><br><span class="line">    DWORD   LoaderFlags;            <span class="comment">// 装载器标志（通常为 0）</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;    <span class="comment">// 数据目录项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">16</span>]; <span class="comment">// 表，结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>字段名称</strong></th><th><strong>32 位 PE（PE32）</strong></th><th><strong>64 位 PE（PE32+）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>Magic</code></td><td><code>0x10B</code></td><td><code>0x20B</code></td><td>标识 PE 文件是 32 位（PE32）还是 64 位（PE32+）。</td></tr><tr><td><code>AddressOfEntryPoint</code></td><td>存在</td><td>存在</td><td>程序入口点的 RVA（相对虚拟地址）。</td></tr><tr><td><code>BaseOfCode</code></td><td>存在</td><td>存在</td><td>代码段的起始 RVA。</td></tr><tr><td><code>BaseOfData</code></td><td>存在</td><td><strong>不存在</strong></td><td>数据段的起始 RVA，<strong>仅在 PE32 中存在</strong>。</td></tr><tr><td><code>ImageBase</code></td><td>32 位地址（默认 0x00400000）</td><td>64 位地址（默认 0x0000000140000000）</td><td>可执行文件加载到内存中的首地址。</td></tr><tr><td><code>SizeOfStackReserve</code></td><td>32 位值</td><td>64 位值</td><td>为线程的堆栈预留的大小。</td></tr><tr><td><code>SizeOfHeapReserve</code></td><td>32 位值</td><td>64 位值</td><td>为堆分配的保留大小。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011903423.png" alt="1735729389033.png"></p><ul><li><strong>Magic</strong></li></ul><p>2个字节，文件的标志</p><p>32 位：10B</p><p>64 位：20B </p><ul><li><strong>AddressOfEntryPoint</strong></li></ul><p>4个字节，程序的入口点地址，即执行开始的位置。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904115.png" alt="1735729398902.png"></p><ul><li><strong>ImageBase</strong></li></ul><p>4个字节，程序加载的基地址。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904366.png" alt="1735729409663.png"></p><p>AddressOfEntryPoint：<u>042CE910</u></p><p>imagebase:<u>00000010</u></p><p>程序执行入口：（EIP)042CE910+00000010=042CE920</p><ul><li><strong>SectionAlignment</strong></li></ul><p>节区的内存对齐大小，节区在<strong>内存</strong>中的最小大小。</p><ul><li><strong>FileAlignment</strong></li></ul><p>节区的文件对齐大小，节区在<strong>磁盘文件</strong>中的最小单位。</p><ul><li><strong>SizeOfImage</strong></li></ul><p>表示在内存中<strong>整个</strong>PE文件映射的大小（包括所有节区和头信息），可比实际的值大。内存对齐以后是SectionAlignment或者FileAlignment的整数倍。</p><ul><li><strong>SizeOfHeaders</strong></li></ul><p>PE 文件头的大小。是<strong>FileAlignment的整数倍</strong>。</p><ul><li><strong>CheckSum</strong></li></ul><p>校验和，系统用来检测文件是否被修改</p><ul><li><strong>Subsystem</strong></li></ul><p>程序的子系统类型（例如，Windows GUI 或控制台应用程序），用来表示PE文件的特性。</p><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p><strong>IMAGE_SECTION_HEADER</strong> (40字节)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[<span class="number">8</span>];               <span class="comment">// 节名称（最多 8 字节，可能没有结束符）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   PhysicalAddress;   <span class="comment">// 实际已弃用，常为 0</span></span><br><span class="line">        DWORD   VirtualSize;       <span class="comment">// 节的实际大小（内存中的大小）</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;        <span class="comment">// 节在内存中的 RVA（相对虚拟地址）</span></span><br><span class="line">    DWORD   SizeOfRawData;         <span class="comment">// 节在文件中的大小（以 FileAlignment 对齐）</span></span><br><span class="line">    DWORD   PointerToRawData;      <span class="comment">// 节在文件中的偏移（以 FileAlignment 对齐）</span></span><br><span class="line">    DWORD   PointerToRelocations; <span class="comment">// 重定位表的文件偏移（通常为 0，已弃用）</span></span><br><span class="line">    DWORD   PointerToLinenumbers; <span class="comment">// 调试信息的文件偏移（通常为 0）</span></span><br><span class="line">    WORD    NumberOfRelocations;  <span class="comment">// 重定位条目数量（通常为 0）</span></span><br><span class="line">    WORD    NumberOfLinenumbers;  <span class="comment">// 调试行号条目数量（通常为 0）</span></span><br><span class="line">    DWORD   Characteristics;      <span class="comment">// 节的属性标志（权限、类型等）</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>红色框出来的是扩展PE头，下面就是节表</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904634.png" alt="1735729466460.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905916.png" alt="1735729479345.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905144.png" alt=""></p><ul><li><h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4></li></ul><p>8字节，当前节的名字，可以随意更改。</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106081.png" alt="image"></h5><p>当前这个节未对齐时的大小，即实际大小。</p><p>实际大小有可能会比Size of Raw Data大，因为未初始化的全局变量在文件中是不占空间的，但是在内存里是有位置的。</p><p><strong>Q</strong>：在内存中展开时以什么为基准呢？</p><p><strong>A</strong>：谁大按谁，如果Vitual Size&gt;Size of Raw Data,则按照Vitual Size展开，反之则按照Size of Raw Data。</p><ul><li><h4 id="VirtualAddress（RVA）"><a href="#VirtualAddress（RVA）" class="headerlink" title="VirtualAddress（RVA）"></a>VirtualAddress（RVA）</h4></li></ul><p>在内存中的偏移地址，加上ImageBase则是内存中的真实地址。</p><ul><li><h4 id="Raw-Size-Size-of-Raw-Data"><a href="#Raw-Size-Size-of-Raw-Data" class="headerlink" title="Raw Size(Size of Raw Data)"></a>Raw Size(Size of Raw Data)</h4></li></ul><p>文件对齐后的大小</p><ul><li><h4 id="Raw-Address-File-Pointer-to-Raw-Data"><a href="#Raw-Address-File-Pointer-to-Raw-Data" class="headerlink" title="Raw Address(File Pointer to Raw Data)"></a><strong>Raw Address</strong>(File Pointer to Raw Data)</h4></li></ul><p>当前节在文件中起始位置</p><ul><li><h4 id="Reloc-Address"><a href="#Reloc-Address" class="headerlink" title="Reloc Address"></a><strong>Reloc Address</strong></h4></li></ul><p>节的重定位表（如果有的话）在文件中的偏移地址。</p><ul><li><h4 id="Line-Numbers、Relocation-Number、Line-Number-Numbers"><a href="#Line-Numbers、Relocation-Number、Line-Number-Numbers" class="headerlink" title="Line Numbers、Relocation Number、Line Number Numbers"></a><strong>Line Numbers</strong>、<strong>Relocation Number</strong>、<strong>Line Number Numbers</strong></h4></li></ul><p>与调试信息和重定位表相关。</p><ul><li><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4></li></ul><p>节区属性</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106048.png" alt="image"></p><h3 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h3><p>文件对齐和内存对齐的差异：</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106850.png" alt="image"></p><h2 id="4、RVA和FOA的转换"><a href="#4、RVA和FOA的转换" class="headerlink" title="4、RVA和FOA的转换"></a>4、RVA和FOA的转换</h2><p><strong>VA</strong>：虚拟内存的绝对地址。</p><p><strong>RVA</strong>：相对虚拟地址，从ImageBase开始的相对地址。</p><p><strong>FOA</strong>：文件偏移地址</p><p><strong>Q</strong>：想改边一个全局变量的初始值，应该怎么做？</p><p><strong>A</strong>：先区分全局变量有无初始值。如果有初始值，全局变量储存在文件中，如果没有初始值，在文件里就没有位置，在内存展开时才会分配位置。</p><p><1>、判断RVA是否在头部，在的话直接返回</p><p>FOA=RVA</p><p><2>、判断RVA在哪一个节</p><p>RVA&gt;=节.VA</p><p>RVA&lt;=节.VA+当前节内存对其后大小</p><p>差值=RVA-节.VA</p><p><4>、FOA=节.PointerToRawData+差值</p><p>看一下书上的例子，实例下面导入表的计算也有提到</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052107891.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108166.png" alt="image"></p><p><strong>算完RAW记得查看是否和内存中在同一节区！！！</strong>如上图Q3</p><h2 id="5、手撕PE文件"><a href="#5、手撕PE文件" class="headerlink" title="5、手撕PE文件"></a>5、手撕PE文件</h2><h3 id="（1）在空白区添加代码"><a href="#（1）在空白区添加代码" class="headerlink" title="（1）在空白区添加代码"></a>（1）在空白区添加代码</h3><h3 id="（2）扩大节"><a href="#（2）扩大节" class="headerlink" title="（2）扩大节"></a>（2）扩大节</h3><h3 id="（3）删除节"><a href="#（3）删除节" class="headerlink" title="（3）删除节"></a>（3）删除节</h3><h3 id="（4）新添节"><a href="#（4）新添节" class="headerlink" title="（4）新添节"></a>（4）新添节</h3><h3 id="（5）合并节"><a href="#（5）合并节" class="headerlink" title="（5）合并节"></a>（5）合并节</h3><h2 id="6、导出表-amp-导入表"><a href="#6、导出表-amp-导入表" class="headerlink" title="6、导出表&amp;导入表"></a>6、导出表&amp;导入表</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先明白，一个可执行程序是有<strong>多个pe文件组成</strong>的。</p><p><strong>导入表（IMP)</strong>：PE文件引用了哪些文件</p><ul><li><strong>导入地址表IAT</strong>：储存导入函数在内存里的实际应用。</li><li><strong>导入名称表INT</strong>：每个dll导入描述符，储存函数名或者序号，用于加载解析函数地址。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>组件</strong></th><th style="text-align:left"><strong>内容（磁盘）</strong></th><th style="text-align:left"><strong>内容（内存）</strong></th><th style="text-align:left"><strong>作用</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>导入表（IMP）</strong></td><td style="text-align:left">所有导入DLL的描述信息</td><td style="text-align:left">不变</td><td style="text-align:left">管理所有导入的DLL和函数引用</td></tr><tr><td style="text-align:left"><strong>导入名称表（INT）</strong></td><td style="text-align:left">函数名称/序号的RVA</td><td style="text-align:left">不变（或不存在于内存）</td><td style="text-align:left">提供加载时解析函数地址的线索</td></tr><tr><td style="text-align:left"><strong>导入地址表（IAT）</strong></td><td style="text-align:left">初始为函数名称/序号的RVA</td><td style="text-align:left">实际函数地址</td><td style="text-align:left">运行时跳转到目标函数的地址表</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Import Table (IMP)</span><br><span class="line">├─ IMAGE_IMPORT_DESCRIPTOR 1 (DLL1)</span><br><span class="line">│  ├─ OriginalFirstThunk → INT (函数名称/序号)</span><br><span class="line">│  └─ FirstThunk → IAT (初始同INT，加载后为地址)</span><br><span class="line">├─ IMAGE_IMPORT_DESCRIPTOR 2 (DLL2)</span><br><span class="line">│  ├─ OriginalFirstThunk → INT</span><br><span class="line">│  └─ FirstThunk → IAT</span><br><span class="line">└─ ...</span><br></pre></td></tr></table></figure><p><strong>导出表(EAT)</strong>：当前的PE文件储存了哪些函数给其他文件用。</p><p><strong>Q</strong>：导出表在哪？</p><p><strong>A</strong>：再扩展PE头最后一个成员</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108437.png" alt="image"></p><h4 id="Dll"><a href="#Dll" class="headerlink" title="Dll"></a>Dll</h4><p>动态链接库</p><p>加载DLL的两种方式</p><ul><li><strong>显式链接</strong>：程序使用DLL时候加载，使用完释放内存。</li><li><strong>隐式链接</strong>：程序开始时一同加载DLL，程序终止时释放内存。</li></ul><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052109509.png" alt="image"></h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052110010.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111005.png" alt="image"></p><p>先找到导出表位置</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111830.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111561.png" alt="image"></p><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>确定依赖的函数</p><p><strong>导入表位置</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112545.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112232.png" alt="image"></p><p><strong>导入表结构</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112548.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113698.png" alt="image"></p><h4 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h4><p>字符串指针，指向导入函数所属的库文件名字。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113795.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113568.png" alt="image"></p><p>RVA要转成FOA，参考下面的实际计算</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114790.png" alt="image"></p><p>因为指向的是assic码的字符串，所以到第一个00结束</p><h4 id="OringinalFirstThunk-INT"><a href="#OringinalFirstThunk-INT" class="headerlink" title="OringinalFirstThunk-INT"></a>OringinalFirstThunk-INT</h4><p>导入名称表<img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114717.png" alt="image"></p><h4 id="FirstThunk-IAT"><a href="#FirstThunk-IAT" class="headerlink" title="FirstThunk-IAT"></a>FirstThunk-IAT</h4><p>导入地址表</p><h3 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h3><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052115276.png" alt="image"></p><p>Export Directory RVA：93 5D 82 09-&gt;0x09825D93(imagebase:0x00000010)查了一下再rdata段-&gt;FOA：0x09825D83</p><p>Export Directory Size：00033669</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116225.png" alt="image"></p><p>看了010半天不对，dumpbin /headers看了一下，然后又开了个exe，发现这个爆红的意思是typora.exe没有导入表导出表。。。(也有可能有加壳？die看了一下没有，但是这个地址太大了不正常)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /headers &quot;D:\Typora\Typora\Typora.exe&quot;</span><br></pre></td></tr></table></figure><p>换个文件来</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116588.png" alt="image"></p><p>Import Directory RVA：0x00003824，在.rdata段，rdata段的RVA是0x00003000，所以相对地址就是0x00000824，rdata段的raw address是0x00001A00，所以FOA是0x00002224，大小是C8字节</p><p><strong>Import Directory RVA</strong>：0x00003824</p><p><strong>.rdata段的 RVA</strong>：0x00003000</p><p><strong>.rdata段的 Raw Address</strong>：0x00001A00</p><p><strong>.rdata段的 Raw Size</strong>：C8 字节（即 200 字节）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相对地址 <span class="operator">=</span> <span class="built_in">Import</span> <span class="built_in">Directory</span> <span class="variable">RVA</span> <span class="operator">-</span> <span class="operator">.</span><span class="variable">rdata</span>段的 <span class="variable">RVA</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00003824</span> <span class="operator">-</span> <span class="number">0</span><span class="variable">x00003000</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00000824</span></span><br><span class="line"></span><br><span class="line"><span class="variable">FOA</span> <span class="operator">=</span> <span class="operator">.</span><span class="variable">rdata</span>段的 <span class="variable">Raw</span> <span class="variable">Address</span> <span class="operator">+</span> 相对地址 <span class="operator">=</span><span class="number">0</span><span class="variable">x00001A00</span> <span class="operator">+</span> <span class="number">0</span><span class="variable">x00000824</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00002224</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116426.png" alt="image"></p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF</title>
      <link href="/2025/01/05/NSSCTF/"/>
      <url>/2025/01/05/NSSCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="easyRE（虚函数表-反调试-内联函数）"><a href="#easyRE（虚函数表-反调试-内联函数）" class="headerlink" title="easyRE（虚函数表+反调试+内联函数）"></a>easyRE（虚函数表+反调试+内联函数）</h2><p><a href="https://www.nssctf.cn/problem/43">[SWPU 2019]easyRE | NSSCTF</a></p><p>没做出来，看了佬的wp才理清思路<a href="https://bbs.kanxue.com/thread-271798.htm#msg_header_h3_2">[原创] SWPUCTF 2019 easyRE-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD v4[<span class="number">30</span>]; <span class="comment">// [esp-6Ch] [ebp-F8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+Ch] [ebp-80h]</span></span><br><span class="line">  _DWORD v6[<span class="number">27</span>]; <span class="comment">// [esp+10h] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+88h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_40EF90</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                                   <span class="comment">// 反调试</span></span><br><span class="line">  <span class="built_in">sub_4026C0</span>(<span class="number">0x6Cu</span>);</span><br><span class="line">  <span class="built_in">sub_401FE0</span>(v6);                               <span class="comment">// vftable虚函数表</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v4[<span class="number">29</span>] = v4;</span><br><span class="line">  <span class="built_in">sub_40F360</span>(v4, v6);</span><br><span class="line">  <span class="built_in">sub_40F080</span>(v4[<span class="number">0</span>], v4[<span class="number">1</span>]);</span><br><span class="line">  v4[<span class="number">28</span>] = v4;</span><br><span class="line">  <span class="built_in">sub_40F360</span>(v4, v6);</span><br><span class="line">  <span class="built_in">sub_40F150</span>(argc, (<span class="type">int</span>)argv);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sub_4021C0</span>(v6);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反调试patch掉就行</p><h4 id="sub-401FE0"><a href="#sub-401FE0" class="headerlink" title="sub_401FE0"></a>sub_401FE0</h4><p>这里创建了一个虚函数表，下面的偏移是对比用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD *__thiscall <span class="title">sub_401FE0</span><span class="params">(_DWORD *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> = &amp;EASYRE::`vftable<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">  this[1] = 0;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 52) = 8;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 53) = 0xEA;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 54) = 0x58;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 55) = 0xDE;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 56) = 0x94;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 57) = 0xD0;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 58) = 0x3B;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 59) = 0xBE;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 60) = 0x88;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 61) = 0xD4;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 62) = 0x32;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 63) = 0xB6;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 64) = 0x14;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 65) = 0x82;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 66) = 0xB7;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 67) = 0xAF;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 68) = 0x14;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 69) = 0x54;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 70) = 0x7F;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 71) = 0xCF;</span></span><br><span class="line"><span class="string">  qmemcpy(this + 0x12, &quot;  03\&quot;3   0 203\&quot;   $ &quot;, 20);</span></span><br><span class="line"><span class="string">  sub_4030A0(this + 0x17);</span></span><br><span class="line"><span class="string">  sub_402DE0(this + 0x1A);</span></span><br><span class="line"><span class="string">  for ( i = 0; i &lt; 40; ++i )</span></span><br><span class="line"><span class="string">    *((_BYTE *)this + i + 12) = 0;</span></span><br><span class="line"><span class="string">  return this;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.rdata:004124E4 90 21 40 00                   ??_7EASYRE@@6B@ dd offset sub_402190    ; DATA XREF: sub_401FE0+2B↑o</span><br><span class="line">.rdata:004124E4                                                                       ; sub_4021C0+A↑o</span><br><span class="line">.rdata:004124E4                                                                       ; sub_40F360+C↑o</span><br><span class="line">.rdata:004124E8 F0 21 40 00                   dd offset sub_4021F0</span><br><span class="line">.rdata:004124EC B0 24 40 00                   dd offset sub_4024B0</span><br><span class="line">.rdata:004124F0 00 25 40 00                   dd offset sub_402500</span><br><span class="line">.rdata:004124F4 F0 22 40 00                   dd offset sub_4022F0</span><br><span class="line">.rdata:004124F8 A0 23 40 00                   dd offset sub_4023A0</span><br><span class="line">.rdata:004124FC E0 26 40 00                   dd offset sub_4026E0</span><br><span class="line">.rdata:00412500 30 27 40 00                   dd offset sub_402730</span><br><span class="line">.rdata:00412504 E0 23 40 00                   dd offset sub_4023E0</span><br><span class="line">.rdata:00412508 A0 28 40 00                   dd offset sub_4028A0</span><br><span class="line">.rdata:0041250C 00 2A 40 00                   dd offset sub_402A00</span><br><span class="line">.rdata:00412510 40 24 40 00                   dd offset sub_402440</span><br><span class="line">.rdata:00412514 00 00 00 00                   align 8</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="sub-40F150"><a href="#sub-40F150" class="headerlink" title="sub_40F150"></a>sub_40F150</h4><p>找到对比函数</p><p> if ( sub_A124B0(va, input) )输出congratulations说明sub_A124B0是我们主要关注的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_40F150</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">10</span>]; <span class="comment">// [esp+Ch] [ebp-38h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+40h] [ebp-4h]</span></span><br><span class="line">  va_list va; <span class="comment">// [esp+54h] [ebp+10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span>(va, a2);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="built_in">sizeof</span>(v6));</span><br><span class="line">  v2 = <span class="built_in">printf</span>(std::cout, <span class="string">&quot;Please input your flag : &quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, sub_40F8F0);</span><br><span class="line">  <span class="built_in">sub_40F930</span>(std::cin, v6);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_4024B0</span>(v6) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">printf</span>(std::cout, &amp;unk_4122F0);        <span class="comment">// congratulations</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, sub_40F8F0);</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sub_4021C0</span>(va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">printf</span>(std::cout, &amp;unk_41231C);        <span class="comment">// sorry，try again</span></span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v5, sub_40F8F0);</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sub_4021C0</span>(va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sub-4024B0"><a href="#sub-4024B0" class="headerlink" title="sub_4024B0"></a>sub_4024B0</h4><p>对照虚函数表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL __thiscall <span class="title">sub_D724B0</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">2</span>] = a2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0xC</span>))(<span class="keyword">this</span>) )<span class="comment">// sub_402500 00D72500</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="built_in">void</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0x18</span>))(<span class="keyword">this</span>);<span class="comment">// sub_4026E0 00D824FC</span></span><br><span class="line">    <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0x28</span>))(<span class="keyword">this</span>) )<span class="comment">// sub_402A00 00D72A00</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化一下就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sub_402500（）</span><br><span class="line">    sub_<span class="number">4026E0</span>（）</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">sub_402A00</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 1</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> 0</span></span><br></pre></td></tr></table></figure><h4 id="sub-D72500"><a href="#sub-D72500" class="headerlink" title="sub_D72500"></a>sub_D72500</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __thiscall <span class="title">sub_D72500</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-B0h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// [esp+14h] [ebp-A8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+24h] [ebp-98h]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">56</span>]; <span class="comment">// [esp+30h] [ebp-8Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">20</span>]; <span class="comment">// [esp+68h] [ebp-54h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">48</span>]; <span class="comment">// [esp+7Ch] [ebp-40h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+B8h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = &amp;<span class="keyword">this</span>[<span class="number">2</span>][<span class="built_in">strlen</span>(<span class="keyword">this</span>[<span class="number">2</span>])];</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">&quot;Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_D726C0</span>(v6, <span class="number">0x38u</span>);                        <span class="comment">// 初始化v6</span></span><br><span class="line">  <span class="built_in">sub_D72B00</span>(v6);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i )</span><br><span class="line">    v8[i] ^= <span class="number">0x10u</span>;                             <span class="comment">// ^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span></span><br><span class="line">  <span class="built_in">sub_D726C0</span>(v7, <span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">sub_D72A70</span>(v8, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v9) = <span class="number">1</span>;</span><br><span class="line">  v2 = (<span class="type">unsigned</span> __int8)<span class="built_in">sub_D74260</span>(<span class="keyword">this</span>[<span class="number">2</span>], v3, v6, v7, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">LOBYTE</span>(v9) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">sub_D72A50</span>(v7);</span><br><span class="line">  v9 = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sub_D726A0</span>();</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501031630537.png" alt="1735892999415.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span><br></pre></td></tr></table></figure><p>有点像正则表达式，估计是flag格式</p><h4 id="sub-A12730"><a href="#sub-A12730" class="headerlink" title="sub_A12730"></a>sub_A12730</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __thiscall <span class="title">sub_A12730</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// bl</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// t2</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+Ch] [ebp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+14h] [ebp-28h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+1Ch] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+20h] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp+24h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp+28h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+2Ch] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp+30h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp+34h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="keyword">this</span>[<span class="number">2</span>] + <span class="number">5</span> * a2 + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i )</span><br><span class="line">    *(&amp;v13 + i) = *(i + v10);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(&amp;v13 + v2);                          <span class="comment">// 取单个字符</span></span><br><span class="line">    _DL = v4;</span><br><span class="line">    __asm &#123; rcl     dl, <span class="number">1</span> &#125;                     <span class="comment">// 循环左移直到CF为1</span></span><br><span class="line">    *(&amp;v15 + v2) = <span class="number">1</span>;                           <span class="comment">// 将1写入v15 v2个字节的位置</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>                                          <span class="comment">// v8=v6左移7位</span></span><br><span class="line">                                                <span class="comment">// v6=v4最低位</span></span><br><span class="line">                                                <span class="comment">// v4去掉最低有效位</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v6 &lt;&lt; <span class="number">7</span>;</span><br><span class="line">      v6 = v4 &amp; <span class="number">1</span>;</span><br><span class="line">      v4 = (v4 &gt;&gt; <span class="number">1</span>) | v8;</span><br><span class="line">      ++v7;                                     <span class="comment">// v7计算v4中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 );                               <span class="comment">// 如果v6为1 即v4的当前最低有效位是 1，继续循环，</span></span><br><span class="line">                                                <span class="comment">// v6为0则结束循环</span></span><br><span class="line">    *(&amp;v16 + v2++) = v7 - <span class="number">1</span>;                    <span class="comment">// 位宽度v16=v7-1</span></span><br><span class="line">    --v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 );</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    *(&amp;v14 + j) = *(&amp;v16 + j) + *(&amp;v15 + j);    <span class="comment">// 右边0的个数+左移至进位个数</span></span><br><span class="line">    *(&amp;v17 + j) = *(&amp;v13 + j) &lt;&lt; *(&amp;v15 + j);   <span class="comment">// flag&lt;&lt;左移至进位个数</span></span><br><span class="line">    *(&amp;v18 + j) = (*(&amp;v13 + j) &lt;&lt; (<span class="number">8</span> - *(&amp;v16 + j))) | ((*(&amp;v13 + j) &gt;&gt; (<span class="number">8</span> - *(&amp;v15 + j))) &lt;&lt; *(&amp;v15 + j));</span><br><span class="line">  &#125;                                             <span class="comment">// [flag&lt;&lt;（8-右边0的个数）]|&#123;[flag&gt;&gt;(8-左移至进位个数）]&lt;&lt;左移至进位个数&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_A12F80</span>(&amp;v13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外面的dowhile其实是在计算左移几位CF为1，里面的dowhile是在计算右边0的个数</p><h4 id="sub-A128A0"><a href="#sub-A128A0" class="headerlink" title="sub_A128A0"></a>sub_A128A0</h4><p>不想看了，大概看看感觉能爆破，不行再回来看</p><p>好吧还是得看</p><p>for循环嵌套if else，大概把上面加密完的flag分为两个部分处理。</p><p>前四次循环走else，对 <code>v15 + i + 20</code> 赋值</p><p>后四次走if，对 <code>v17 + 0x1A</code> 进行操作，更新 <code>v14</code> 并对 <code>v15</code> 执行位操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v17 = this;</span><br><span class="line">v15 = this + 3;</span><br><span class="line">*v15 |= *(v10 + i + 0x10) &lt;&lt; v14;</span><br><span class="line">*v15 |= *(v5 + i + 0x10) &lt;&lt; v14;</span><br><span class="line">*(v15 + i + 20) = *(v8 + i + 0xC) | v7;</span><br></pre></td></tr></table></figure><p>因为我们前面得到了flag格式，可以判断出来while走5次。</p><p>一个参与了加密一个没参与</p><p>这里用了佬简化完的加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;</span><br><span class="line">    v9 = sub_402DC0(v17 + <span class="number">26</span>);</span><br><span class="line">    v14 -= *(<span class="type">unsigned</span> __int8 *)(v9 + i); <span class="comment">// v14的初始值为0x20</span></span><br><span class="line">    *v15 |= res3 &lt;&lt; v14;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    v14 -= <span class="number">8</span> - res1;</span><br><span class="line">    *v15 |= res2 &lt;&lt; v14;</span><br><span class="line">    *((_BYTE *)v15 + i + <span class="number">20</span>) = <span class="number">0</span>的个数 | (<span class="number">16</span> * 左移进位位数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理一下逻辑</p><ul><li>校验flag格式</li><li>加密</li><li>5次循环处理加密，两种结果，一个受字符影响一个独立存在。</li><li>对比</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查左移进位位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_1</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = c &lt;&lt; <span class="number">1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">0x100</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查右边0的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_0</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        c = c &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标识符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_0</span>(<span class="params">c</span>):</span><br><span class="line">    res1 = check_0(c) + check_1(c)</span><br><span class="line">    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1</span><br><span class="line">    res3 = ((c &gt;&gt; (<span class="number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="number">8</span> - check_0(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1)</span><br><span class="line">    <span class="keyword">return</span> [res1, res2, res3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_part</span>(<span class="params">c,s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查字符的分类，并返回符合条件的字符&quot;&quot;&quot;</span></span><br><span class="line">    tmp = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))</span><br><span class="line">    tmp2=check_0(c) | (<span class="number">16</span>*check_1(c))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s2):</span><br><span class="line">        <span class="keyword">if</span> tmp2 ==<span class="built_in">ord</span>(i):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>():</span><br><span class="line">    for_each=string.ascii_lowercase+string.ascii_uppercase+string.digits</span><br><span class="line">    second_part_res = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">    d=<span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)):</span><br><span class="line">        d[i]=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> for_each:</span><br><span class="line">        tmp=check_part(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            d[tmp].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">c,v14</span>):</span><br><span class="line">    exam=&#123;c:generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14=v14-(<span class="number">8</span>-exam[c][<span class="number">0</span>])</span><br><span class="line">    tmp=exam[c][<span class="number">1</span>]&lt;&lt;v14</span><br><span class="line">    <span class="keyword">return</span> tmp,v14</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">c,v14</span>):</span><br><span class="line">    exam=&#123;c:generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14=v14-exam[c][<span class="number">0</span>]</span><br><span class="line">    tmp=exam[c][<span class="number">2</span>]&lt;&lt;v14</span><br><span class="line">    <span class="keyword">return</span> tmp,v14</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查左移进位位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_1</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = c &lt;&lt; <span class="number">1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">0x100</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查右边0的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_0</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        c = c &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标识符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_0</span>(<span class="params">c</span>):</span><br><span class="line">    res1 = check_0(c) + check_1(c)</span><br><span class="line">    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1</span><br><span class="line">    res3 = ((c &gt;&gt; (<span class="number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="number">8</span> - check_0(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1)</span><br><span class="line">    <span class="keyword">return</span> [res1, res2, res3]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_part</span>(<span class="params">c</span>):</span><br><span class="line">    tmp = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))</span><br><span class="line">    tmp2 = check_0(c) | (<span class="number">16</span> * check_1(c))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">        <span class="keyword">if</span> tmp2 == <span class="built_in">ord</span>(i):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>():</span><br><span class="line">    for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits</span><br><span class="line">    second_part_res = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)):</span><br><span class="line">        d[i] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> for_each:</span><br><span class="line">        tmp = check_part(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            d[tmp].append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">c, v14</span>):</span><br><span class="line">    exam = &#123;c: generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14 = v14 - (<span class="number">8</span> - exam[c][<span class="number">0</span>])</span><br><span class="line">    tmp = exam[c][<span class="number">1</span>] &lt;&lt; v14</span><br><span class="line">    <span class="keyword">return</span> tmp, v14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">c, v14</span>):</span><br><span class="line">    exam = &#123;c: generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14 = v14 - exam[c][<span class="number">0</span>]</span><br><span class="line">    tmp = exam[c][<span class="number">2</span>] &lt;&lt; v14</span><br><span class="line">    <span class="keyword">return</span> tmp, v14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算第一个部分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_first_part</span>(<span class="params">s</span>):</span><br><span class="line">    v14 = <span class="number">0x20</span></span><br><span class="line">    tmp, v14 = test_1(s[<span class="number">0</span>], v14)</span><br><span class="line">    tmp2, v14 = test_1(s[<span class="number">1</span>], v14)</span><br><span class="line">    tmp3, v14 = test_1(s[<span class="number">2</span>], v14)</span><br><span class="line">    tmp4, v14 = test_1(s[<span class="number">3</span>], v14)</span><br><span class="line">    tmp5, v14 = test_2(s[<span class="number">0</span>], v14)</span><br><span class="line">    tmp6, v14 = test_2(s[<span class="number">1</span>], v14)</span><br><span class="line">    tmp7, v14 = test_2(s[<span class="number">2</span>], v14)</span><br><span class="line">    tmp8, v14 = test_2(s[<span class="number">3</span>], v14)</span><br><span class="line">    <span class="keyword">return</span> tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查第一个部分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_first_part</span>(<span class="params">second_part, first_part, d</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> d[second_part[<span class="number">0</span>]]:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> d[second_part[<span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> d[second_part[<span class="number">2</span>]]:</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> d[second_part[<span class="number">3</span>]]:</span><br><span class="line">                    tmp = i + j + k + m</span><br><span class="line">                    <span class="keyword">if</span> calc_first_part(tmp) == first_part:</span><br><span class="line">                        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line">d = classify()</span><br><span class="line">s2 = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">s = [<span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;EA&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;DE&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;3B&#x27;</span>, <span class="string">&#x27;BE&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;D4&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;B6&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;B7&#x27;</span>, <span class="string">&#x27;AF&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;7F&#x27;</span>, <span class="string">&#x27;CF&#x27;</span>]</span><br><span class="line">flag = <span class="string">&#x27;swpuctf&#123;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    first_part = <span class="built_in">int</span>(s[<span class="number">3</span> + <span class="number">4</span> * i] + s[<span class="number">2</span> + <span class="number">4</span> * i] + s[<span class="number">1</span> + <span class="number">4</span> * i] + s[<span class="number">4</span> * i], <span class="number">16</span>)</span><br><span class="line">    second_part = s2[i * <span class="number">4</span>:i * <span class="number">4</span> + <span class="number">4</span>]</span><br><span class="line">    res = check_first_part(second_part, first_part, d)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        flag += res</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    flag += res + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">flag += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#swpuctf&#123;we18-l8co-m1e4-58to-swpu&#125;</span></span><br></pre></td></tr></table></figure><h2 id="EasiestRe（双进程-自修改-背包加密）"><a href="#EasiestRe（双进程-自修改-背包加密）" class="headerlink" title="EasiestRe（双进程+自修改+背包加密）"></a>EasiestRe（双进程+自修改+背包加密）</h2><p><a href="https://www.nssctf.cn/problem/40">[SWPU 2019]EasiestRe | NSSCTF</a></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h4><p>进来先看到IsDebuggerPresent，运行一下发现和直接打开的结果不一样，双进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( IsDebuggerPresent() )  <span class="comment">//调试器进程</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">if</span> ( CreateProcessA(Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )  <span class="comment">//正常进程</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  PVOID lpBaseAddress; <span class="comment">// [esp+18h] [ebp-558h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+1Fh] [ebp-551h]</span></span><br><span class="line">  DWORD dwContinueStatus; <span class="comment">// [esp+20h] [ebp-550h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> <span class="title">DebugEvent</span>;</span> <span class="comment">// [esp+28h] [ebp-548h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// [esp+8Fh] [ebp-4E1h]</span></span><br><span class="line">  CONTEXT Context; <span class="comment">// [esp+94h] [ebp-4DCh] BYREF</span></span><br><span class="line">  HANDLE hThread; <span class="comment">// [esp+364h] [ebp-20Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+368h] [ebp-208h]</span></span><br><span class="line">  SIZE_T NumberOfBytesRead[<span class="number">3</span>]; <span class="comment">// [esp+370h] [ebp-200h] BYREF</span></span><br><span class="line">  SIZE_T NumberOfBytesWritten[<span class="number">3</span>]; <span class="comment">// [esp+37Ch] [ebp-1F4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> Buffer[<span class="number">60</span>]; <span class="comment">// [esp+388h] [ebp-1E8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v15[<span class="number">40</span>]; <span class="comment">// [esp+3C4h] [ebp-1ACh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16[<span class="number">16</span>]; <span class="comment">// [esp+3ECh] [ebp-184h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> <span class="title">StartupInfo</span>;</span> <span class="comment">// [esp+3FCh] [ebp-174h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> <span class="title">ProcessInformation</span>;</span> <span class="comment">// [esp+448h] [ebp-128h] BYREF</span></span><br><span class="line">  CHAR Filename[<span class="number">267</span>]; <span class="comment">// [esp+460h] [ebp-110h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;ProcessInformation, <span class="number">0</span>, <span class="keyword">sizeof</span>(ProcessInformation));</span><br><span class="line">  j__memset(&amp;StartupInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(StartupInfo));</span><br><span class="line">  v16[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v16[<span class="number">1</span>] = <span class="number">0x83</span>;</span><br><span class="line">  v16[<span class="number">2</span>] = <span class="number">0x7D</span>;</span><br><span class="line">  v16[<span class="number">3</span>] = <span class="number">0xF8</span>;</span><br><span class="line">  v16[<span class="number">4</span>] = <span class="number">0x18</span>;</span><br><span class="line">  v16[<span class="number">5</span>] = <span class="number">0x7D</span>;</span><br><span class="line">  v16[<span class="number">6</span>] = <span class="number">0x11</span>;</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v15[<span class="number">1</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">2</span>] = <span class="number">0xB6</span>;</span><br><span class="line">  v15[<span class="number">3</span>] = <span class="number">0x55</span>;</span><br><span class="line">  v15[<span class="number">4</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">5</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">6</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">  v15[<span class="number">8</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">9</span>] = <span class="number">4</span>;</span><br><span class="line">  v15[<span class="number">10</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v15[<span class="number">11</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">12</span>] = <span class="number">0xAF</span>;</span><br><span class="line">  v15[<span class="number">13</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">14</span>] = <span class="number">0xFC</span>;</span><br><span class="line">  v15[<span class="number">15</span>] = <span class="number">0x33</span>;</span><br><span class="line">  v15[<span class="number">16</span>] = <span class="number">0xD2</span>;</span><br><span class="line">  v15[<span class="number">17</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">18</span>] = <span class="number">0x75</span>;</span><br><span class="line">  v15[<span class="number">19</span>] = <span class="number">0xF8</span>;</span><br><span class="line">  v15[<span class="number">20</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">21</span>] = <span class="number">0xB6</span>;</span><br><span class="line">  v15[<span class="number">22</span>] = <span class="number">0x4D</span>;</span><br><span class="line">  v15[<span class="number">23</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">24</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">25</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">26</span>] = <span class="number">0xC</span>;</span><br><span class="line">  v15[<span class="number">27</span>] = <span class="number">0x89</span>;</span><br><span class="line">  v15[<span class="number">28</span>] = <span class="number">0x14</span>;</span><br><span class="line">  v15[<span class="number">29</span>] = <span class="number">0x88</span>;</span><br><span class="line">  j__memset(Buffer, <span class="number">0</span>, <span class="number">0x32u</span>);</span><br><span class="line">  NumberOfBytesWritten[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( IsDebuggerPresent() )                    <span class="comment">// 调试器进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetStartupInfoA(&amp;StartupInfo);</span><br><span class="line">    GetModuleFileNameA(<span class="number">0</span>, Filename, <span class="number">0x104u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( CreateProcessA(Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )<span class="comment">// 创建新进程</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="number">1</span>;</span><br><span class="line">LABEL_6:</span><br><span class="line">      <span class="keyword">while</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">        WaitForDebugEvent(&amp;DebugEvent, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        <span class="keyword">switch</span> ( DebugEvent.dwDebugEventCode )  <span class="comment">// 处理调试事件</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">            <span class="keyword">if</span> ( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode == <span class="number">0x80000003</span> )<span class="comment">// 遇到调试断点</span></span><br><span class="line">            &#123;</span><br><span class="line">              v8 = <span class="number">1</span>;                           <span class="comment">// 继续执行程序，跳过当前异常</span></span><br><span class="line">              dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">              lpBaseAddress = DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress;<span class="comment">// 保存异常的地址（即断点地址）</span></span><br><span class="line">              ReadProcessMemory(                <span class="comment">// 读取 35 字节的内存数据到buffer里</span></span><br><span class="line">                ProcessInformation.hProcess,</span><br><span class="line">                DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,</span><br><span class="line">                Buffer,</span><br><span class="line">                <span class="number">0x23u</span>,</span><br><span class="line">                NumberOfBytesRead);</span><br><span class="line">              <span class="keyword">if</span> ( NumberOfBytesRead[<span class="number">0</span>] )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">35</span> &amp;&amp; Buffer[i] == <span class="number">0x90</span>; ++i )<span class="comment">// 检查nop</span></span><br><span class="line">                  ;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> ( i == <span class="number">1</span> )</span><br><span class="line">                v8 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v8 )                         <span class="comment">// v8非0则继续执行，v8为0则跳转到dwContinueStatus = 0x80010001;</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( i )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    Context.ContextFlags = <span class="number">65543</span>;</span><br><span class="line">                    hThread = OpenThread(<span class="number">0x1FFFFFu</span>, <span class="number">0</span>, DebugEvent.dwThreadId);</span><br><span class="line">                    <span class="keyword">if</span> ( !GetThreadContext(hThread, &amp;Context) )</span><br><span class="line">                      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">                    ++Context.Eip;</span><br><span class="line">                    <span class="keyword">if</span> ( SetThreadContext(hThread, &amp;Context) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">                      CloseHandle(hThread);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">LABEL_31:</span><br><span class="line">                    ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x80010001</span>);</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">7</span>:                       <span class="comment">// 将v16的数据写入lpBaseAddress</span></span><br><span class="line">                                                <span class="comment">// 然后读取lpBaseAddress 处的数据并存储在 Buffer 中</span></span><br><span class="line">                                                <span class="comment">// 成功写入 7 字节数据则继续执行程序</span></span><br><span class="line">                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="number">7u</span>, NumberOfBytesWritten);</span><br><span class="line">                    <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">7</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="number">7u</span>, NumberOfBytesRead);</span><br><span class="line">                      dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">30</span>:                      <span class="comment">// v15 中的 30 字节数据写入lpBaseAddress</span></span><br><span class="line">                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v15, <span class="number">0x1Eu</span>, NumberOfBytesWritten);</span><br><span class="line">                    <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">30</span> )</span><br><span class="line">                      dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">default</span>:                      <span class="comment">// i！=4，5，7，30</span></span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              dwContinueStatus = <span class="number">0x80010001</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">            v5 = <span class="number">0</span>;</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">LABEL_33:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinueStatus);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_F53922();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sub-F58A40"><a href="#sub-F58A40" class="headerlink" title="sub_F58A40"></a>sub_F58A40</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text:00F58AF8                 int     3               ; Trap to Debugger</span><br><span class="line">text:00F58AF9                 nop</span><br><span class="line">text:00F58AFA                 nop</span><br><span class="line">text:00F58AFB                 nop</span><br><span class="line">text:00F58AFC                 nop</span><br><span class="line">text:00F58AFD                 nop</span><br><span class="line">text:00F58AFE                 nop</span><br><span class="line">text:00F58AFF                 push    offset aYouAreTooShort ; &quot;you are too short!&quot;</span><br><span class="line">text:00F58B04                 call    printf</span><br></pre></td></tr></table></figure><p>根据上面的分析，遇到int 3会写入v16 7字节的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:                      </span><br><span class="line">                   WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="number">7u</span>, NumberOfBytesWritten);</span><br><span class="line">                   <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">7</span> )</span><br><span class="line">                   &#123;</span><br><span class="line">                     ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="number">7u</span>, NumberOfBytesRead);</span><br><span class="line">                     dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">goto</span> LABEL_33;</span><br></pre></td></tr></table></figure><p>paste data就行</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501051651130.png" alt="image"></p><h4 id="sub-F587E0"><a href="#sub-F587E0" class="headerlink" title="sub_F587E0"></a>sub_F587E0</h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501080247609.png" alt="1736275603403.png"></p><p>30字节的有点长，idapython吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取的字节位置范围：从 0xF58C45 到 0xF58D10</span></span><br><span class="line">start_addr = <span class="number">0x00F58C45</span>  <span class="comment"># 起始地址</span></span><br><span class="line">end_addr = <span class="number">0x00F58D10</span>    <span class="comment"># 结束地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储字节的列表</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历指定地址范围</span></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(start_addr, end_addr + <span class="number">1</span>):  <span class="comment"># 按字节逐个读取</span></span><br><span class="line">    byte = idaapi.get_byte(addr)  <span class="comment"># 获取当前地址的字节</span></span><br><span class="line">    <span class="keyword">if</span> byte != -<span class="number">1</span>:  <span class="comment"># 确保字节有效</span></span><br><span class="line">        data.append(byte)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只提取存储到内存中的字节（每条 mov 指令的最后一个字节）</span></span><br><span class="line">stored_values = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data) - <span class="number">6</span>, <span class="number">7</span>):  <span class="comment"># 每条指令为 7 字节，确保有足够字节</span></span><br><span class="line">    stored_values.append(data[i + <span class="number">6</span>])  <span class="comment"># 存储每条 mov 指令的最后一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印提取的存储字节值作为数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stored values in array:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[&quot;</span> + <span class="string">&quot;, &quot;</span>.join(<span class="string">&quot;0x&#123;:02X&#125;&quot;</span>.<span class="built_in">format</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> stored_values) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[0x90, 0x0F, 0xB6, 0x55, 0xF7, 0x8B, 0x45, 0x08, 0x8B, 0x04, 0x90, 0x0F, 0xAF, 0x45, 0xFC, 0x33, 0xD2, 0xF7, 0x75, 0xF8, 0x0F, 0xB6, 0x4D, 0xF7, 0x8B, 0x45, 0x0C, 0x89, 0x14，0x88]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span>*</span><br><span class="line">data=[<span class="number">0x90</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x55</span>, <span class="number">0xF7</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x08</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x90</span>, <span class="number">0x0F</span>, <span class="number">0xAF</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x33</span>, <span class="number">0xD2</span>, <span class="number">0xF7</span>, <span class="number">0x75</span>, <span class="number">0xF8</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x4D</span>, <span class="number">0xF7</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x0C</span>, <span class="number">0x89</span>, <span class="number">0x14</span>,<span class="number">0x88</span>]</span><br><span class="line">b=<span class="number">0x0F58824</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    ida_bytes.patch_byte(b+i,data[i])</span><br></pre></td></tr></table></figure><p>修完</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __cdecl <span class="title function_">sub_F587E0</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 i; <span class="comment">// [esp+3h] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8u</span>; ++i )</span><br><span class="line">    *(a2 + <span class="number">4</span> * i) = <span class="number">41</span> * *(a1 + <span class="number">4</span> * i) % <span class="number">0x1EBu</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要个in3+3个nop，根据主函数分析不管它</p><h4 id="sub-F583C0"><a href="#sub-F583C0" class="headerlink" title="sub_F583C0"></a>sub_F583C0</h4><p>in3+4个nop，对应case4，main里的处理是eip+1跳过异常</p><p><del>在int3那里下个断点，动调一下看看程序咋处理这里的</del></p><p>忘了双线程了，apply patch to programm，然后运行一下exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:0069842B                               ;   __try &#123; // __except at loc_69845A</span><br><span class="line">.text:0069842B C7 45 FC 00 00 00 00          mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00698432 CC                            int     3                               ; Trap to Debugger</span><br><span class="line">.text:00698433 90                            nop</span><br><span class="line">.text:00698434 90                            nop</span><br><span class="line">.text:00698435 90                            nop</span><br><span class="line">.text:00698436 90                            nop</span><br><span class="line">....</span><br><span class="line">.text:0069845A                               loc_69845A:                             ; DATA XREF: .rdata:stru_7783E8↓o</span><br><span class="line">.text:0069845A                               ;   __except(loc_698454) // owned by 69842B</span><br><span class="line">.text:0069845A 8B 65 E8                      mov     esp, [ebp+ms_exc.old_esp]</span><br></pre></td></tr></table></figure><p>这里直接跳到了loc_69845A，有点像密文密钥之类的，同样的我们keypatch in3 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 3 -&gt; jmp loc_69845A</span><br></pre></td></tr></table></figure><p>然后就是解密了，背包加密网上随便找个脚本改改</p><p>swpuctf{y0u_@re_s0_coo1}</p><h2 id="zer0pts-2020-vmlog（vm）"><a href="#zer0pts-2020-vmlog（vm）" class="headerlink" title="[zer0pts 2020]vmlog（vm）"></a>[zer0pts 2020]vmlog（vm）</h2><p><a href="https://www.nssctf.cn/problem/61">[zer0pts 2020]vmlog | NSSCTF</a></p><p>拿到vm.py和log.txt，vm.py实现了一个自定义的指令集，行为取决于program变量和输入。做vm题的常规思路就是把汇编打印出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> program <span class="keyword">import</span> program</span><br><span class="line"></span><br><span class="line">reg = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">pc = <span class="number">0</span></span><br><span class="line">buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(program)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> pc &lt; <span class="built_in">len</span>(program):</span><br><span class="line">    op = program[pc]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        reg += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> add reg 1 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        reg -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> sub reg 1 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        reg *= mem[p]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mul reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;%&quot;</span>:</span><br><span class="line">        reg = mem[p] % reg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mod reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        reg = mem[p]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>,p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;s&quot;</span>:</span><br><span class="line">        mem[p] = reg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov mem[<span class="subst">&#123;p&#125;</span>] reg #mem=<span class="subst">&#123;mem&#125;</span>,p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        p = (p + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> inc p 1 #p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        p = (p - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> dec p 1 #p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">        a = sys.stdin.buffer.read(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> getchar&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">            reg = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov, reg 0 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            reg += <span class="built_in">ord</span>(a)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov, reg <span class="subst">&#123;<span class="built_in">ord</span>(a)&#125;</span> #input #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;p&quot;</span>:</span><br><span class="line">        buf += <span class="built_in">str</span>(reg)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> buf+=str(reg)&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> cmp reg 0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg == <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">                pc += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> jz &quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> cmp reg 0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg != <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">                pc -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> jnz &quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;M&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(mem)</span><br><span class="line"></span><br><span class="line">    pc += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="comment">#print(f&quot;PC: &#123;pc&#125;, OP: &#123;op&#125;, REG: &#123;reg&#125;, MEM: &#123;mem&#125;, P: &#123;p&#125;, BUF: &#x27;&#123;buf&#125;&#x27;&quot;)</span></span><br></pre></td></tr></table></figure><p>给的log.txt是program+运行日志</p><p>自己再定义一个program.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program = <span class="string">&quot;M+s+&gt;s&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[s&lt;&lt;l&gt;*&lt;s&gt;&gt;l-]&lt;&lt;l-s&gt;l*-s*-s*-s*-s*-s*-s&gt;l*+++++s*-----s****s&gt;&gt;l+s[Ml-s&lt;&lt;l&gt;,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s&gt;&gt;l&lt;s&gt;l+s&lt;l]&gt;l]&lt;&lt;lp&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M+s+&gt;s&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[s&lt;&lt;l&gt;*&lt;s&gt;&gt;l-]&lt;&lt;l-s</span><br><span class="line">&gt;l*-s*-s*-s*-s*-s*-s</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>M</code></strong>：打印初始内存状态，便于调试。</p></li><li><p><code>s</code> 和 <code>l</code></p><p>：将值存储到内存或加载到寄存器。</p><ul><li><code>mem[0]</code> 被设置为一个大值（262−12^{62} - 1262−1），通常用于模运算。</li><li><code>mem[1]</code> 被设置为 2（基数 <code>r</code>）。</li><li><code>mem[2]</code> 被设置为 1（初始哈希值 <code>h</code>）。</li></ul></li><li><p>推断</p><ul><li>这种初始化方式非常典型，常见于滚动哈希算法的实现。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s</span><br></pre></td></tr></table></figure><ul><li><strong><code>[ ,</code></strong>：开始读取输入字符。</li><li><strong><code>&lt;&lt;\*</code></strong>：当前哈希值 <code>h</code> 加上输入字符后，乘以基数 <code>r</code>。</li><li><strong><code>%</code></strong>：对模数 <code>m</code> 取模，防止哈希值溢出。</li><li>推断<ul><li>这是滚动哈希算法的核心公式： h=(h+input)⋅rmod  mh = (h + \text{input}) \cdot r \mod mh=(h+input)⋅rmodm</li></ul></li></ul><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ml-s&lt;&lt;l&gt;,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s&gt;&gt;l&lt;s&gt;l+s&lt;l]&gt;l]&lt;&lt;lp</span><br></pre></td></tr></table></figure><ul><li>循环核心<ul><li><code>[Ml-s&lt;&lt;l&gt;</code>：开始新一轮的哈希值更新，标志位控制。</li><li><code>,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s</code>：对每个输入字符进行滚动哈希更新。</li><li><code>&gt;l+s&lt;l]</code>：设置标志位，继续下一轮输入处理。</li></ul></li><li>推断<ul><li>滚动哈希的本质是对输入字符的逐个处理，结合乘法、加法和模运算。</li></ul></li></ul><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;lp</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>输出最终的哈希值 <code>h</code>（存储在 <code>mem[2]</code>）。</li></ul></li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\LeStoreDownload\webpage\CTF\nssctf\[zer0pts 2020]vmlog\tmp\log.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    prev_h = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            arr = <span class="built_in">eval</span>(l.strip())</span><br><span class="line">            <span class="keyword">if</span> arr[<span class="number">4</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> prev_h:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                        <span class="keyword">if</span> (prev_h + i) * arr[<span class="number">1</span>] % arr[<span class="number">0</span>] == arr[<span class="number">2</span>]:</span><br><span class="line">                            flag += <span class="built_in">chr</span>(i)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                prev_h = arr[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#zer0pts&#123;3asy_t0_f0110w_th3_l0g?&#125;</span></span><br></pre></td></tr></table></figure><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDApython学习</title>
      <link href="/2024/12/30/%E5%88%9D%E8%AF%86IDApython/"/>
      <url>/2024/12/30/%E5%88%9D%E8%AF%86IDApython/</url>
      
        <content type="html"><![CDATA[<h1 id="IDApython-amp-IDC"><a href="#IDApython-amp-IDC" class="headerlink" title="IDApython&amp;IDC"></a><strong>IDApython&amp;IDC</strong></h1><p>IDApython 官方文档：<a href="https://docs.hex-rays.com/developer-guide/idapython">IDAPython | Hex-Rays Docs</a></p><p>IDC 官方文档：<a href="https://docs.hex-rays.com/developer-guide/idc">IDC | Hex-Rays Docs</a></p><h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a><strong>常用模块</strong></h1><h2 id="1-IDC"><a href="#1-IDC" class="headerlink" title="1.IDC"></a><strong>1.IDC</strong></h2><p>与 IDA 命令行进行交互的模块，提供了很多 IDA 中指令相关的函数。</p><ul><li><strong><code>idc.get_name(ea)</code></strong>：获取地址 <code>ea</code> 处的名称。</li><li><strong><code>idc.get_func_name(ea)</code></strong>：获取函数地址处的函数名称。</li><li><strong><code>idc.set_name(ea, name)</code></strong>：为地址 <code>ea</code> 设置一个新的名称。</li><li><strong><code>idc.add_entry(ea, name, start, end)</code></strong>：在 <code>ea</code> 处添加一个入口点。</li><li><strong><code>idc.get_func(ea)</code></strong>：获取 <code>ea</code> 处的函数结构。</li></ul><h2 id="2-IDAAPI"><a href="#2-IDAAPI" class="headerlink" title="2.IDAAPI"></a><strong>2.IDAAPI</strong></h2><p>与 IDA 的核心 API 交互的主要模块。包括了对 IDA 核心对象的访问，涵盖了地址、函数、节等许多底层操作。</p><ul><li><strong><code>idaapi.get_func(ea)</code></strong>：返回地址 <code>ea</code> 处的函数对象。</li><li><strong><code>idaapi.get_flags(ea)</code></strong>：返回地址 <code>ea</code> 的标志，表示它是代码、数据还是其他类型。</li><li><strong><code>idaapi.create_data(ea, size, type)</code></strong>：在地址 <code>ea</code> 处创建数据。</li><li><strong><code>idaapi.get_strlit_contents(ea)</code></strong>：获取 <code>ea</code> 处的字符串内容。</li><li><strong><code>idaapi.add_func(ea)</code></strong>：将地址 <code>ea</code> 添加为一个函数。</li></ul><h2 id="3-IDAUTILS"><a href="#3-IDAUTILS" class="headerlink" title="3.IDAUTILS"></a><strong>3.IDAUTILS</strong></h2><p>工具函数，帮助在反汇编中自动化和简化分析过程。</p><ul><li><strong><code>idautils.Functions(start, end)</code></strong>：遍历在 <code>start</code> 到 <code>end</code> 地址范围内的所有函数。</li><li><strong><code>idautils.DecodeInstruction(ea)</code></strong>：解码地址 <code>ea</code> 处的指令。</li><li><strong><code>idautils.FindBinary(start, end, pattern, flags)</code></strong>：在指定范围内查找与模式匹配的二进制数据。</li><li><strong><code>idautils.Heads(start, end)</code></strong>：遍历地址范围内的所有指令地址。</li></ul><h2 id="4-ida-bytes"><a href="#4-ida-bytes" class="headerlink" title="4.ida_bytes"></a><strong>4.ida_bytes</strong></h2><p><code>ida_bytes</code> 提供了对内存区域字节级别操作的函数。</p><ul><li><strong><code>ida_bytes.get_byte(ea)</code></strong>：获取 <code>ea</code> 处的一个字节</li><li><strong><code>ida_bytes.get_word(ea)</code></strong>：获取 <code>ea</code> 处的一个字.</li><li><strong><code>ida_bytes.get_dword(ea)</code></strong>：获取 <code>ea</code> 处的一个双字。</li></ul><h2 id="5-ida-struct"><a href="#5-ida-struct" class="headerlink" title="5.ida_struct"></a><strong>5.ida_struct</strong></h2><p><code>ida_struct</code> 处理 IDA 中的结构体。你可以使用它来读取、创建、修改和设置结构体。</p><ul><li><strong><code>ida_struct.get_struc_name(struc)</code></strong>：获取结构体的名称。</li><li><strong><code>ida_struct.add_struc()</code></strong>：添加一个新的结构体。</li><li><strong><code>ida_struct.set_struc_member()</code></strong>：设置结构体成员的属性。</li></ul><h2 id="6-ida-diskio"><a href="#6-ida-diskio" class="headerlink" title="6.ida_diskio"></a><strong>6.ida_diskio</strong></h2><p><code>ida_diskio</code> 提供了与磁盘 IO 操作相关的函数，例如读取或写入文件。</p><ul><li><strong><code>ida_diskio.get_input_file_path()</code></strong>：获取当前输入文件的路径。</li><li><strong><code>ida_diskio.save_input_file()</code></strong>：保存当前输入文件。</li></ul><h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a><strong>常用技巧</strong></h1><h2 id="获取基本块-ida-get-bb"><a href="#获取基本块-ida-get-bb" class="headerlink" title="获取基本块 ida_get_bb"></a><strong>获取基本块 ida_get_bb</strong></h2><p><code>ida_get_bb</code> 函数的功能是获取指定地址 <code>ea</code> 所在的基本块（Basic Block）。基本块是指在程序中连续的一组指令序列，这些指令在程序的控制流图上不会被中断，只有从头到尾的顺序执行，并且只有在块的结束处才能跳出这个块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ida_get_bb</span>(<span class="params">ea</span>):</span><br><span class="line">    f_blocks = idaapi.FlowChart(idaapi.get_func(ea), flags=idaapi.FC_PREDS)</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> f_blocks:</span><br><span class="line">        <span class="keyword">if</span> block.start_ea &lt;= ea <span class="keyword">and</span> ea &lt; block.end_ea:</span><br><span class="line">            <span class="keyword">return</span> block</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="函数功能概述"><a href="#函数功能概述" class="headerlink" title="函数功能概述"></a><strong>函数功能概述</strong></h3><ul><li><strong>输入</strong>：虚拟地址 (<code>ea</code>)，即目标指令的地址。</li><li><strong>输出</strong>：包含该地址的基本块 (<code>block</code>) 或者 <code>None</code>（如果未找到）。</li></ul><h3 id="函数逻辑"><a href="#函数逻辑" class="headerlink" title="函数逻辑"></a><strong>函数逻辑</strong></h3><ol><li>利用 IDA Pro 的 <code>idaapi.FlowChart</code> 类生成当前函数的控制流图（Flow Chart），即函数内的所有基本块。</li><li>遍历每个基本块，检查该基本块的起始地址 (<code>start_ea</code>) 和结束地址 (<code>end_ea</code>)，判断目标地址 (<code>ea</code>) 是否在该基本块范围内。</li><li>如果找到符合条件的基本块，则返回该基本块对象。</li><li>如果遍历完所有基本块都没有找到符合条件的，返回 <code>None</code>。</li></ol><h2 id="创建-删除函数"><a href="#创建-删除函数" class="headerlink" title="创建 / 删除函数"></a><strong>创建 / 删除函数</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idc.add_func(<span class="number">0x401000</span>, <span class="number">0x401050</span>)  <span class="comment"># Create a function starting at 0x401000 and ending at 0x401050</span></span><br><span class="line">idc.del_func(<span class="number">0x401000</span>)  <span class="comment"># Delete the function at 0x401000</span></span><br></pre></td></tr></table></figure><h2 id="获取函数的名称"><a href="#获取函数的名称" class="headerlink" title="获取函数的名称"></a><strong>获取函数的名称</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_func_name(ea)</span><br></pre></td></tr></table></figure><h2 id="遍历所有函数并打印其有效地址和名称"><a href="#遍历所有函数并打印其有效地址和名称" class="headerlink" title="遍历所有函数并打印其有效地址和名称"></a><strong>遍历所有函数并打印其有效地址和名称</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions(): </span><br><span class="line">func_name = idc.get_func_name(func_ea)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(func_ea), func_name)</span><br></pre></td></tr></table></figure><h2 id="列出地址的交叉引用："><a href="#列出地址的交叉引用：" class="headerlink" title="列出地址的交叉引用："></a><strong>列出地址的交叉引用：</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsFrom(<span class="number">0x401000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Xref from 0x401000 to <span class="subst">&#123;<span class="built_in">hex</span>(xref.to)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="遍历所有交叉引用并打印"><a href="#遍历所有交叉引用并打印" class="headerlink" title="遍历所有交叉引用并打印"></a><strong>遍历所有交叉引用并打印</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ref in idautils.XrefsTo(ea):</span><br><span class="line">  print(hex(ref.frm))</span><br></pre></td></tr></table></figure><h2 id="获取段地址"><a href="#获取段地址" class="headerlink" title="获取段地址"></a>获取段地址</h2><p><code>idautils.Segments()</code> 返回 <strong>所有段的起始地址</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    seg_name = idc.get_segm_name(seg)</span><br><span class="line">    <span class="keyword">if</span> seg_name != <span class="string">&quot;.text&quot;</span> <span class="keyword">and</span> seg_name != <span class="string">&quot;UPX0&quot;</span>:</span><br><span class="line">        <span class="comment"># print(f&quot;跳过段: &#123;seg_name&#125; (0x&#123;seg:X&#125;)&quot;)</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在处理段: <span class="subst">&#123;seg_name&#125;</span> (0x<span class="subst">&#123;seg:X&#125;</span>)&quot;</span>)</span><br><span class="line">    start_ea = seg</span><br><span class="line">    end_ea = idc.get_segm_end(seg) <span class="comment">#返回段的结束地址。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文本-指令搜索"><a href="#文本-指令搜索" class="headerlink" title="文本 / 指令搜索"></a><strong>文本 / 指令搜索</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索整个内存区域的字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_string</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> idautils.Strings():</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> ea:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found string at <span class="subst">&#123;<span class="built_in">hex</span>(ea)&#125;</span>: <span class="subst">&#123;ea&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 &quot;Hello&quot; 字符串</span></span><br><span class="line">search_string(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#搜索汇编指令</span></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_asm_instruction</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="comment"># 遍历整个程序的所有指令</span></span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> idautils.Heads(idc.get_segm_by_name(<span class="string">&quot;.text&quot;</span>), idc.get_segm_end(idc.get_segm_by_name(<span class="string">&quot;.text&quot;</span>))):</span><br><span class="line">        disasm = idc.GetDisasm(ea)  <span class="comment"># 获取地址处的反汇编指令</span></span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> disasm:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found instruction at <span class="subst">&#123;<span class="built_in">hex</span>(ea)&#125;</span>: <span class="subst">&#123;disasm&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 &quot;mov eax, ebx&quot; 指令</span></span><br><span class="line">search_asm_instruction(<span class="string">&quot;mov eax, ebx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="循环左移-右移"><a href="#循环左移-右移" class="headerlink" title="循环左移 / 右移"></a><strong>循环左移 / 右移</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ROR</span>(<span class="params">i,index</span>):<span class="comment">#循环又移</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].rjust(<span class="number">8</span>,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        tmp = tmp[-<span class="number">1</span>] + tmp[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ROL</span>(<span class="params">i,index</span>):<span class="comment">#循环左移</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        tmp = tmp[<span class="number">1</span>:] + tmp[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实例</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def ROR(i,index):</span><br><span class="line">    tmp = bin(i)[2:].rjust(8,&quot;0&quot;)</span><br><span class="line">    for _ in range(index):</span><br><span class="line">        tmp = tmp[-1] + tmp[:-1]</span><br><span class="line">    return int(tmp, 2)</span><br><span class="line">    </span><br><span class="line">addr1=0x140001085</span><br><span class="line">addr2=0x140001d00</span><br><span class="line">for i in range(addr2-addr1):</span><br><span class="line">    PatchByte(addr1+i,ROR(Byte(addr1+i),3)^90)</span><br><span class="line">print(&#x27;successful&#x27;)</span><br></pre></td></tr></table></figure><h2 id="列出-segment-函数（以及它们的交叉引用）"><a href="#列出-segment-函数（以及它们的交叉引用）" class="headerlink" title="列出 segment 函数（以及它们的交叉引用）"></a><strong>列出 segment 函数（以及它们的交叉引用）</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_xref</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ida_auto.auto_wait()  <span class="comment"># 确保 IDA 完成自动分析</span></span><br><span class="line">    ea = ida_kernwin.get_screen_ea()</span><br><span class="line">    seg = ida_segment.getseg(ea)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> seg:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No segment found at 0x%x&quot;</span> % ea)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    func = ida_funcs.get_func(seg.start_ea)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">        func = ida_funcs.get_next_func(seg.start_ea)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> func <span class="keyword">and</span> func.start_ea &lt; seg.end_ea:</span><br><span class="line">        funcea = func.start_ea</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Function %s at 0x%x&quot;</span> % (ida_funcs.get_func_name(funcea), funcea))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查找对 funcea 的交叉引用</span></span><br><span class="line">        xb = ida_xref.xrefblk_t()</span><br><span class="line">        <span class="keyword">if</span> xb.first_to(funcea, ida_xref.XREF_ALL):</span><br><span class="line">            <span class="keyword">while</span> xb.iscode:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  called from %s(0x%x)&quot;</span> % (ida_funcs.get_func_name(xb.frm), xb.frm))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> xb.next_to():</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        func = ida_funcs.get_next_func(funcea)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="列出-segment-中的所有函数-（和交叉引用）"><a href="#列出-segment-中的所有函数-（和交叉引用）" class="headerlink" title="列出 segment 中的所有函数 （和交叉引用）"></a><strong>列出 segment 中的所有函数 （和交叉引用）</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_idaapi</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Get current ea</span></span><br><span class="line">    ea = ida_kernwin.get_screen_ea()</span><br><span class="line">    <span class="keyword">if</span> ea == ida_idaapi.BADADDR:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Could not get get_screen_ea()&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    seg = ida_segment.getseg(ea)</span><br><span class="line">    <span class="keyword">if</span> seg:</span><br><span class="line">        <span class="comment"># Loop from start to end in the current segment</span></span><br><span class="line">        <span class="keyword">for</span> funcea <span class="keyword">in</span> idautils.Functions(seg.start_ea, seg.end_ea):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Function %s at 0x%x&quot;</span> % (ida_funcs.get_func_name(funcea), funcea))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Find all code references to funcea</span></span><br><span class="line">            <span class="keyword">for</span> ref <span class="keyword">in</span> idautils.CodeRefsTo(funcea, <span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  called from %s(0x%x)&quot;</span> % (ida_funcs.get_func_name(ref), ref))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please position the cursor within a segment&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="获取并打印当前光标所在函数（或代码块）的详细信息"><a href="#获取并打印当前光标所在函数（或代码块）的详细信息" class="headerlink" title="获取并打印当前光标所在函数（或代码块）的详细信息"></a>获取并打印当前光标所在函数（或代码块）的详细信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_flags</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的标志信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数标志: %08X&quot;</span> % fn.flags)</span><br><span class="line">    <span class="keyword">if</span> fn.is_far():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  远函数&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fn.does_return():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数不会返回&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_FRAME:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数使用帧指针&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_THUNK:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数是 Thunk 函数&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_LUMINA:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数信息由 Lumina 提供&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_OUTLINE:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数是伪代码函数（非真实函数）&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_regvars</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数中的重命名寄存器信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(pfn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个重命名寄存器&quot;</span> % pfn.regvarqty)</span><br><span class="line">    <span class="keyword">for</span> rv <span class="keyword">in</span> pfn.regvars:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%08X..%08X &#x27;%s&#x27;-&gt;&#x27;%s&#x27;&quot;</span> % (rv.start_ea, rv.end_ea, rv.canon, rv.user))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_regargs</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印寄存器传递的参数信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(pfn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个寄存器参数&quot;</span> % pfn.regargqty)</span><br><span class="line">    <span class="keyword">for</span> ra <span class="keyword">in</span> pfn.regargs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  寄存器编号=%d, 参数名称=\&quot;%s\&quot;, (序列化类型)=\&quot;%s\&quot;&quot;</span> % (</span><br><span class="line">            ra.reg,</span><br><span class="line">            ra.name,</span><br><span class="line">            binascii.hexlify(ra.<span class="built_in">type</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_tails</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的尾块信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(pfn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个尾块&quot;</span> % pfn.tailqty)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pfn.tailqty):</span><br><span class="line">        ft = pfn.tails[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  尾块 %i: %08X..%08X&quot;</span> % (i, ft.start_ea, ft.end_ea))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_stkpnts</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的栈调整点信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个栈调整点&quot;</span> % pfn.pntqty)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pfn.pntqty):</span><br><span class="line">        pnt = pfn.points[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  栈调整点 %i @%08X: %d&quot;</span> % (i, pnt.ea, pnt.spd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_frame</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的栈帧信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(fn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;帧结构 ID: %08X&quot;</span> % fn.frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;局部变量区大小: %8X&quot;</span> % fn.frsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;保存寄存器区大小: %8X&quot;</span> % fn.frregs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;返回时清理的字节数: %8X&quot;</span> % fn.argsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;帧指针偏移量: %8X&quot;</span> % fn.fpd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_parents</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数尾块的所有者和引用信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_tail(fn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所属函数: %08X&quot;</span> % fn.owner)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该尾块被 %d 个函数引用&quot;</span> % fn.refqty)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fn.refqty):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  引用者 %i: %08X&quot;</span> % (i, fn.referers[i]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_func_info</span>(<span class="params">ea</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印指定地址所在的函数信息&quot;&quot;&quot;</span></span><br><span class="line">    pfn = ida_funcs.get_fchunk(ea)</span><br><span class="line">    <span class="keyword">if</span> pfn <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;该地址 %08X 处没有函数！&quot;</span> % ea)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前代码块范围: %08X..%08X&quot;</span> % (pfn.start_ea, pfn.end_ea))</span><br><span class="line">    dump_flags(pfn)</span><br><span class="line">    <span class="keyword">if</span> ida_funcs.is_func_entry(pfn):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是一个入口代码块&quot;</span>)</span><br><span class="line">        dump_tails(pfn)</span><br><span class="line">        dump_frame(pfn)</span><br><span class="line">        dump_regvars(pfn)</span><br><span class="line">        dump_regargs(pfn)</span><br><span class="line">        dump_stkpnts(pfn)</span><br><span class="line">    <span class="keyword">elif</span> ida_funcs.is_func_tail(pfn):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是一个尾代码块&quot;</span>)</span><br><span class="line">        dump_parents(pfn)</span><br><span class="line"></span><br><span class="line">ea = ida_kernwin.get_screen_ea()</span><br><span class="line">dump_func_info(ea)</span><br></pre></td></tr></table></figure><h2 id="向现有函数帧添加新成员"><a href="#向现有函数帧添加新成员" class="headerlink" title="向现有函数帧添加新成员"></a><strong>向现有函数帧添加新成员</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_frame</span><br><span class="line"><span class="keyword">import</span> ida_typeinf</span><br><span class="line"><span class="keyword">import</span> ida_range</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_frame_member</span>(<span class="params">func_ea</span>):</span><br><span class="line">    name = <span class="string">&quot;my_stkvar&quot;</span></span><br><span class="line"></span><br><span class="line">    tif = ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT64) </span><br><span class="line">    <span class="comment">#创建了一个 64 位整数 (uint64_t) 的 tinfo_t 类型对象。</span></span><br><span class="line">    tif.create_ptr(tif)</span><br><span class="line">    <span class="comment"># 将其转换为指针类型，即 uint64_t*。</span></span><br><span class="line">    </span><br><span class="line">    func = ida_funcs.get_func(func_ea)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Failed to get function!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Function @ <span class="subst">&#123;func.start_ea:x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    frame_tif = ida_typeinf.tinfo_t()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ida_frame.get_func_frame(frame_tif, func):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Failed to get frame!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;frame_tif._<span class="built_in">print</span>()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    rs = ida_range.rangeset_t()</span><br><span class="line">    sp_offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> frame_tif.calc_gaps(rs):</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">range</span> <span class="keyword">in</span> rs:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">range</span>.start_ea &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> (<span class="built_in">range</span>.end_ea - <span class="built_in">range</span>.start_ea) &gt;= tif.get_size():</span><br><span class="line">                sp_offset = <span class="built_in">range</span>.start_ea</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Range [<span class="subst">&#123;<span class="built_in">range</span>.start_ea:x&#125;</span>, <span class="subst">&#123;<span class="built_in">range</span>.end_ea:x&#125;</span>[ selected.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sp_offset &gt; <span class="number">0</span>:</span><br><span class="line">        sval = ida_frame.calc_frame_offset(func, sp_offset, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 计算在IDA 栈帧结构中的偏移量</span></span><br><span class="line">        <span class="keyword">if</span> ida_frame.add_frame_member(func, name, sval, tif):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Frame member added at frame offset <span class="subst">&#123;sval&#125;</span>!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Failed adding frame member&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Could not find gaps in current frame...&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_frame_member(idc.here())</span><br></pre></td></tr></table></figure><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><p><code>idaapi.MinEA()</code>：获取载入程序的最小的有效地址。</p><p><code>idaapi.MaxEA()</code>：获取载入的程序最大的有效地址。</p><p><code>idaapi.Assemble(head, line)</code>：从head地址开始反汇编，寻找直到遇到line这条指令时停止，返回两个变量，一个表示是否成功，另外一个是最后这条line指令的字节表示，例如：<code>ret</code>就会是<code>&#39;\xc3&#39;</code>这一个字节来表示，有些指令可能由多个字节表示。</p><p><code>idaapi.GetMnem(addr)</code>：获取addr地址处的指令。</p><p><code>idaapi.MakeCode(addr)</code>：从addr地址开始尝试将数据转换为汇编代码。</p><p><code>idaapi.next_not_tail(addr)</code>：往下走一个指令，如果不是尾部，则返回下一条指令的起始地址。</p><p><code>idaapi.GetDisasm(addr)</code>：获取addr地址开始的一条汇编指令。</p><p><code>idaapi.GetFlags(addr)</code>：获取addr地址处的一系列标志位，可用来<em>判断属于code还是data</em>。</p><p><code>idaapi.isCode(Flags)</code>：通过Flags判断是否是汇编代码。</p><p><code>idaapi.MakeUnkn(addr, size)</code>：取消对addr地址处的size大小的定义，暂不清楚该地址是代码还是数据时可以使用。</p><p><code>idaapi.GetOpnd(addr, index)</code>：取addr地址处的指令的第index个操作数，从零开始，从左开始，依次为intel汇编语法中的目的操作数、源操作数。</p><p><code>idaapi.get_name_ea(min_ea, name)</code>：从min_ea地址开始，寻找名为name的有效地址，该name可以为函数名、label名。</p><p><code>idaapi.get_dword(addr)</code>：从addr地址处获取一个dword数据。</p><p><code>idaapi.MakeDword(addr)</code>：将addr开始的一个DWORD大小的数据定义为双字形式，举一反三，Q代表四字节数据，API形式一致。</p><p><code>idaapi.Segname(addr)</code>：得到addr地址所处的区段名。</p><p><code>idaapi.MakeFunction(addr)</code>：将addr地址处定义为一个函数，相当于快捷键P。</p><p>BADADDR: 常量，代表错误的地址。</p><p><code>idaapi.GetSpd(addr)</code>：获取addr地址处的栈指针SP的值，而在IDA中显示的值则是SP到BP基址针的差值，例如获取到的值为-4，在IDA中显示栈指针的情况时则为4。</p><p><code>idaapi.SetSpDiff(addr, diff)</code>：设置addr地址处的Sp指针与Bp指针的差值，在平衡堆栈时需要用到。</p><p><code>idaapi.next_head(head, BADADDR)</code>：遍历下一条指令，除非遇到BADADDR，返回下一条指令的地址。</p><p><code>idaapi.ua_mnem(addr)</code>：返回addr地址处的指令类型。</p><p><code>idaapi.MakeName(addr, &#39;&#39;)</code>：给addr地址处一个标记label。</p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA, Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识TCP</title>
      <link href="/2024/12/27/%E5%88%9D%E8%AF%86TCP/"/>
      <url>/2024/12/27/%E5%88%9D%E8%AF%86TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="一、TCP特点"><a href="#一、TCP特点" class="headerlink" title="一、TCP特点"></a>一、TCP特点</h3><ol><li><p>面向连接的协议，在传输数据前需要建立一条可靠连接</p></li><li><p>流式协议，TCP将数据看作字节流。传输过程中数据是可以被分割为多个数据包在接收端重新组装的。</p></li><li><p>TCP通过校验和\序列号和确认应答来确保数据的可靠传输，出错回重新传输。</p></li><li><p>服务器被动连接，客户端主动连接。</p></li></ol><h3 id="二、TCP编程"><a href="#二、TCP编程" class="headerlink" title="二、TCP编程"></a>二、TCP编程</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><h5 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1.创建套接字socket()"></a>1.创建套接字socket()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"> </span><br><span class="line">功能：</span><br><span class="line">    创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">    domain：通信域，协议族</span><br><span class="line">      AF_UNIX 本地通信</span><br><span class="line">      AF_INET ipv4网络协议</span><br><span class="line">      AF_INET6 ipv6网络协议</span><br><span class="line">      AF_PACKET 底层接口</span><br><span class="line">    type：套接字的类型</span><br><span class="line">      SOCK_STREAM 流式套接字（tcp）</span><br><span class="line">      SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line">      SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line">    protocol：附加协议，如果不需要，则设置为<span class="number">0</span></span><br><span class="line"> </span><br><span class="line">返回值：</span><br><span class="line">    成功：文件描述符</span><br><span class="line">    失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-绑定套接字bind"><a href="#2-绑定套接字bind" class="headerlink" title="2.绑定套接字bind()"></a>2.绑定套接字bind()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：</span><br><span class="line">    将套接字与网络信息结构体绑定</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket的返回值</span><br><span class="line">    addr：网络信息结构体</span><br><span class="line">      通用结构体（一般不用）</span><br><span class="line">      struct sockaddr</span><br><span class="line">      网络信息结构体 sockaddr_in</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">addrlen：</span><br><span class="line">    addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure><h5 id="3-监听套接字listen"><a href="#3-监听套接字listen" class="headerlink" title="3.监听套接字listen()"></a>3.监听套接字listen()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将套接字设置为被动监听状态，这样做之后就可以接收到连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数返回值</span><br><span class="line">    backlog：允许通信连接的主机个数，一般设置为<span class="number">5</span>、<span class="number">10</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="4-接收连接accept"><a href="#4-接收连接accept" class="headerlink" title="4.接收连接accept()"></a>4.接收连接accept()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数的返回值</span><br><span class="line">    addr：接收到的客户端的信息结构体（自动填充，定义变量即可）</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，这个新的文件描述符专门与指定的客户端进行通信的）</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="5-通信recv-send"><a href="#5-通信recv-send" class="headerlink" title="5.通信recv()/send()"></a>5.通信recv()/send()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">功能：</span><br><span class="line">    接收数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符</span><br><span class="line">客户端：socket函数的返回值</span><br><span class="line">服务器：accept函数的返回值</span><br><span class="line">    buf：保存接收到的数据</span><br><span class="line">    len：buf的长度</span><br><span class="line">    flags：标志位</span><br><span class="line">      <span class="number">0</span> 阻塞</span><br><span class="line">      MSG_DONTWAIT 非阻塞</span><br><span class="line">返回值：</span><br><span class="line">    成功：接收的字节数</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line">如果发送端关闭文件描述符或者关闭进程，则recv函数会返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"> </span><br><span class="line">功能：</span><br><span class="line">    发送数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符</span><br><span class="line"> </span><br><span class="line">客户端：</span><br><span class="line">    socket函数的返回值</span><br><span class="line">服务器：</span><br><span class="line">    accept函数的返回值</span><br><span class="line"> </span><br><span class="line">     buf：发送的数据</span><br><span class="line">     len：buf的长度</span><br><span class="line">     flags：标志位</span><br><span class="line">       <span class="number">0</span> 阻塞</span><br><span class="line">       MSG_DONTWAIT 非阻塞</span><br><span class="line"> </span><br><span class="line">返回值：</span><br><span class="line">    成功：发送的字节数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6.关闭套接字()"></a>6.关闭套接字()</h5><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><h5 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket()"></a>1.socket()</h5><h5 id="2-connect"><a href="#2-connect" class="headerlink" title="2.connect()"></a>2.connect()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给服务器发送客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数的返回值</span><br><span class="line">    addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line">    addrlen：add的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="3-send-recv"><a href="#3-send-recv" class="headerlink" title="3.send()/recv()"></a>3.send()/recv()</h5><h5 id="4-close"><a href="#4-close" class="headerlink" title="4.close()"></a>4.close()</h5><h3 id="三、OSI模型"><a href="#三、OSI模型" class="headerlink" title="三、OSI模型"></a>三、OSI模型</h3><div class="table-container"><table><thead><tr><th>应用层</th><th>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等等</th></tr></thead><tbody><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP、等等</td></tr><tr><td>会话层</td><td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等等</td></tr><tr><td>传输层</td><td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等等</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等等</td></tr><tr><td>物理层</td><td>例如铜缆、网线、光缆、无线电等等</td></tr></tbody></table></div><p><img src="C:\Users\zmycm\AppData\Roaming\Typora\typora-user-images\image-20241124204619077.png" alt="image-20241124204619077"></p><h2 id="DTLS"><a href="#DTLS" class="headerlink" title="DTLS"></a>DTLS</h2><h3 id="1-1DTLS特点作用"><a href="#1-1DTLS特点作用" class="headerlink" title="1.1DTLS特点作用"></a>1.1DTLS特点作用</h3><p><strong>DTLS</strong>: 是一种面向<strong>无连接</strong>的协议，<strong>基于 UDP</strong>，<strong>作用</strong>为给UDP提供端到端的安全通道，就像SSL/TLS对TCP的作用一样。</p><p>SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。</p><p>没用到，用到再来补充</p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86汇编&amp;内联汇编</title>
      <link href="/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h2 id="X86汇编学习"><a href="#X86汇编学习" class="headerlink" title="X86汇编学习"></a>X86汇编学习</h2><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>CPU控制整个计算机运作和运算。要想让CPU工作，就需要向它提供<strong>指令</strong>和<strong>数据</strong>。</p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><h5 id="（1）-汇编指令"><a href="#（1）-汇编指令" class="headerlink" title="（1）.汇编指令"></a>（1）.汇编指令</h5><p>直接被CPU执行的指令</p><h5 id="（2）-伪指令"><a href="#（2）-伪指令" class="headerlink" title="（2）.伪指令"></a>（2）.伪指令</h5><p>指导汇编器工作的指令，不生成机械码。</p><ul><li>段定义指令：如SEGMENT、ENDS，用于定义和结束一个段。</li><li>数据定义指令：如DB、DW，用于定义字节或字数据。</li><li>常量定义指令：如EQU，用于定义常量。</li></ul><h5 id="3-符号指令"><a href="#3-符号指令" class="headerlink" title="(3).符号指令"></a>(3).符号指令</h5><p>用于标识变量、常量、代码段等，在汇编过程中被替换为具体的地址或值。它们没有对应的机器码。</p><ul><li><p><strong>标签</strong>：用于标识代码中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">LABEL</span>: ; 定义一个标签<span class="selector-tag">LABEL</span></span><br></pre></td></tr></table></figure></li><li><p><strong>宏定义</strong>：如<code>MACRO</code>，用于定义宏，简化代码编写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYMACRO MACRO ; 宏定义内容 ENDM</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-CPU对存储器的读写"><a href="#3-CPU对存储器的读写" class="headerlink" title="3.CPU对存储器的读写"></a>3.CPU对存储器的读写</h4><ol><li>存储单元的地址</li><li>控制信息</li><li>读或者写的数据</li></ol><h4 id="4-地址总线"><a href="#4-地址总线" class="headerlink" title="4.地址总线"></a>4.地址总线</h4><p>CPU通过地址总线来<strong>指定存储器单元</strong>。</p><p>一个CPU有N根地址线，则它的地址总线宽度为N，最多可以寻找2的N次方给内存单元。</p><p>CPU通过地址总线传入存储器的必须是一个内存单元的<strong>物理地址</strong>。</p><h4 id="5-数据总线"><a href="#5-数据总线" class="headerlink" title="5.数据总线"></a>5.数据总线</h4><p>CPU与内存或其他器件之间<strong>数据传送</strong>是通过数据总线进行的。</p><h4 id="6-控制总线"><a href="#6-控制总线" class="headerlink" title="6.控制总线"></a>6.控制总线</h4><p>CPU<strong>对外部器件的控制</strong>是通过控制总线进行的。</p><h4 id="7-内存地址空间"><a href="#7-内存地址空间" class="headerlink" title="7.内存地址空间"></a>7.内存地址空间</h4><p>8086CPU地址总线宽度为20，可以定位2的20次方个内存单元，那么内存地址空间为1MB。</p><h3 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h3><h4 id="（一）、通用寄存器"><a href="#（一）、通用寄存器" class="headerlink" title="（一）、通用寄存器"></a>（一）、通用寄存器</h4><h5 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="1.数据寄存器"></a>1.数据寄存器</h5><h6 id="（1）作为完整的32位数据寄存器"><a href="#（1）作为完整的32位数据寄存器" class="headerlink" title="（1）作为完整的32位数据寄存器"></a>（1）作为完整的32位数据寄存器</h6><ul><li>EAX，EBX，ECX，EDX</li></ul><h6 id="（2）下半部分作为16位寄存器"><a href="#（2）下半部分作为16位寄存器" class="headerlink" title="（2）下半部分作为16位寄存器"></a>（2）下半部分作为16位寄存器</h6><ul><li>AX：累加器</li><li>BX：基址寄存器</li><li>CX：计数寄存器</li><li>DX：数据寄存器</li></ul><h6 id="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"><a href="#（3）16位寄存器的下半部分和上半部分再作为8位寄存器" class="headerlink" title="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"></a>（3）16位寄存器的下半部分和上半部分再作为8位寄存器</h6><ul><li>AH,AL,BLH,BL</li><li>CH,CL,DH,DL</li></ul><h5 id="2-指针寄存器"><a href="#2-指针寄存器" class="headerlink" title="2.指针寄存器"></a>2.指针寄存器</h5><ul><li>指令指针（IP）</li><li>堆栈指针（SP）</li><li>基本指针（BP）</li></ul><h5 id="3-索引寄存器"><a href="#3-索引寄存器" class="headerlink" title="3.索引寄存器"></a>3.索引寄存器</h5><ul><li>源索引（SI）</li><li>DI</li></ul><h5 id="4-数据寄存器"><a href="#4-数据寄存器" class="headerlink" title="4.数据寄存器"></a>4.数据寄存器</h5><h4 id="（二）、控制寄存器"><a href="#（二）、控制寄存器" class="headerlink" title="（二）、控制寄存器"></a>（二）、控制寄存器</h4><p>将32位指令指针寄存器和32位标志寄存器组合。</p><h5 id="通用标志位"><a href="#通用标志位" class="headerlink" title="通用标志位"></a>通用标志位</h5><ul><li><strong>溢出标志（OF）</strong> -<u>有符号</u>算术运算后数据的高阶位（最左位）的溢出。</li><li><strong>方向标记（DF）</strong> -DF值为0时，字符串操作为从左至右的方向；当DF值为1时，字符串操作为从右至左的方向。</li><li><strong>中断标志（IF）</strong> -当值为0时，它禁用外部中断，而当值为1时，它使能中断。</li><li><strong>陷阱标志（TF）</strong> -允许在单步模式下设置处理器的操作。我们使用的DEBUG程序设置了陷阱标志，因此我们可以一次逐步执行一条指令。</li><li><strong>符号标志（SF）</strong> -正结果将SF的值清除为0，负结果将其设置为1。</li><li><strong>零标志（ZF）</strong> -非零结果将零标志清零，零结果将其清零。</li><li><strong>辅助进位标志（AF）</strong> -包含经过算术运算后从位3到位4的进位；用于专业算术。当1字节算术运算引起从第3位到第4位的进位时，将设置AF。</li><li><strong>奇偶校验标志（PF）</strong> -偶数个1位将奇偶校验标志清为0，奇数个1位将奇偶校验标志清为1。</li><li><strong>进位标志（CF）</strong> -在算术运算后，它包含一个高位（最左边）的0或1进位。</li></ul><h4 id="（三）、段寄存器"><a href="#（三）、段寄存器" class="headerlink" title="（三）、段寄存器"></a>（三）、段寄存器</h4><ul><li><strong>CS</strong>：<u><strong>代码段寄存器</strong></u>，包含当前正在执行的代码的段基址。</li><li><strong>DS</strong>：<strong><u>数据段寄存器</u></strong>，通常包含程序正在操作的数据的段基址。</li><li><strong>SS</strong>：<strong><u>堆栈段寄存器</u></strong>，包含当前堆栈的段基址。</li><li><strong>ES</strong>：<strong><u>附加段寄存器</u></strong>，用于存储其他数据段的基址。</li><li><strong>FS</strong></li><li><strong>GS</strong></li></ul><h4 id="（四）8086CPU给出物理地址的方法"><a href="#（四）8086CPU给出物理地址的方法" class="headerlink" title="（四）8086CPU给出物理地址的方法"></a>（四）8086CPU给出物理地址的方法</h4><p><strong>物理地址=段地址x16+偏移地址</strong></p><p>用两个16位地址（段地址、偏移地址）合成一个20位物理地址</p><p>段地址 x 16 是十六进制<strong>段地址数据左移一位</strong></p><h3 id="（三）、内存和寻址"><a href="#（三）、内存和寻址" class="headerlink" title="（三）、内存和寻址"></a>（三）、内存和寻址</h3><h4 id="段分布"><a href="#段分布" class="headerlink" title="段分布"></a>段分布</h4><ul><li><strong>text</strong>: 存放的是二进制机器码，用于存储程序中已初始化的全局变量和静态变量，只读</li><li><strong>.data</strong>: 用于存储程序中已初始化的全局变量和静态变量。非默认值</li><li><strong>.bss</strong>：存放未初始化的全局变量，或者默认初始化的全局变量。这一部分在二进制文件中不占硬盘空间，即不会真实存储这些为初始化的变量，而是在程序加载到内存时再分配。当然肯定需要有个标识，告诉该怎么分配内存</li><li><strong>.rodata</strong>：存放只读数据，如常量数据</li></ul><h4 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h4><p>.DATA声明静态数据区</p><p><strong>在汇编中只有一维数组</strong>，只有没有二维和多维数组。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li><strong>立即寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 123 ; rax = 123</span><br></pre></td></tr></table></figure><ul><li><strong>寄存器寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rax, rbx ; rax = rax + rbx</span><br></pre></td></tr></table></figure><ul><li><strong>直接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [someVariable] ; eax = contents of memory at address someVariable</span><br></pre></td></tr></table></figure><ul><li><strong>间接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx] ; eax = contents of memory at address stored in rbx</span><br></pre></td></tr></table></figure><ul><li><strong>基址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+4] ; eax = contents of memory at address (rbx + 4)</span><br></pre></td></tr></table></figure><ul><li><strong>索引寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+rcx*4] ; eax = contents of memory at address (rbx + rcx*4)</span><br></pre></td></tr></table></figure><ul><li><strong>基址变址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+rcx+4] ; eax = contents of memory at address (rbx + rcx + 4)</span><br></pre></td></tr></table></figure><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。</p><p>它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt="img"></p><h3 id="（五）、指令"><a href="#（五）、指令" class="headerlink" title="（五）、指令"></a>（五）、指令</h3><h4 id="lea和mov指令"><a href="#lea和mov指令" class="headerlink" title="lea和mov指令"></a>lea和mov指令</h4><p>LEA指令将其第二个操作对象指定的地址放入其第一个操作对象指定的寄存器中。</p><p>MOV指令将其第二操作对象（即寄存器内容、内存内容或常量值）所引用的数据项复制到其第一操作对象（即寄存器或内存）所引用的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebx]     ; 将EBX中的地址所指向的内存中的4个字节移动到EAX中</span><br><span class="line">mov [var], ebx     ; 将EBX的内容移到内存地址var的4个字节中(注意，不加中括号的var是一个32位地址常量，加中括号才是取地址指向的内容)</span><br><span class="line">mov eax, [esi-4] ; 将内存地址ESI+(-4)上的4个字节移入EAX</span><br><span class="line">mov [esi+eax], cl ; 将CL的内容移到地址为ESI+EAX的单字节中</span><br><span class="line">mov edx, [esi+4*ebx] ; 将地址为ESI+4*EBX的4字节数据移动到EDX中</span><br></pre></td></tr></table></figure><h4 id="ADD、SUB指令"><a href="#ADD、SUB指令" class="headerlink" title="ADD、SUB指令"></a>ADD、SUB指令</h4><p>用于对字节，字和双字大小的二进制数据进行简单的加/减，即分别用于添加或减去8位，16位或32位操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;con&gt;</span><br><span class="line">sub al, ah ; AL ← AL - AH</span><br><span class="line">sub eax, 216 ; 从存储在EAX中的值中减去216</span><br></pre></td></tr></table></figure><h4 id="INC和DEC指令"><a href="#INC和DEC指令" class="headerlink" title="INC和DEC指令"></a>INC和DEC指令</h4><p>目标操作数可以是8位，16位或32位操作数。</p><p>INC指令用于将操作数加1。</p><p>DEC指令用于将操作数减1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INC EBX      ;  32-bit 寄存器 自增1</span><br><span class="line">INC DL       ;  8-bit 寄存器 自增1</span><br><span class="line">INC [count]  ;  变量count  自增1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="imul、idiv"><a href="#imul、idiv" class="headerlink" title="imul、idiv"></a>imul、idiv</h4><p>整数乘除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">imul &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;mem&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中</span><br><span class="line">imul esi, edi, 25 ; ESI → EDI * 25</span><br><span class="line"></span><br><span class="line">idiv &lt;reg32&gt;</span><br><span class="line">idiv &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中</span><br><span class="line">idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="and-or-xor指令"><a href="#and-or-xor指令" class="headerlink" title="and, or, xor指令"></a><strong>and, or, xor</strong>指令</h4><p>按位与、或和异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">and &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">and &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line">and eax, 0fH ; 清除EAX的除最后4位以外的所有位</span><br><span class="line">xor edx, edx ; 将EDX的内容设置为零</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="not、neg指令"><a href="#not、neg指令" class="headerlink" title="not、neg指令"></a>not、neg指令</h4><p>NOT 指令触发（翻转）操作对象中的所有位。其结果被称为反码。</p><p>NEG是汇编指令中的求补指令，对操作对象执行求补运算：用零减去操作对象，然后结果返回操作对象。</p><p>（将操作对象按位取反后加1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">not &lt;reg&gt;</span><br><span class="line">not &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="shl-shr指令"><a href="#shl-shr指令" class="headerlink" title="shl, shr指令"></a><strong>shl, shr</strong>指令</h4><p> 左移，右移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line">shl &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line">shl &lt;reg&gt;,&lt;cl&gt;</span><br><span class="line">shl &lt;mem&gt;,&lt;cl&gt;</span><br><span class="line"></span><br><span class="line">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）</span><br><span class="line">shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值</span><br></pre></td></tr></table></figure><h4 id="JMP及衍生"><a href="#JMP及衍生" class="headerlink" title="JMP及衍生"></a>JMP及衍生</h4><p>无条件跳转</p><div class="table-container"><table><thead><tr><th>JMP</th><th>无条件跳转指令</th></tr></thead><tbody><tr><td><strong>JC</strong></td><td>进位时跳转</td></tr><tr><td><strong>JO</strong></td><td>溢出时跳转</td></tr><tr><td><strong>JE</strong>/<strong>JZ</strong></td><td>相等/零时跳转</td></tr><tr><td><strong>JS</strong></td><td>负数时跳转</td></tr><tr><td><strong>JP</strong>/<strong>JPE</strong></td><td>奇偶校验时跳转</td></tr><tr><td></td></tr></tbody></table></div><h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><p>比较两个操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP DX, 00  ; 将DX值与0进行比较</span><br><span class="line">JE  L7      ; 如果等于，则跳转到标签L7</span><br></pre></td></tr></table></figure><h4 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h4><p>实现循环（计数型循环）</p><p>CX = CX -1</p><p>判断CX中的值，不为0则继续跳转；为0则向下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOOP    label</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="六-、调用约定"><a href="#六-、调用约定" class="headerlink" title="(六)、调用约定"></a>(六)、调用约定</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h4><p>操作系统为用户态运行的进程与硬件设备之间进行交互提供了一组接口。</p><p>实质上就是<strong><em>\</em>函数调用**</strong>，只不过调用的是<strong><em>\</em>系统函数**</strong>，处于内核态而已</p><p>在Linux中，EAX寄存器是负责传递系统调用号的。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="（一）、内联函数"><a href="#（一）、内联函数" class="headerlink" title="（一）、内联函数"></a>（一）、内联函数</h3><p>内联汇编是指在高级语言中嵌入汇编代码，，减少函数调用。</p><h3 id="（二）、内联汇编语法"><a href="#（二）、内联汇编语法" class="headerlink" title="（二）、内联汇编语法"></a>（二）、内联汇编语法</h3><h4 id="1-在-GCC-中"><a href="#1-在-GCC-中" class="headerlink" title="1. 在 GCC 中"></a>1. 在 GCC 中</h4><p>使用 <code>asm</code> 或 <code>__asm__</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly-code&quot;</span> : output : input : clobbered_registers);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, result;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;addl %%ebx, %%eax&quot;</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span>(result)           <span class="comment">// 输出约束，`a` 表示使用 EAX 寄存器</span></span><br><span class="line">    : <span class="string">&quot;a&quot;</span>(a), <span class="string">&quot;b&quot;</span>(b)         <span class="comment">// 输入约束，`b` 表示使用 EBX 寄存器</span></span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);                 <span class="comment">// 通知编译器条件码被修改</span></span><br></pre></td></tr></table></figure><h4 id="关键约束："><a href="#关键约束：" class="headerlink" title="关键约束："></a>关键约束：</h4><ul><li><strong>操作数约束</strong>：<ul><li><code>&quot;r&quot;</code>：任意寄存器</li><li><code>&quot;m&quot;</code>：内存操作数</li><li><code>&quot;i&quot;</code>：立即数</li><li><code>&quot;a&quot;</code>：EAX</li><li><code>&quot;b&quot;</code>：EBX 等</li></ul></li><li><strong>修饰符</strong>：<ul><li><code>=：</code>：表示写入输出</li><li><code>+：</code>：表示读写操作</li><li><code>&amp;：</code>：表示早期释放寄存器</li></ul></li></ul><h4 id="2-在-MSVC-中"><a href="#2-在-MSVC-中" class="headerlink" title="2. 在 MSVC 中"></a>2. 在 MSVC 中</h4><p>使用 <code>__asm</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">    mov eax, <span class="number">1</span></span><br><span class="line">    add eax, <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>, result;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, b</span><br><span class="line">        mov result, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-常用指令示例"><a href="#三-常用指令示例" class="headerlink" title="(三)常用指令示例"></a>(三)常用指令示例</h3><h4 id="1-数据传送"><a href="#1-数据传送" class="headerlink" title="1. 数据传送"></a>1. 数据传送</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 10       ; 将 10 送入 EAX 寄存器</span><br><span class="line">mov ebx, eax      ; 将 EAX 的值传给 EBX</span><br></pre></td></tr></table></figure><h4 id="2-算术运算"><a href="#2-算术运算" class="headerlink" title="2. 算术运算"></a>2. 算术运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add eax, ebx      ; EAX = EAX + EBX</span><br><span class="line">sub eax, 5        ; EAX = EAX - 5</span><br><span class="line">mul ebx           ; EAX = EAX * EBX</span><br><span class="line">div ecx           ; EAX = EAX / ECX</span><br></pre></td></tr></table></figure><h4 id="3-条件跳转"><a href="#3-条件跳转" class="headerlink" title="3. 条件跳转"></a>3. 条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, ebx      ; 比较 EAX 和 EBX</span><br><span class="line">je equal_label    ; 如果相等，则跳转到 equal_label</span><br><span class="line">jg greater_label  ; 如果大于，则跳转到 greater_label</span><br></pre></td></tr></table></figure><h4 id="4-栈操作"><a href="#4-栈操作" class="headerlink" title="4. 栈操作"></a>4. 栈操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push eax          ; 将 EAX 压入栈</span><br><span class="line">pop ebx           ; 从栈中弹出值到 EBX</span><br></pre></td></tr></table></figure><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
