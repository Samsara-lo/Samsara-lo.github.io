<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NSSCTF</title>
      <link href="/2025/01/05/NSSCTF/"/>
      <url>/2025/01/05/NSSCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h3 id="easyRE（虚函数表-反调试-内联函数）"><a href="#easyRE（虚函数表-反调试-内联函数）" class="headerlink" title="easyRE（虚函数表+反调试+内联函数）"></a>easyRE（虚函数表+反调试+内联函数）</h3><p><a href="https://www.nssctf.cn/problem/43">[SWPU 2019]easyRE | NSSCTF</a></p><p>没做出来，看了佬的wp才理清思路<a href="https://bbs.kanxue.com/thread-271798.htm#msg_header_h3_2">[原创] SWPUCTF 2019 easyRE-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  _DWORD v4[<span class="hljs-number">30</span>]; <span class="hljs-comment">// [esp-6Ch] [ebp-F8h] BYREF</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+Ch] [ebp-80h]</span><br>  _DWORD v6[<span class="hljs-number">27</span>]; <span class="hljs-comment">// [esp+10h] [ebp-7Ch] BYREF</span><br>  <span class="hljs-type">int</span> v7; <span class="hljs-comment">// [esp+88h] [ebp-4h]</span><br><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">sub_40EF90</span>() )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                                   <span class="hljs-comment">// 反调试</span><br>  <span class="hljs-built_in">sub_4026C0</span>(<span class="hljs-number">0x6Cu</span>);<br>  <span class="hljs-built_in">sub_401FE0</span>(v6);                               <span class="hljs-comment">// vftable虚函数表</span><br>  v7 = <span class="hljs-number">0</span>;<br>  v4[<span class="hljs-number">29</span>] = v4;<br>  <span class="hljs-built_in">sub_40F360</span>(v4, v6);<br>  <span class="hljs-built_in">sub_40F080</span>(v4[<span class="hljs-number">0</span>], v4[<span class="hljs-number">1</span>]);<br>  v4[<span class="hljs-number">28</span>] = v4;<br>  <span class="hljs-built_in">sub_40F360</span>(v4, v6);<br>  <span class="hljs-built_in">sub_40F150</span>(argc, (<span class="hljs-type">int</span>)argv);<br>  v5 = <span class="hljs-number">0</span>;<br>  v7 = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">sub_4021C0</span>(v6);<br>  <span class="hljs-keyword">return</span> v5;<br>&#125;<br></code></pre></td></tr></table></figure><p>反调试patch掉就行</p><h5 id="sub-401FE0"><a href="#sub-401FE0" class="headerlink" title="sub_401FE0"></a>sub_401FE0</h5><p>这里创建了一个虚函数表，下面的偏移是对比用的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_DWORD *__thiscall <span class="hljs-title">sub_401FE0</span><span class="hljs-params">(_DWORD *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br><br>  *<span class="hljs-keyword">this</span> = &amp;EASYRE::`vftable<span class="hljs-string">&#x27;;</span><br><span class="hljs-string">  this[1] = 0;</span><br><span class="hljs-string">  *((_BYTE *)this + 52) = 8;</span><br><span class="hljs-string">  *((_BYTE *)this + 53) = 0xEA;</span><br><span class="hljs-string">  *((_BYTE *)this + 54) = 0x58;</span><br><span class="hljs-string">  *((_BYTE *)this + 55) = 0xDE;</span><br><span class="hljs-string">  *((_BYTE *)this + 56) = 0x94;</span><br><span class="hljs-string">  *((_BYTE *)this + 57) = 0xD0;</span><br><span class="hljs-string">  *((_BYTE *)this + 58) = 0x3B;</span><br><span class="hljs-string">  *((_BYTE *)this + 59) = 0xBE;</span><br><span class="hljs-string">  *((_BYTE *)this + 60) = 0x88;</span><br><span class="hljs-string">  *((_BYTE *)this + 61) = 0xD4;</span><br><span class="hljs-string">  *((_BYTE *)this + 62) = 0x32;</span><br><span class="hljs-string">  *((_BYTE *)this + 63) = 0xB6;</span><br><span class="hljs-string">  *((_BYTE *)this + 64) = 0x14;</span><br><span class="hljs-string">  *((_BYTE *)this + 65) = 0x82;</span><br><span class="hljs-string">  *((_BYTE *)this + 66) = 0xB7;</span><br><span class="hljs-string">  *((_BYTE *)this + 67) = 0xAF;</span><br><span class="hljs-string">  *((_BYTE *)this + 68) = 0x14;</span><br><span class="hljs-string">  *((_BYTE *)this + 69) = 0x54;</span><br><span class="hljs-string">  *((_BYTE *)this + 70) = 0x7F;</span><br><span class="hljs-string">  *((_BYTE *)this + 71) = 0xCF;</span><br><span class="hljs-string">  qmemcpy(this + 0x12, &quot;  03\&quot;3   0 203\&quot;   $ &quot;, 20);</span><br><span class="hljs-string">  sub_4030A0(this + 0x17);</span><br><span class="hljs-string">  sub_402DE0(this + 0x1A);</span><br><span class="hljs-string">  for ( i = 0; i &lt; 40; ++i )</span><br><span class="hljs-string">    *((_BYTE *)this + i + 12) = 0;</span><br><span class="hljs-string">  return this;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">.rdata:004124E4 90 21 40 00                   ??_7EASYRE@@6B@ dd offset sub_402190    ; DATA XREF: sub_401FE0+2B↑o<br>.rdata:004124E4                                                                       ; sub_4021C0+A↑o<br>.rdata:004124E4                                                                       ; sub_40F360+C↑o<br>.rdata:004124E8 F0 21 40 00                   dd offset sub_4021F0<br>.rdata:004124EC B0 24 40 00                   dd offset sub_4024B0<br>.rdata:004124F0 00 25 40 00                   dd offset sub_402500<br>.rdata:004124F4 F0 22 40 00                   dd offset sub_4022F0<br>.rdata:004124F8 A0 23 40 00                   dd offset sub_4023A0<br>.rdata:004124FC E0 26 40 00                   dd offset sub_4026E0<br>.rdata:00412500 30 27 40 00                   dd offset sub_402730<br>.rdata:00412504 E0 23 40 00                   dd offset sub_4023E0<br>.rdata:00412508 A0 28 40 00                   dd offset sub_4028A0<br>.rdata:0041250C 00 2A 40 00                   dd offset sub_402A00<br>.rdata:00412510 40 24 40 00                   dd offset sub_402440<br>.rdata:00412514 00 00 00 00                   align 8<br></code></pre></td></tr></table></figure><p>​    </p><h4 id="sub-40F150"><a href="#sub-40F150" class="headerlink" title="sub_40F150"></a>sub_40F150</h4><p>找到对比函数</p><p> if ( sub_A124B0(va, input) )输出congratulations说明sub_A124B0是我们主要关注的函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sub_40F150</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v6[<span class="hljs-number">10</span>]; <span class="hljs-comment">// [esp+Ch] [ebp-38h] BYREF</span><br>  <span class="hljs-type">int</span> v7; <span class="hljs-comment">// [esp+40h] [ebp-4h]</span><br>  va_list va; <span class="hljs-comment">// [esp+54h] [ebp+10h] BYREF</span><br><br>  <span class="hljs-built_in">va_start</span>(va, a2);<br>  v7 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(v6, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v6));<br>  v2 = <span class="hljs-built_in">printf</span>(std::cout, <span class="hljs-string">&quot;Please input your flag : &quot;</span>);<br>  std::ostream::<span class="hljs-keyword">operator</span>&lt;&lt;(v2, sub_40F8F0);<br>  <span class="hljs-built_in">sub_40F930</span>(std::cin, v6);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">sub_4024B0</span>(v6) )<br>  &#123;<br>    v3 = <span class="hljs-built_in">printf</span>(std::cout, &amp;unk_4122F0);        <span class="hljs-comment">// congratulations</span><br>                                                <span class="hljs-comment">// </span><br>    std::ostream::<span class="hljs-keyword">operator</span>&lt;&lt;(v3, sub_40F8F0);<br>    v7 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">sub_4021C0</span>(va);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    v5 = <span class="hljs-built_in">printf</span>(std::cout, &amp;unk_41231C);        <span class="hljs-comment">// sorry，try again</span><br>    std::ostream::<span class="hljs-keyword">operator</span>&lt;&lt;(v5, sub_40F8F0);<br>    v7 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">sub_4021C0</span>(va);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="sub-4024B0"><a href="#sub-4024B0" class="headerlink" title="sub_4024B0"></a>sub_4024B0</h5><p>对照虚函数表</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL __thiscall <span class="hljs-title">sub_D724B0</span><span class="hljs-params">(_DWORD *<span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  BOOL result; <span class="hljs-comment">// eax</span><br><br>  <span class="hljs-keyword">this</span>[<span class="hljs-number">2</span>] = a2;<br>  result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ( (*(<span class="hljs-built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="hljs-keyword">this</span> + <span class="hljs-number">0xC</span>))(<span class="hljs-keyword">this</span>) )<span class="hljs-comment">// sub_402500 00D72500</span><br>  &#123;<br>    (*(<span class="hljs-built_in">void</span> (__thiscall **)(_DWORD *))(*<span class="hljs-keyword">this</span> + <span class="hljs-number">0x18</span>))(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// sub_4026E0 00D824FC</span><br>    <span class="hljs-keyword">if</span> ( (*(<span class="hljs-built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="hljs-keyword">this</span> + <span class="hljs-number">0x28</span>))(<span class="hljs-keyword">this</span>) )<span class="hljs-comment">// sub_402A00 00D72A00</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>简化一下就是</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> sub_402500（）<br>    sub_<span class="hljs-number">4026E0</span>（）<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">sub_402A00</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">return</span> 1</span><br><span class="hljs-function"><span class="hljs-keyword">return</span> 0</span><br></code></pre></td></tr></table></figure><h5 id="sub-D72500"><a href="#sub-D72500" class="headerlink" title="sub_D72500"></a>sub_D72500</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __thiscall <span class="hljs-title">sub_D72500</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+Ch] [ebp-B0h]</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v3; <span class="hljs-comment">// [esp+14h] [ebp-A8h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+24h] [ebp-98h]</span><br>  <span class="hljs-type">char</span> v6[<span class="hljs-number">56</span>]; <span class="hljs-comment">// [esp+30h] [ebp-8Ch] BYREF</span><br>  <span class="hljs-type">char</span> v7[<span class="hljs-number">20</span>]; <span class="hljs-comment">// [esp+68h] [ebp-54h] BYREF</span><br>  <span class="hljs-type">char</span> v8[<span class="hljs-number">48</span>]; <span class="hljs-comment">// [esp+7Ch] [ebp-40h] BYREF</span><br>  <span class="hljs-type">int</span> v9; <span class="hljs-comment">// [esp+B8h] [ebp-4h]</span><br><br>  v3 = &amp;<span class="hljs-keyword">this</span>[<span class="hljs-number">2</span>][<span class="hljs-built_in">strlen</span>(<span class="hljs-keyword">this</span>[<span class="hljs-number">2</span>])];<br>  <span class="hljs-built_in">strcpy</span>(v8, <span class="hljs-string">&quot;Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm&quot;</span>);<br>  <span class="hljs-built_in">sub_D726C0</span>(v6, <span class="hljs-number">0x38u</span>);                        <span class="hljs-comment">// 初始化v6</span><br>  <span class="hljs-built_in">sub_D72B00</span>(v6);<br>  v9 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">45</span>; ++i )<br>    v8[i] ^= <span class="hljs-number">0x10u</span>;                             <span class="hljs-comment">// ^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span><br>  <span class="hljs-built_in">sub_D726C0</span>(v7, <span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">sub_D72A70</span>(v8, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-built_in">LOBYTE</span>(v9) = <span class="hljs-number">1</span>;<br>  v2 = (<span class="hljs-type">unsigned</span> __int8)<span class="hljs-built_in">sub_D74260</span>(<span class="hljs-keyword">this</span>[<span class="hljs-number">2</span>], v3, v6, v7, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">LOBYTE</span>(v9) = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">sub_D72A50</span>(v7);<br>  v9 = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">sub_D726A0</span>();<br>  <span class="hljs-keyword">return</span> v2;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501031630537.png" alt="1735892999415.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;<br></code></pre></td></tr></table></figure><p>有点像正则表达式，估计是flag格式</p><h5 id="sub-A12730"><a href="#sub-A12730" class="headerlink" title="sub_A12730"></a>sub_A12730</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __thiscall <span class="hljs-title">sub_A12730</span><span class="hljs-params">(_DWORD *<span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// ecx</span><br>  <span class="hljs-type">unsigned</span> __int8 v4; <span class="hljs-comment">// al</span><br>  <span class="hljs-type">char</span> v6; <span class="hljs-comment">// cf</span><br>  <span class="hljs-type">char</span> v7; <span class="hljs-comment">// bl</span><br>  <span class="hljs-type">char</span> v8; <span class="hljs-comment">// t2</span><br>  <span class="hljs-type">int</span> v10; <span class="hljs-comment">// [esp+Ch] [ebp-30h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+14h] [ebp-28h]</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [esp+1Ch] [ebp-20h]</span><br>  <span class="hljs-type">int</span> v13; <span class="hljs-comment">// [esp+20h] [ebp-1Ch] BYREF</span><br>  <span class="hljs-type">int</span> v14; <span class="hljs-comment">// [esp+24h] [ebp-18h]</span><br>  <span class="hljs-type">int</span> v15; <span class="hljs-comment">// [esp+28h] [ebp-14h]</span><br>  <span class="hljs-type">int</span> v16; <span class="hljs-comment">// [esp+2Ch] [ebp-10h]</span><br>  <span class="hljs-type">int</span> v17; <span class="hljs-comment">// [esp+30h] [ebp-Ch]</span><br>  <span class="hljs-type">int</span> v18; <span class="hljs-comment">// [esp+34h] [ebp-8h]</span><br><br>  v13 = <span class="hljs-number">0</span>;<br>  v14 = <span class="hljs-number">0</span>;<br>  v15 = <span class="hljs-number">0</span>;<br>  v16 = <span class="hljs-number">0</span>;<br>  v17 = <span class="hljs-number">0</span>;<br>  v18 = <span class="hljs-number">0</span>;<br>  v10 = <span class="hljs-keyword">this</span>[<span class="hljs-number">2</span>] + <span class="hljs-number">5</span> * a2 + <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i )<br>    *(&amp;v13 + i) = *(i + v10);<br>  v2 = <span class="hljs-number">0</span>;<br>  v3 = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v4 = *(&amp;v13 + v2);                          <span class="hljs-comment">// 取单个字符</span><br>    _DL = v4;<br>    __asm &#123; rcl     dl, <span class="hljs-number">1</span> &#125;                     <span class="hljs-comment">// 循环左移直到CF为1</span><br>    *(&amp;v15 + v2) = <span class="hljs-number">1</span>;                           <span class="hljs-comment">// 将1写入v15 v2个字节的位置</span><br>    v7 = <span class="hljs-number">0</span>;<br>    v6 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span>                                          <span class="hljs-comment">// v8=v6左移7位</span><br>                                                <span class="hljs-comment">// v6=v4最低位</span><br>                                                <span class="hljs-comment">// v4去掉最低有效位</span><br>    &#123;<br>      v8 = v6 &lt;&lt; <span class="hljs-number">7</span>;<br>      v6 = v4 &amp; <span class="hljs-number">1</span>;<br>      v4 = (v4 &gt;&gt; <span class="hljs-number">1</span>) | v8;<br>      ++v7;                                     <span class="hljs-comment">// v7计算v4中1的个数</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> ( v6 );                               <span class="hljs-comment">// 如果v6为1 即v4的当前最低有效位是 1，继续循环，</span><br>                                                <span class="hljs-comment">// v6为0则结束循环</span><br>    *(&amp;v16 + v2++) = v7 - <span class="hljs-number">1</span>;                    <span class="hljs-comment">// 位宽度v16=v7-1</span><br>    --v3;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v3 );<br>  <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j )<br>  &#123;<br>    *(&amp;v14 + j) = *(&amp;v16 + j) + *(&amp;v15 + j);    <span class="hljs-comment">// 右边0的个数+左移至进位个数</span><br>    *(&amp;v17 + j) = *(&amp;v13 + j) &lt;&lt; *(&amp;v15 + j);   <span class="hljs-comment">// flag&lt;&lt;左移至进位个数</span><br>    *(&amp;v18 + j) = (*(&amp;v13 + j) &lt;&lt; (<span class="hljs-number">8</span> - *(&amp;v16 + j))) | ((*(&amp;v13 + j) &gt;&gt; (<span class="hljs-number">8</span> - *(&amp;v15 + j))) &lt;&lt; *(&amp;v15 + j));<br>  &#125;                                             <span class="hljs-comment">// [flag&lt;&lt;（8-右边0的个数）]|&#123;[flag&gt;&gt;(8-左移至进位个数）]&lt;&lt;左移至进位个数&#125;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sub_A12F80</span>(&amp;v13);<br>&#125;<br></code></pre></td></tr></table></figure><p>外面的dowhile其实是在计算左移几位CF为1，里面的dowhile是在计算右边0的个数</p><h5 id="sub-A128A0"><a href="#sub-A128A0" class="headerlink" title="sub_A128A0"></a>sub_A128A0</h5><p>不想看了，大概看看感觉能爆破，不行再回来看</p><p>好吧还是得看</p><p>for循环嵌套if else，大概把上面加密完的flag分为两个部分处理。</p><p>前四次循环走else，对 <code>v15 + i + 20</code> 赋值</p><p>后四次走if，对 <code>v17 + 0x1A</code> 进行操作，更新 <code>v14</code> 并对 <code>v15</code> 执行位操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">v17 = this;<br>v15 = this + 3;<br>*v15 |= *(v10 + i + 0x10) &lt;&lt; v14;<br>*v15 |= *(v5 + i + 0x10) &lt;&lt; v14;<br>*(v15 + i + 20) = *(v8 + i + 0xC) | v7;<br></code></pre></td></tr></table></figure><p>因为我们前面得到了flag格式，可以判断出来while走5次。</p><p>一个参与了加密一个没参与</p><p>这里用了佬简化完的加密</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> &#123;<br>    v9 = sub_402DC0(v17 + <span class="hljs-number">26</span>);<br>    v14 -= *(<span class="hljs-type">unsigned</span> __int8 *)(v9 + i); <span class="hljs-comment">// v14的初始值为0x20</span><br>    *v15 |= res3 &lt;&lt; v14;<br>&#125;   <br><span class="hljs-keyword">else</span> &#123;<br>    v14 -= <span class="hljs-number">8</span> - res1;<br>    *v15 |= res2 &lt;&lt; v14;<br>    *((_BYTE *)v15 + i + <span class="hljs-number">20</span>) = <span class="hljs-number">0</span>的个数 | (<span class="hljs-number">16</span> * 左移进位位数);<br>&#125;<br></code></pre></td></tr></table></figure><p>理一下逻辑</p><ul><li>校验flag格式</li><li>加密</li><li>5次循环处理加密，两种结果，一个受字符影响一个独立存在。</li><li>对比</li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#exp</span><br><span class="hljs-keyword">import</span> string<br><br><span class="hljs-comment"># 检查左移进位位数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_1</span>(<span class="hljs-params">c</span>): <br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        c = c &lt;&lt; <span class="hljs-number">1</span><br>        num += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> c &amp; <span class="hljs-number">0x100</span>:<br>            <span class="hljs-keyword">return</span> num<br><br><span class="hljs-comment"># 检查右边0的个数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_0</span>(<span class="hljs-params">c</span>): <br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> c &amp; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> num<br>        num += <span class="hljs-number">1</span><br>        c = c &gt;&gt; <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 生成标识符</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_0</span>(<span class="hljs-params">c</span>):<br>    res1 = check_0(c) + check_1(c)<br>    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="hljs-number">0xff</span>) &gt;&gt; res1<br>    res3 = ((c &gt;&gt; (<span class="hljs-number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="hljs-number">8</span> - check_0(c)) &amp; <span class="hljs-number">0xff</span>) &gt;&gt; res1)<br>    <span class="hljs-keyword">return</span> [res1, res2, res3]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_part</span>(<span class="hljs-params">c,s2</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;检查字符的分类，并返回符合条件的字符&quot;&quot;&quot;</span><br>    tmp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))<br>    tmp2=check_0(c) | (<span class="hljs-number">16</span>*check_1(c))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(s2):<br>        <span class="hljs-keyword">if</span> tmp2 ==<span class="hljs-built_in">ord</span>(i):<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>():<br>    for_each=string.ascii_lowercase+string.ascii_uppercase+string.digits<br>    second_part_res = <span class="hljs-string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span><br>    d=<span class="hljs-built_in">dict</span>.fromkeys(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(second_part_res)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(second_part_res)):<br>        d[i]=[]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> for_each:<br>        tmp=check_part(<span class="hljs-built_in">ord</span>(i))<br>        <span class="hljs-keyword">if</span> tmp:<br>            d[tmp].append(i)<br><br>    <span class="hljs-keyword">return</span> d<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">c,v14</span>):<br>    exam=&#123;c:generate_0(<span class="hljs-built_in">ord</span>(c))&#125;<br>    v14=v14-(<span class="hljs-number">8</span>-exam[c][<span class="hljs-number">0</span>])<br>    tmp=exam[c][<span class="hljs-number">1</span>]&lt;&lt;v14<br>    <span class="hljs-keyword">return</span> tmp,v14<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">c,v14</span>):<br>    exam=&#123;c:generate_0(<span class="hljs-built_in">ord</span>(c))&#125;<br>    v14=v14-exam[c][<span class="hljs-number">0</span>]<br>    tmp=exam[c][<span class="hljs-number">2</span>]&lt;&lt;v14<br>    <span class="hljs-keyword">return</span> tmp,v14<br><br><span class="hljs-keyword">import</span> string<br><br><span class="hljs-comment"># 检查左移进位位数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_1</span>(<span class="hljs-params">c</span>): <br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        c = c &lt;&lt; <span class="hljs-number">1</span><br>        num += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> c &amp; <span class="hljs-number">0x100</span>:<br>            <span class="hljs-keyword">return</span> num<br><br><span class="hljs-comment"># 检查右边0的个数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_0</span>(<span class="hljs-params">c</span>): <br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> c &amp; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> num<br>        num += <span class="hljs-number">1</span><br>        c = c &gt;&gt; <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 生成标识符</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_0</span>(<span class="hljs-params">c</span>):<br>    res1 = check_0(c) + check_1(c)<br>    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="hljs-number">0xff</span>) &gt;&gt; res1<br>    res3 = ((c &gt;&gt; (<span class="hljs-number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="hljs-number">8</span> - check_0(c)) &amp; <span class="hljs-number">0xff</span>) &gt;&gt; res1)<br>    <span class="hljs-keyword">return</span> [res1, res2, res3]<br><br><span class="hljs-comment"># 分类检查</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_part</span>(<span class="hljs-params">c</span>):<br>    tmp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))<br>    tmp2 = check_0(c) | (<span class="hljs-number">16</span> * check_1(c))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tmp:<br>        <span class="hljs-keyword">if</span> tmp2 == <span class="hljs-built_in">ord</span>(i):<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># 分类函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>():<br>    for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits<br>    second_part_res = <span class="hljs-string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span><br>    d = <span class="hljs-built_in">dict</span>.fromkeys(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(second_part_res)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(second_part_res)):<br>        d[i] = []<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> for_each:<br>        tmp = check_part(<span class="hljs-built_in">ord</span>(i))<br>        <span class="hljs-keyword">if</span> tmp:<br>            d[tmp].append(i)<br>    <br>    <span class="hljs-keyword">return</span> d<br><br><span class="hljs-comment"># 测试函数1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">c, v14</span>):<br>    exam = &#123;c: generate_0(<span class="hljs-built_in">ord</span>(c))&#125;<br>    v14 = v14 - (<span class="hljs-number">8</span> - exam[c][<span class="hljs-number">0</span>])<br>    tmp = exam[c][<span class="hljs-number">1</span>] &lt;&lt; v14<br>    <span class="hljs-keyword">return</span> tmp, v14<br><br><span class="hljs-comment"># 测试函数2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">c, v14</span>):<br>    exam = &#123;c: generate_0(<span class="hljs-built_in">ord</span>(c))&#125;<br>    v14 = v14 - exam[c][<span class="hljs-number">0</span>]<br>    tmp = exam[c][<span class="hljs-number">2</span>] &lt;&lt; v14<br>    <span class="hljs-keyword">return</span> tmp, v14<br><br><span class="hljs-comment"># 计算第一个部分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_first_part</span>(<span class="hljs-params">s</span>):<br>    v14 = <span class="hljs-number">0x20</span><br>    tmp, v14 = test_1(s[<span class="hljs-number">0</span>], v14)<br>    tmp2, v14 = test_1(s[<span class="hljs-number">1</span>], v14)<br>    tmp3, v14 = test_1(s[<span class="hljs-number">2</span>], v14)<br>    tmp4, v14 = test_1(s[<span class="hljs-number">3</span>], v14)<br>    tmp5, v14 = test_2(s[<span class="hljs-number">0</span>], v14)<br>    tmp6, v14 = test_2(s[<span class="hljs-number">1</span>], v14)<br>    tmp7, v14 = test_2(s[<span class="hljs-number">2</span>], v14)<br>    tmp8, v14 = test_2(s[<span class="hljs-number">3</span>], v14)<br>    <span class="hljs-keyword">return</span> tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8<br><br><span class="hljs-comment"># 检查第一个部分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_first_part</span>(<span class="hljs-params">second_part, first_part, d</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d[second_part[<span class="hljs-number">0</span>]]:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> d[second_part[<span class="hljs-number">1</span>]]:<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d[second_part[<span class="hljs-number">2</span>]]:<br>                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> d[second_part[<span class="hljs-number">3</span>]]:<br>                    tmp = i + j + k + m<br>                    <span class="hljs-keyword">if</span> calc_first_part(tmp) == first_part:<br>                        <span class="hljs-keyword">return</span> tmp<br><br><span class="hljs-comment"># 主程序</span><br>d = classify()<br>s2 = <span class="hljs-string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span><br>s = [<span class="hljs-string">&#x27;08&#x27;</span>, <span class="hljs-string">&#x27;EA&#x27;</span>, <span class="hljs-string">&#x27;58&#x27;</span>, <span class="hljs-string">&#x27;DE&#x27;</span>, <span class="hljs-string">&#x27;94&#x27;</span>, <span class="hljs-string">&#x27;D0&#x27;</span>, <span class="hljs-string">&#x27;3B&#x27;</span>, <span class="hljs-string">&#x27;BE&#x27;</span>, <span class="hljs-string">&#x27;88&#x27;</span>, <span class="hljs-string">&#x27;D4&#x27;</span>, <span class="hljs-string">&#x27;32&#x27;</span>, <span class="hljs-string">&#x27;B6&#x27;</span>, <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;82&#x27;</span>, <span class="hljs-string">&#x27;B7&#x27;</span>, <span class="hljs-string">&#x27;AF&#x27;</span>, <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;54&#x27;</span>, <span class="hljs-string">&#x27;7F&#x27;</span>, <span class="hljs-string">&#x27;CF&#x27;</span>]<br>flag = <span class="hljs-string">&#x27;swpuctf&#123;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>):<br>    first_part = <span class="hljs-built_in">int</span>(s[<span class="hljs-number">3</span> + <span class="hljs-number">4</span> * i] + s[<span class="hljs-number">2</span> + <span class="hljs-number">4</span> * i] + s[<span class="hljs-number">1</span> + <span class="hljs-number">4</span> * i] + s[<span class="hljs-number">4</span> * i], <span class="hljs-number">16</span>)<br>    second_part = s2[i * <span class="hljs-number">4</span>:i * <span class="hljs-number">4</span> + <span class="hljs-number">4</span>]<br>    res = check_first_part(second_part, first_part, d)<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">4</span>:<br>        flag += res<br>        <span class="hljs-keyword">break</span><br>    flag += res + <span class="hljs-string">&#x27;-&#x27;</span><br>flag += <span class="hljs-string">&#x27;&#125;&#x27;</span><br><br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-comment">#swpuctf&#123;we18-l8co-m1e4-58to-swpu&#125;</span><br></code></pre></td></tr></table></figure><h3 id="EasiestRe（双进程-自修改-背包加密）"><a href="#EasiestRe（双进程-自修改-背包加密）" class="headerlink" title="EasiestRe（双进程+自修改+背包加密）"></a>EasiestRe（双进程+自修改+背包加密）</h3><p><a href="https://www.nssctf.cn/problem/40">[SWPU 2019]EasiestRe | NSSCTF</a></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><h5 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h5><p>进来先看到IsDebuggerPresent，运行一下发现和直接打开的结果不一样，双进程。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( IsDebuggerPresent() )  <span class="hljs-comment">//调试器进程</span><br>.....<br><span class="hljs-keyword">if</span> ( CreateProcessA(Filename, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3u</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )  <span class="hljs-comment">//正常进程</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main_0</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  PVOID lpBaseAddress; <span class="hljs-comment">// [esp+18h] [ebp-558h]</span><br>  <span class="hljs-type">char</span> v5; <span class="hljs-comment">// [esp+1Fh] [ebp-551h]</span><br>  DWORD dwContinueStatus; <span class="hljs-comment">// [esp+20h] [ebp-550h]</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DEBUG_EVENT</span> <span class="hljs-title">DebugEvent</span>;</span> <span class="hljs-comment">// [esp+28h] [ebp-548h] BYREF</span><br>  <span class="hljs-type">char</span> v8; <span class="hljs-comment">// [esp+8Fh] [ebp-4E1h]</span><br>  CONTEXT Context; <span class="hljs-comment">// [esp+94h] [ebp-4DCh] BYREF</span><br>  HANDLE hThread; <span class="hljs-comment">// [esp+364h] [ebp-20Ch]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+368h] [ebp-208h]</span><br>  SIZE_T NumberOfBytesRead[<span class="hljs-number">3</span>]; <span class="hljs-comment">// [esp+370h] [ebp-200h] BYREF</span><br>  SIZE_T NumberOfBytesWritten[<span class="hljs-number">3</span>]; <span class="hljs-comment">// [esp+37Ch] [ebp-1F4h] BYREF</span><br>  <span class="hljs-type">char</span> Buffer[<span class="hljs-number">60</span>]; <span class="hljs-comment">// [esp+388h] [ebp-1E8h] BYREF</span><br>  <span class="hljs-type">char</span> v15[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+3C4h] [ebp-1ACh] BYREF</span><br>  <span class="hljs-type">char</span> v16[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [esp+3ECh] [ebp-184h] BYREF</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">STARTUPINFOA</span> <span class="hljs-title">StartupInfo</span>;</span> <span class="hljs-comment">// [esp+3FCh] [ebp-174h] BYREF</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PROCESS_INFORMATION</span> <span class="hljs-title">ProcessInformation</span>;</span> <span class="hljs-comment">// [esp+448h] [ebp-128h] BYREF</span><br>  CHAR Filename[<span class="hljs-number">267</span>]; <span class="hljs-comment">// [esp+460h] [ebp-110h] BYREF</span><br><br>  <span class="hljs-built_in">memset</span>(&amp;ProcessInformation, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ProcessInformation));<br>  j__memset(&amp;StartupInfo, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(StartupInfo));<br>  v16[<span class="hljs-number">0</span>] = <span class="hljs-number">0x90</span>;<br>  v16[<span class="hljs-number">1</span>] = <span class="hljs-number">0x83</span>;<br>  v16[<span class="hljs-number">2</span>] = <span class="hljs-number">0x7D</span>;<br>  v16[<span class="hljs-number">3</span>] = <span class="hljs-number">0xF8</span>;<br>  v16[<span class="hljs-number">4</span>] = <span class="hljs-number">0x18</span>;<br>  v16[<span class="hljs-number">5</span>] = <span class="hljs-number">0x7D</span>;<br>  v16[<span class="hljs-number">6</span>] = <span class="hljs-number">0x11</span>;<br>  v15[<span class="hljs-number">0</span>] = <span class="hljs-number">0x90</span>;<br>  v15[<span class="hljs-number">1</span>] = <span class="hljs-number">0xF</span>;<br>  v15[<span class="hljs-number">2</span>] = <span class="hljs-number">0xB6</span>;<br>  v15[<span class="hljs-number">3</span>] = <span class="hljs-number">0x55</span>;<br>  v15[<span class="hljs-number">4</span>] = <span class="hljs-number">0xF7</span>;<br>  v15[<span class="hljs-number">5</span>] = <span class="hljs-number">0x8B</span>;<br>  v15[<span class="hljs-number">6</span>] = <span class="hljs-number">0x45</span>;<br>  v15[<span class="hljs-number">7</span>] = <span class="hljs-number">8</span>;<br>  v15[<span class="hljs-number">8</span>] = <span class="hljs-number">0x8B</span>;<br>  v15[<span class="hljs-number">9</span>] = <span class="hljs-number">4</span>;<br>  v15[<span class="hljs-number">10</span>] = <span class="hljs-number">0x90</span>;<br>  v15[<span class="hljs-number">11</span>] = <span class="hljs-number">0xF</span>;<br>  v15[<span class="hljs-number">12</span>] = <span class="hljs-number">0xAF</span>;<br>  v15[<span class="hljs-number">13</span>] = <span class="hljs-number">0x45</span>;<br>  v15[<span class="hljs-number">14</span>] = <span class="hljs-number">0xFC</span>;<br>  v15[<span class="hljs-number">15</span>] = <span class="hljs-number">0x33</span>;<br>  v15[<span class="hljs-number">16</span>] = <span class="hljs-number">0xD2</span>;<br>  v15[<span class="hljs-number">17</span>] = <span class="hljs-number">0xF7</span>;<br>  v15[<span class="hljs-number">18</span>] = <span class="hljs-number">0x75</span>;<br>  v15[<span class="hljs-number">19</span>] = <span class="hljs-number">0xF8</span>;<br>  v15[<span class="hljs-number">20</span>] = <span class="hljs-number">0xF</span>;<br>  v15[<span class="hljs-number">21</span>] = <span class="hljs-number">0xB6</span>;<br>  v15[<span class="hljs-number">22</span>] = <span class="hljs-number">0x4D</span>;<br>  v15[<span class="hljs-number">23</span>] = <span class="hljs-number">0xF7</span>;<br>  v15[<span class="hljs-number">24</span>] = <span class="hljs-number">0x8B</span>;<br>  v15[<span class="hljs-number">25</span>] = <span class="hljs-number">0x45</span>;<br>  v15[<span class="hljs-number">26</span>] = <span class="hljs-number">0xC</span>;<br>  v15[<span class="hljs-number">27</span>] = <span class="hljs-number">0x89</span>;<br>  v15[<span class="hljs-number">28</span>] = <span class="hljs-number">0x14</span>;<br>  v15[<span class="hljs-number">29</span>] = <span class="hljs-number">0x88</span>;<br>  j__memset(Buffer, <span class="hljs-number">0</span>, <span class="hljs-number">0x32u</span>);<br>  NumberOfBytesWritten[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  i = <span class="hljs-number">0</span>;<br>  v8 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( IsDebuggerPresent() )                    <span class="hljs-comment">// 调试器进程</span><br>  &#123;<br>    GetStartupInfoA(&amp;StartupInfo);<br>    GetModuleFileNameA(<span class="hljs-number">0</span>, Filename, <span class="hljs-number">0x104u</span>);<br>    <span class="hljs-keyword">if</span> ( CreateProcessA(Filename, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3u</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )<span class="hljs-comment">// 创建新进程</span><br>    &#123;<br>      v5 = <span class="hljs-number">1</span>;<br>LABEL_6:<br>      <span class="hljs-keyword">while</span> ( v5 )<br>      &#123;<br>        dwContinueStatus = <span class="hljs-number">0x10002</span>;<br>        WaitForDebugEvent(&amp;DebugEvent, <span class="hljs-number">0xFFFFFFFF</span>);<br>        <span class="hljs-keyword">switch</span> ( DebugEvent.dwDebugEventCode )  <span class="hljs-comment">// 处理调试事件</span><br>        &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">1u</span>:<br>            <span class="hljs-keyword">if</span> ( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode == <span class="hljs-number">0x80000003</span> )<span class="hljs-comment">// 遇到调试断点</span><br>            &#123;<br>              v8 = <span class="hljs-number">1</span>;                           <span class="hljs-comment">// 继续执行程序，跳过当前异常</span><br>              dwContinueStatus = <span class="hljs-number">0x10002</span>;<br>              lpBaseAddress = DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress;<span class="hljs-comment">// 保存异常的地址（即断点地址）</span><br>              ReadProcessMemory(                <span class="hljs-comment">// 读取 35 字节的内存数据到buffer里</span><br>                ProcessInformation.hProcess,<br>                DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,<br>                Buffer,<br>                <span class="hljs-number">0x23u</span>,<br>                NumberOfBytesRead);<br>              <span class="hljs-keyword">if</span> ( NumberOfBytesRead[<span class="hljs-number">0</span>] )<br>              &#123;<br>                <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">35</span> &amp;&amp; Buffer[i] == <span class="hljs-number">0x90</span>; ++i )<span class="hljs-comment">// 检查nop</span><br>                  ;<br>              &#125;<br>              <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">1</span> )<br>                v8 = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">if</span> ( v8 )                         <span class="hljs-comment">// v8非0则继续执行，v8为0则跳转到dwContinueStatus = 0x80010001;</span><br>              &#123;<br>                <span class="hljs-keyword">switch</span> ( i )<br>                &#123;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    Context.ContextFlags = <span class="hljs-number">65543</span>;<br>                    hThread = OpenThread(<span class="hljs-number">0x1FFFFFu</span>, <span class="hljs-number">0</span>, DebugEvent.dwThreadId);<br>                    <span class="hljs-keyword">if</span> ( !GetThreadContext(hThread, &amp;Context) )<br>                      <span class="hljs-keyword">goto</span> LABEL_31;<br>                    ++Context.Eip;<br>                    <span class="hljs-keyword">if</span> ( SetThreadContext(hThread, &amp;Context) )<br>                    &#123;<br>                      dwContinueStatus = <span class="hljs-number">0x10002</span>;<br>                      CloseHandle(hThread);<br>                    &#125;<br>                    <span class="hljs-keyword">goto</span> LABEL_33;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>LABEL_31:<br>                    ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="hljs-number">0x80010001</span>);<br>                    <span class="hljs-keyword">goto</span> LABEL_6;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                       <span class="hljs-comment">// 将v16的数据写入lpBaseAddress</span><br>                                                <span class="hljs-comment">// 然后读取lpBaseAddress 处的数据并存储在 Buffer 中</span><br>                                                <span class="hljs-comment">// 成功写入 7 字节数据则继续执行程序</span><br>                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="hljs-number">7u</span>, NumberOfBytesWritten);<br>                    <span class="hljs-keyword">if</span> ( NumberOfBytesWritten[<span class="hljs-number">0</span>] == <span class="hljs-number">7</span> )<br>                    &#123;<br>                      ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="hljs-number">7u</span>, NumberOfBytesRead);<br>                      dwContinueStatus = <span class="hljs-number">65538</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">goto</span> LABEL_33;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>:                      <span class="hljs-comment">// v15 中的 30 字节数据写入lpBaseAddress</span><br>                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v15, <span class="hljs-number">0x1Eu</span>, NumberOfBytesWritten);<br>                    <span class="hljs-keyword">if</span> ( NumberOfBytesWritten[<span class="hljs-number">0</span>] == <span class="hljs-number">30</span> )<br>                      dwContinueStatus = <span class="hljs-number">65538</span>;<br>                    <span class="hljs-keyword">goto</span> LABEL_33;<br>                  <span class="hljs-keyword">default</span>:                      <span class="hljs-comment">// i！=4，5，7，30</span><br>                    <span class="hljs-keyword">goto</span> LABEL_33;<br>                &#125;<br>              &#125;<br>              dwContinueStatus = <span class="hljs-number">0x80010001</span>;<br>            &#125;<br>            <span class="hljs-keyword">goto</span> LABEL_33;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">2u</span>:<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">3u</span>:<br>            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="hljs-number">0x10002u</span>);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">4u</span>:<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">5u</span>:<br>            v5 = <span class="hljs-number">0</span>;<br>            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="hljs-number">0x10002u</span>);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">6u</span>:<br>            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="hljs-number">0x10002u</span>);<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">default</span>:<br>LABEL_33:<br>            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinueStatus);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    sub_F53922();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="sub-F58A40"><a href="#sub-F58A40" class="headerlink" title="sub_F58A40"></a>sub_F58A40</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">text:00F58AF8                 int     3               ; Trap to Debugger<br>text:00F58AF9                 nop<br>text:00F58AFA                 nop<br>text:00F58AFB                 nop<br>text:00F58AFC                 nop<br>text:00F58AFD                 nop<br>text:00F58AFE                 nop<br>text:00F58AFF                 push    offset aYouAreTooShort ; &quot;you are too short!&quot;<br>text:00F58B04                 call    printf<br></code></pre></td></tr></table></figure><p>根据上面的分析，遇到int 3会写入v16 7字节的数据</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                      <br>                   WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="hljs-number">7u</span>, NumberOfBytesWritten);<br>                   <span class="hljs-keyword">if</span> ( NumberOfBytesWritten[<span class="hljs-number">0</span>] == <span class="hljs-number">7</span> )<br>                   &#123;<br>                     ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="hljs-number">7u</span>, NumberOfBytesRead);<br>                     dwContinueStatus = <span class="hljs-number">65538</span>;<br>                   &#125;<br>                   <span class="hljs-keyword">goto</span> LABEL_33;<br></code></pre></td></tr></table></figure><p>paste data就行</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501051651130.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识IDApython&amp;IDC</title>
      <link href="/2024/12/30/%E5%88%9D%E8%AF%86IDApython/"/>
      <url>/2024/12/30/%E5%88%9D%E8%AF%86IDApython/</url>
      
        <content type="html"><![CDATA[<h2 id="IDApython-amp-IDC"><a href="#IDApython-amp-IDC" class="headerlink" title="IDApython&amp;IDC"></a>IDApython&amp;IDC</h2><p>IDApython官方文档：<a href="https://docs.hex-rays.com/developer-guide/idapython">IDAPython | Hex-Rays Docs</a></p><p>IDC官方文档：<a href="https://docs.hex-rays.com/developer-guide/idc">IDC | Hex-Rays Docs</a></p><h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><h4 id="1-IDC"><a href="#1-IDC" class="headerlink" title="1.IDC"></a>1.IDC</h4><p>与IDA命令行进行交互的模块，提供了很多IDA中指令相关的函数。</p><ul><li><strong><code>idc.get_name(ea)</code></strong>：获取地址 <code>ea</code> 处的名称。</li><li><strong><code>idc.get_func_name(ea)</code></strong>：获取函数地址处的函数名称。</li><li><strong><code>idc.set_name(ea, name)</code></strong>：为地址 <code>ea</code> 设置一个新的名称。</li><li><strong><code>idc.add_entry(ea, name, start, end)</code></strong>：在 <code>ea</code> 处添加一个入口点。</li><li><strong><code>idc.get_func(ea)</code></strong>：获取 <code>ea</code> 处的函数结构。</li></ul><h4 id="2-IDAAPI"><a href="#2-IDAAPI" class="headerlink" title="2.IDAAPI"></a>2.IDAAPI</h4><p>与 IDA 的核心 API 交互的主要模块。包括了对 IDA 核心对象的访问，涵盖了地址、函数、节等许多底层操作。</p><ul><li><p><strong><code>idaapi.get_func(ea)</code></strong>：返回地址 <code>ea</code> 处的函数对象。</p></li><li><p><strong><code>idaapi.get_flags(ea)</code></strong>：返回地址 <code>ea</code> 的标志，表示它是代码、数据还是其他类型。</p></li><li><p><strong><code>idaapi.create_data(ea, size, type)</code></strong>：在地址 <code>ea</code> 处创建数据。</p></li><li><p><strong><code>idaapi.get_strlit_contents(ea)</code></strong>：获取 <code>ea</code> 处的字符串内容。</p></li><li><p><strong><code>idaapi.add_func(ea)</code></strong>：将地址 <code>ea</code> 添加为一个函数。</p></li></ul><h4 id="3-IDAUTILS"><a href="#3-IDAUTILS" class="headerlink" title="3.IDAUTILS"></a>3.IDAUTILS</h4><p>工具函数，帮助在反汇编中自动化和简化分析过程。</p><ul><li><p><strong><code>idautils.Functions(start, end)</code></strong>：遍历在 <code>start</code> 到 <code>end</code> 地址范围内的所有函数。</p></li><li><p><strong><code>idautils.DecodeInstruction(ea)</code></strong>：解码地址 <code>ea</code> 处的指令。</p></li><li><p><strong><code>idautils.FindBinary(start, end, pattern, flags)</code></strong>：在指定范围内查找与模式匹配的二进制数据。</p></li><li><p><strong><code>idautils.Heads(start, end)</code></strong>：遍历地址范围内的所有指令地址。</p></li></ul><h4 id="4-ida-bytes"><a href="#4-ida-bytes" class="headerlink" title="4.ida_bytes"></a>4.ida_bytes</h4><p><code>ida_bytes</code> 提供了对内存区域字节级别操作的函数。</p><ul><li><strong><code>ida_bytes.get_byte(ea)</code></strong>：获取 <code>ea</code> 处的一个字节</li><li><strong><code>ida_bytes.get_word(ea)</code></strong>：获取 <code>ea</code> 处的一个字.</li><li><strong><code>ida_bytes.get_dword(ea)</code></strong>：获取 <code>ea</code> 处的一个双字。</li></ul><h4 id="5-ida-struct"><a href="#5-ida-struct" class="headerlink" title="5.ida_struct"></a>5.ida_struct</h4><p><code>ida_struct</code> 处理 IDA 中的结构体。你可以使用它来读取、创建、修改和设置结构体。</p><ul><li><p><strong><code>ida_struct.get_struc_name(struc)</code></strong>：获取结构体的名称。</p></li><li><p><strong><code>ida_struct.add_struc()</code></strong>：添加一个新的结构体。</p></li><li><p><strong><code>ida_struct.set_struc_member()</code></strong>：设置结构体成员的属性。</p></li></ul><h4 id="6-ida-diskio"><a href="#6-ida-diskio" class="headerlink" title="6.ida_diskio"></a>6.ida_diskio</h4><p><code>ida_diskio</code> 提供了与磁盘 IO 操作相关的函数，例如读取或写入文件。</p><ul><li><p><strong><code>ida_diskio.get_input_file_path()</code></strong>：获取当前输入文件的路径。</p></li><li><p><strong><code>ida_diskio.save_input_file()</code></strong>：保存当前输入文件。</p></li></ul><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="创建-删除函数"><a href="#创建-删除函数" class="headerlink" title="创建/删除函数"></a>创建/删除函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">idc.add_func(<span class="hljs-number">0x401000</span>, <span class="hljs-number">0x401050</span>)  <span class="hljs-comment"># Create a function starting at 0x401000 and ending at 0x401050</span><br>idc.del_func(<span class="hljs-number">0x401000</span>)  <span class="hljs-comment"># Delete the function at 0x401000</span><br></code></pre></td></tr></table></figure><h4 id="获取函数的名称"><a href="#获取函数的名称" class="headerlink" title="获取函数的名称"></a>获取函数的名称</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">get_func_name(ea)<br></code></pre></td></tr></table></figure><h4 id="遍历所有函数并打印其有效地址和名称"><a href="#遍历所有函数并打印其有效地址和名称" class="headerlink" title="遍历所有函数并打印其有效地址和名称"></a>遍历所有函数并打印其有效地址和名称</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> func_ea <span class="hljs-keyword">in</span> idautils.Functions(): func_name = idc.get_func_name(func_ea); <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func_ea), func_name)<br></code></pre></td></tr></table></figure><h4 id="列出对地址的交叉引用"><a href="#列出对地址的交叉引用" class="headerlink" title="列出对地址的交叉引用"></a>列出对地址的交叉引用</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(<span class="hljs-number">0x401000</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Xref to 0x401000 from <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(xref.frm)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="列出地址的交叉引用："><a href="#列出地址的交叉引用：" class="headerlink" title="列出地址的交叉引用："></a>列出地址的交叉引用：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsFrom(<span class="hljs-number">0x401000</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Xref from 0x401000 to <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(xref.to)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="遍历所有交叉引用并打印"><a href="#遍历所有交叉引用并打印" class="headerlink" title="遍历所有交叉引用并打印"></a>遍历所有交叉引用并打印</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> ref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ref.frm))<br></code></pre></td></tr></table></figure><h4 id="文本-指令搜索"><a href="#文本-指令搜索" class="headerlink" title="文本/指令搜索"></a>文本/指令搜索</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#搜索字符串</span><br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idc<br><br><span class="hljs-comment"># 搜索整个内存区域的字符串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">search_string</span>(<span class="hljs-params">pattern</span>):<br>    <span class="hljs-keyword">for</span> ea <span class="hljs-keyword">in</span> idautils.Strings():<br>        <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> ea:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Found string at <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(ea)&#125;</span>: <span class="hljs-subst">&#123;ea&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 搜索 &quot;Hello&quot; 字符串</span><br>search_string(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#搜索汇编指令</span><br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">search_asm_instruction</span>(<span class="hljs-params">pattern</span>):<br>    <span class="hljs-comment"># 遍历整个程序的所有指令</span><br>    <span class="hljs-keyword">for</span> ea <span class="hljs-keyword">in</span> idautils.Heads(idc.get_segm_by_name(<span class="hljs-string">&quot;.text&quot;</span>), idc.get_segm_end(idc.get_segm_by_name(<span class="hljs-string">&quot;.text&quot;</span>))):<br>        disasm = idc.GetDisasm(ea)  <span class="hljs-comment"># 获取地址处的反汇编指令</span><br>        <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> disasm:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Found instruction at <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(ea)&#125;</span>: <span class="hljs-subst">&#123;disasm&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 搜索 &quot;mov eax, ebx&quot; 指令</span><br>search_asm_instruction(<span class="hljs-string">&quot;mov eax, ebx&quot;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA, Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识TCP</title>
      <link href="/2024/12/27/%E5%88%9D%E8%AF%86TCP/"/>
      <url>/2024/12/27/%E5%88%9D%E8%AF%86TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="一、TCP特点"><a href="#一、TCP特点" class="headerlink" title="一、TCP特点"></a>一、TCP特点</h3><ol><li><p>面向连接的协议，在传输数据前需要建立一条可靠连接</p></li><li><p>流式协议，TCP将数据看作字节流。传输过程中数据是可以被分割为多个数据包在接收端重新组装的。</p></li><li><p>TCP通过校验和\序列号和确认应答来确保数据的可靠传输，出错回重新传输。</p></li><li><p>服务器被动连接，客户端主动连接。</p></li></ol><h3 id="二、TCP编程"><a href="#二、TCP编程" class="headerlink" title="二、TCP编程"></a>二、TCP编程</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><h5 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1.创建套接字socket()"></a>1.创建套接字socket()</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br> <br>功能：<br>    创建一个套接字，返回一个文件描述符<br>参数：<br>    domain：通信域，协议族<br>      AF_UNIX 本地通信<br>      AF_INET ipv4网络协议<br>      AF_INET6 ipv6网络协议<br>      AF_PACKET 底层接口<br>    type：套接字的类型<br>      SOCK_STREAM 流式套接字（tcp）<br>      SOCK_DGRAM 数据报套接字（udp）<br>      SOCK_RAW 原始套接字（用于链路层）<br>    protocol：附加协议，如果不需要，则设置为<span class="hljs-number">0</span><br> <br>返回值：<br>    成功：文件描述符<br>    失败：‐<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="2-绑定套接字bind"><a href="#2-绑定套接字bind" class="headerlink" title="2.绑定套接字bind()"></a>2.绑定套接字bind()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;sys/types.h&gt;<br> <br>#include &lt;sys/socket.h&gt;<br>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>功能：<br>    将套接字与网络信息结构体绑定<br>参数：<br>    sockfd：文件描述符，socket的返回值<br>    addr：网络信息结构体<br>      通用结构体（一般不用）<br>      struct sockaddr<br>      网络信息结构体 sockaddr_in<br>#include &lt;netinet/in.h&gt;<br>struct sockaddr_in<br>addrlen：<br>    addr的长度<br>返回值：<br>    成功：0<br>    失败：-1<br></code></pre></td></tr></table></figure><h5 id="3-监听套接字listen"><a href="#3-监听套接字listen" class="headerlink" title="3.监听套接字listen()"></a>3.监听套接字listen()</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> <span class="hljs-comment">/* See NOTES */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br>功能：<br>    将套接字设置为被动监听状态，这样做之后就可以接收到连接请求<br>参数：<br>    sockfd：文件描述符，socket函数返回值<br>    backlog：允许通信连接的主机个数，一般设置为<span class="hljs-number">5</span>、<span class="hljs-number">10</span><br>返回值：<br>    成功：<span class="hljs-number">0</span><br>    失败：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h5 id="4-接收连接accept"><a href="#4-接收连接accept" class="headerlink" title="4.接收连接accept()"></a>4.接收连接accept()</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> <span class="hljs-comment">/* See NOTES */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>功能：<br>    阻塞等待客户端的连接请求<br>参数：<br>    sockfd：文件描述符，socket函数的返回值<br>    addr：接收到的客户端的信息结构体（自动填充，定义变量即可）<br>    addrlen：addr的长度<br>返回值：<br>    成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，这个新的文件描述符专门与指定的客户端进行通信的）<br>    失败：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h5 id="5-通信recv-send"><a href="#5-通信recv-send" class="headerlink" title="5.通信recv()/send()"></a>5.通信recv()/send()</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br>功能：<br>    接收数据<br>参数：<br>    sockfd：文件描述符<br>客户端：socket函数的返回值<br>服务器：accept函数的返回值<br>    buf：保存接收到的数据<br>    len：buf的长度<br>    flags：标志位<br>      <span class="hljs-number">0</span> 阻塞<br>      MSG_DONTWAIT 非阻塞<br>返回值：<br>    成功：接收的字节数<br>    失败：<span class="hljs-number">-1</span><br>如果发送端关闭文件描述符或者关闭进程，则recv函数会返回<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br> <br>功能：<br>    发送数据<br>参数：<br>    sockfd：文件描述符<br> <br>客户端：<br>    socket函数的返回值<br>服务器：<br>    accept函数的返回值<br> <br>     buf：发送的数据<br>     len：buf的长度<br>     flags：标志位<br>       <span class="hljs-number">0</span> 阻塞<br>       MSG_DONTWAIT 非阻塞<br> <br>返回值：<br>    成功：发送的字节数<br>    失败：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h5 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6.关闭套接字()"></a>6.关闭套接字()</h5><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><h5 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket()"></a>1.socket()</h5><h5 id="2-connect"><a href="#2-connect" class="headerlink" title="2.connect()"></a>2.connect()</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> <span class="hljs-comment">/* See NOTES */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br>功能：<br>    给服务器发送客户端的连接请求<br>参数：<br>    sockfd：文件描述符，socket函数的返回值<br>    addr：要连接的服务器的网络信息结构体（需要自己设置）<br>    addrlen：add的长度<br>返回值：<br>    成功：<span class="hljs-number">0</span><br>    失败：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h5 id="3-send-recv"><a href="#3-send-recv" class="headerlink" title="3.send()/recv()"></a>3.send()/recv()</h5><h5 id="4-close"><a href="#4-close" class="headerlink" title="4.close()"></a>4.close()</h5><h3 id="三、OSI模型"><a href="#三、OSI模型" class="headerlink" title="三、OSI模型"></a>三、OSI模型</h3><div class="table-container"><table><thead><tr><th>应用层</th><th>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等等</th></tr></thead><tbody><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP、等等</td></tr><tr><td>会话层</td><td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等等</td></tr><tr><td>传输层</td><td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等等</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等等</td></tr><tr><td>物理层</td><td>例如铜缆、网线、光缆、无线电等等</td></tr></tbody></table></div><p><img src="C:\Users\zmycm\AppData\Roaming\Typora\typora-user-images\image-20241124204619077.png" alt="image-20241124204619077"></p><h2 id="DTLS"><a href="#DTLS" class="headerlink" title="DTLS"></a>DTLS</h2><h3 id="1-1DTLS特点作用"><a href="#1-1DTLS特点作用" class="headerlink" title="1.1DTLS特点作用"></a>1.1DTLS特点作用</h3><p><strong>DTLS</strong>: 是一种面向<strong>无连接</strong>的协议，<strong>基于 UDP</strong>，<strong>作用</strong>为给UDP提供端到端的安全通道，就像SSL/TLS对TCP的作用一样。</p><p>SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。</p><p>没用到，用到再来补充</p>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<hr><p>layout: ‘[layout]’<br>title: X86汇编&amp;内联汇编<br>date: 2024-12-27 01:47:24<br>categories: </p><ul><li>笔记整理<br>tags: </li><li>汇编<br>top_img: <a href="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501021640040.png">https://raw.githubusercontent.com/QYQS1/picture/main/test/202501021640040.png</a><h2 id="X86汇编学习"><a href="#X86汇编学习" class="headerlink" title="X86汇编学习"></a>X86汇编学习</h2></li></ul><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>CPU控制整个计算机运作和运算。要想让CPU工作，就需要向它提供<strong>指令</strong>和<strong>数据</strong>。</p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><h5 id="（1）-汇编指令"><a href="#（1）-汇编指令" class="headerlink" title="（1）.汇编指令"></a>（1）.汇编指令</h5><p>直接被CPU执行的指令</p><h5 id="（2）-伪指令"><a href="#（2）-伪指令" class="headerlink" title="（2）.伪指令"></a>（2）.伪指令</h5><p>指导汇编器工作的指令，不生成机械码。</p><ul><li>段定义指令：如SEGMENT、ENDS，用于定义和结束一个段。</li><li>数据定义指令：如DB、DW，用于定义字节或字数据。</li><li>常量定义指令：如EQU，用于定义常量。</li></ul><h5 id="3-符号指令"><a href="#3-符号指令" class="headerlink" title="(3).符号指令"></a>(3).符号指令</h5><p>用于标识变量、常量、代码段等，在汇编过程中被替换为具体的地址或值。它们没有对应的机器码。</p><ul><li><p><strong>标签</strong>：用于标识代码中的位置。</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">LABEL</span>: ; 定义一个标签<span class="hljs-selector-tag">LABEL</span><br></code></pre></td></tr></table></figure></li><li><p><strong>宏定义</strong>：如<code>MACRO</code>，用于定义宏，简化代码编写。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">MYMACRO MACRO ; 宏定义内容 ENDM<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-CPU对存储器的读写"><a href="#3-CPU对存储器的读写" class="headerlink" title="3.CPU对存储器的读写"></a>3.CPU对存储器的读写</h4><ol><li>存储单元的地址</li><li>控制信息</li><li>读或者写的数据</li></ol><h4 id="4-地址总线"><a href="#4-地址总线" class="headerlink" title="4.地址总线"></a>4.地址总线</h4><p>CPU通过地址总线来<strong>指定存储器单元</strong>。</p><p>一个CPU有N根地址线，则它的地址总线宽度为N，最多可以寻找2的N次方给内存单元。</p><p>CPU通过地址总线传入存储器的必须是一个内存单元的<strong>物理地址</strong>。</p><h4 id="5-数据总线"><a href="#5-数据总线" class="headerlink" title="5.数据总线"></a>5.数据总线</h4><p>CPU与内存或其他器件之间<strong>数据传送</strong>是通过数据总线进行的。</p><h4 id="6-控制总线"><a href="#6-控制总线" class="headerlink" title="6.控制总线"></a>6.控制总线</h4><p>CPU<strong>对外部器件的控制</strong>是通过控制总线进行的。</p><h4 id="7-内存地址空间"><a href="#7-内存地址空间" class="headerlink" title="7.内存地址空间"></a>7.内存地址空间</h4><p>8086CPU地址总线宽度为20，可以定位2的20次方个内存单元，那么内存地址空间为1MB。</p><h3 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h3><h4 id="（一）、通用寄存器"><a href="#（一）、通用寄存器" class="headerlink" title="（一）、通用寄存器"></a>（一）、通用寄存器</h4><h5 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="1.数据寄存器"></a>1.数据寄存器</h5><h6 id="（1）作为完整的32位数据寄存器"><a href="#（1）作为完整的32位数据寄存器" class="headerlink" title="（1）作为完整的32位数据寄存器"></a>（1）作为完整的32位数据寄存器</h6><ul><li>EAX，EBX，ECX，EDX</li></ul><h6 id="（2）下半部分作为16位寄存器"><a href="#（2）下半部分作为16位寄存器" class="headerlink" title="（2）下半部分作为16位寄存器"></a>（2）下半部分作为16位寄存器</h6><ul><li>AX：累加器</li><li>BX：基址寄存器</li><li>CX：计数寄存器</li><li>DX：数据寄存器</li></ul><h6 id="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"><a href="#（3）16位寄存器的下半部分和上半部分再作为8位寄存器" class="headerlink" title="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"></a>（3）16位寄存器的下半部分和上半部分再作为8位寄存器</h6><ul><li>AH,AL,BLH,BL</li><li>CH,CL,DH,DL</li></ul><h5 id="2-指针寄存器"><a href="#2-指针寄存器" class="headerlink" title="2.指针寄存器"></a>2.指针寄存器</h5><ul><li>指令指针（IP）</li><li>堆栈指针（SP）</li><li>基本指针（BP）</li></ul><h5 id="3-索引寄存器"><a href="#3-索引寄存器" class="headerlink" title="3.索引寄存器"></a>3.索引寄存器</h5><ul><li>源索引（SI）</li><li>DI</li></ul><h5 id="4-数据寄存器"><a href="#4-数据寄存器" class="headerlink" title="4.数据寄存器"></a>4.数据寄存器</h5><h4 id="（二）、控制寄存器"><a href="#（二）、控制寄存器" class="headerlink" title="（二）、控制寄存器"></a>（二）、控制寄存器</h4><p>将32位指令指针寄存器和32位标志寄存器组合。</p><h5 id="通用标志位"><a href="#通用标志位" class="headerlink" title="通用标志位"></a>通用标志位</h5><ul><li><strong>溢出标志（OF）</strong> -<u>有符号</u>算术运算后数据的高阶位（最左位）的溢出。</li><li><strong>方向标记（DF）</strong> -DF值为0时，字符串操作为从左至右的方向；当DF值为1时，字符串操作为从右至左的方向。</li><li><strong>中断标志（IF）</strong> -当值为0时，它禁用外部中断，而当值为1时，它使能中断。</li><li><strong>陷阱标志（TF）</strong> -允许在单步模式下设置处理器的操作。我们使用的DEBUG程序设置了陷阱标志，因此我们可以一次逐步执行一条指令。</li><li><strong>符号标志（SF）</strong> -正结果将SF的值清除为0，负结果将其设置为1。</li><li><strong>零标志（ZF）</strong> -非零结果将零标志清零，零结果将其清零。</li><li><strong>辅助进位标志（AF）</strong> -包含经过算术运算后从位3到位4的进位；用于专业算术。当1字节算术运算引起从第3位到第4位的进位时，将设置AF。</li><li><strong>奇偶校验标志（PF）</strong> -偶数个1位将奇偶校验标志清为0，奇数个1位将奇偶校验标志清为1。</li><li><strong>进位标志（CF）</strong> -在算术运算后，它包含一个高位（最左边）的0或1进位。</li></ul><h4 id="（三）、段寄存器"><a href="#（三）、段寄存器" class="headerlink" title="（三）、段寄存器"></a>（三）、段寄存器</h4><ul><li><strong>CS</strong>：<u><strong>代码段寄存器</strong></u>，包含当前正在执行的代码的段基址。</li><li><strong>DS</strong>：<strong><u>数据段寄存器</u></strong>，通常包含程序正在操作的数据的段基址。</li><li><strong>SS</strong>：<strong><u>堆栈段寄存器</u></strong>，包含当前堆栈的段基址。</li><li><strong>ES</strong>：<strong><u>附加段寄存器</u></strong>，用于存储其他数据段的基址。</li><li><strong>FS</strong></li><li><strong>GS</strong></li></ul><h4 id="（四）8086CPU给出物理地址的方法"><a href="#（四）8086CPU给出物理地址的方法" class="headerlink" title="（四）8086CPU给出物理地址的方法"></a>（四）8086CPU给出物理地址的方法</h4><p><strong>物理地址=段地址x16+偏移地址</strong></p><p>用两个16位地址（段地址、偏移地址）合成一个20位物理地址</p><p>段地址 x 16 是十六进制<strong>段地址数据左移一位</strong></p><h3 id="（三）、内存和寻址"><a href="#（三）、内存和寻址" class="headerlink" title="（三）、内存和寻址"></a>（三）、内存和寻址</h3><h4 id="段分布"><a href="#段分布" class="headerlink" title="段分布"></a>段分布</h4><ul><li><strong>text</strong>: 存放的是二进制机器码，用于存储程序中已初始化的全局变量和静态变量，只读</li><li><strong>.data</strong>: 用于存储程序中已初始化的全局变量和静态变量。非默认值</li><li><strong>.bss</strong>：存放未初始化的全局变量，或者默认初始化的全局变量。这一部分在二进制文件中不占硬盘空间，即不会真实存储这些为初始化的变量，而是在程序加载到内存时再分配。当然肯定需要有个标识，告诉该怎么分配内存</li><li><strong>.rodata</strong>：存放只读数据，如常量数据</li></ul><h4 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h4><p>.DATA声明静态数据区</p><p><strong>在汇编中只有一维数组</strong>，只有没有二维和多维数组。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li><strong>立即寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov rax, 123 ; rax = 123<br></code></pre></td></tr></table></figure><ul><li><strong>寄存器寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">add rax, rbx ; rax = rax + rbx<br></code></pre></td></tr></table></figure><ul><li><strong>直接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, [someVariable] ; eax = contents of memory at address someVariable<br></code></pre></td></tr></table></figure><ul><li><strong>间接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, [rbx] ; eax = contents of memory at address stored in rbx<br></code></pre></td></tr></table></figure><ul><li><strong>基址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, [rbx+4] ; eax = contents of memory at address (rbx + 4)<br></code></pre></td></tr></table></figure><ul><li><strong>索引寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, [rbx+rcx*4] ; eax = contents of memory at address (rbx + rcx*4)<br></code></pre></td></tr></table></figure><ul><li><strong>基址变址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, [rbx+rcx+4] ; eax = contents of memory at address (rbx + rcx + 4)<br></code></pre></td></tr></table></figure><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。</p><p>它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt="img"></p><h3 id="（五）、指令"><a href="#（五）、指令" class="headerlink" title="（五）、指令"></a>（五）、指令</h3><h4 id="lea和mov指令"><a href="#lea和mov指令" class="headerlink" title="lea和mov指令"></a>lea和mov指令</h4><p>LEA指令将其第二个操作对象指定的地址放入其第一个操作对象指定的寄存器中。</p><p>MOV指令将其第二操作对象（即寄存器内容、内存内容或常量值）所引用的数据项复制到其第一操作对象（即寄存器或内存）所引用的位置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, [ebx]     ; 将EBX中的地址所指向的内存中的4个字节移动到EAX中<br>mov [var], ebx     ; 将EBX的内容移到内存地址var的4个字节中(注意，不加中括号的var是一个32位地址常量，加中括号才是取地址指向的内容)<br>mov eax, [esi-4] ; 将内存地址ESI+(-4)上的4个字节移入EAX<br>mov [esi+eax], cl ; 将CL的内容移到地址为ESI+EAX的单字节中<br>mov edx, [esi+4*ebx] ; 将地址为ESI+4*EBX的4字节数据移动到EDX中<br></code></pre></td></tr></table></figure><h4 id="ADD、SUB指令"><a href="#ADD、SUB指令" class="headerlink" title="ADD、SUB指令"></a>ADD、SUB指令</h4><p>用于对字节，字和双字大小的二进制数据进行简单的加/减，即分别用于添加或减去8位，16位或32位操作数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">add &lt;reg&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;mem&gt;<br>add &lt;mem&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;con&gt;<br>add &lt;mem&gt;,&lt;con&gt;<br>sub al, ah ; AL ← AL - AH<br>sub eax, 216 ; 从存储在EAX中的值中减去216<br></code></pre></td></tr></table></figure><h4 id="INC和DEC指令"><a href="#INC和DEC指令" class="headerlink" title="INC和DEC指令"></a>INC和DEC指令</h4><p>目标操作数可以是8位，16位或32位操作数。</p><p>INC指令用于将操作数加1。</p><p>DEC指令用于将操作数减1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">INC EBX      ;  32-bit 寄存器 自增1<br>INC DL       ;  8-bit 寄存器 自增1<br>INC [count]  ;  变量count  自增1<br><br></code></pre></td></tr></table></figure><h4 id="imul、idiv"><a href="#imul、idiv" class="headerlink" title="imul、idiv"></a>imul、idiv</h4><p>整数乘除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">imul &lt;reg32&gt;,&lt;reg32&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;<br>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;<br><br>imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中<br>imul esi, edi, 25 ; ESI → EDI * 25<br><br>idiv &lt;reg32&gt;<br>idiv &lt;mem&gt;<br><br>idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中<br>idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<br><br></code></pre></td></tr></table></figure><h4 id="and-or-xor指令"><a href="#and-or-xor指令" class="headerlink" title="and, or, xor指令"></a><strong>and, or, xor</strong>指令</h4><p>按位与、或和异或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">and &lt;reg&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;mem&gt;<br>and &lt;mem&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;con&gt;<br>and &lt;mem&gt;,&lt;con&gt;<br><br>and eax, 0fH ; 清除EAX的除最后4位以外的所有位<br>xor edx, edx ; 将EDX的内容设置为零<br><br></code></pre></td></tr></table></figure><h4 id="not、neg指令"><a href="#not、neg指令" class="headerlink" title="not、neg指令"></a>not、neg指令</h4><p>NOT 指令触发（翻转）操作对象中的所有位。其结果被称为反码。</p><p>NEG是汇编指令中的求补指令，对操作对象执行求补运算：用零减去操作对象，然后结果返回操作对象。</p><p>（将操作对象按位取反后加1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">not &lt;reg&gt;<br>not &lt;mem&gt;<br><br>not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<br><br></code></pre></td></tr></table></figure><h4 id="shl-shr指令"><a href="#shl-shr指令" class="headerlink" title="shl, shr指令"></a><strong>shl, shr</strong>指令</h4><p> 左移，右移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">shl &lt;reg&gt;,&lt;con8&gt;<br>shl &lt;mem&gt;,&lt;con8&gt;<br>shl &lt;reg&gt;,&lt;cl&gt;<br>shl &lt;mem&gt;,&lt;cl&gt;<br><br>shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）<br>shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<br></code></pre></td></tr></table></figure><h4 id="JMP及衍生"><a href="#JMP及衍生" class="headerlink" title="JMP及衍生"></a>JMP及衍生</h4><p>无条件跳转</p><div class="table-container"><table><thead><tr><th>JMP</th><th>无条件跳转指令</th></tr></thead><tbody><tr><td><strong>JC</strong></td><td>进位时跳转</td></tr><tr><td><strong>JO</strong></td><td>溢出时跳转</td></tr><tr><td><strong>JE</strong>/<strong>JZ</strong></td><td>相等/零时跳转</td></tr><tr><td><strong>JS</strong></td><td>负数时跳转</td></tr><tr><td><strong>JP</strong>/<strong>JPE</strong></td><td>奇偶校验时跳转</td></tr><tr><td></td></tr></tbody></table></div><h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><p>比较两个操作数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">CMP DX, 00  ; 将DX值与0进行比较<br>JE  L7      ; 如果等于，则跳转到标签L7<br></code></pre></td></tr></table></figure><h4 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h4><p>实现循环（计数型循环）</p><p>CX = CX -1</p><p>判断CX中的值，不为0则继续跳转；为0则向下执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">LOOP    label<br><br></code></pre></td></tr></table></figure><h3 id="六-、调用约定"><a href="#六-、调用约定" class="headerlink" title="(六)、调用约定"></a>(六)、调用约定</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h4><p>操作系统为用户态运行的进程与硬件设备之间进行交互提供了一组接口。</p><p>实质上就是<strong><em>\</em>函数调用**</strong>，只不过调用的是<strong><em>\</em>系统函数**</strong>，处于内核态而已</p><p>在Linux中，EAX寄存器是负责传递系统调用号的。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="（一）、内联函数"><a href="#（一）、内联函数" class="headerlink" title="（一）、内联函数"></a>（一）、内联函数</h3><p>内联汇编是指在高级语言中嵌入汇编代码，，减少函数调用。</p><h3 id="（二）、内联汇编语法"><a href="#（二）、内联汇编语法" class="headerlink" title="（二）、内联汇编语法"></a>（二）、内联汇编语法</h3><h4 id="1-在-GCC-中"><a href="#1-在-GCC-中" class="headerlink" title="1. 在 GCC 中"></a>1. 在 GCC 中</h4><p>使用 <code>asm</code> 或 <code>__asm__</code> 关键字：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;assembly-code&quot;</span> : output : input : clobbered_registers);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>, result;<br><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;addl %%ebx, %%eax&quot;</span><br>    : <span class="hljs-string">&quot;=a&quot;</span>(result)           <span class="hljs-comment">// 输出约束，`a` 表示使用 EAX 寄存器</span><br>    : <span class="hljs-string">&quot;a&quot;</span>(a), <span class="hljs-string">&quot;b&quot;</span>(b)         <span class="hljs-comment">// 输入约束，`b` 表示使用 EBX 寄存器</span><br>    : <span class="hljs-string">&quot;cc&quot;</span>);                 <span class="hljs-comment">// 通知编译器条件码被修改</span><br></code></pre></td></tr></table></figure><h4 id="关键约束："><a href="#关键约束：" class="headerlink" title="关键约束："></a>关键约束：</h4><ul><li><strong>操作数约束</strong>：<ul><li><code>&quot;r&quot;</code>：任意寄存器</li><li><code>&quot;m&quot;</code>：内存操作数</li><li><code>&quot;i&quot;</code>：立即数</li><li><code>&quot;a&quot;</code>：EAX</li><li><code>&quot;b&quot;</code>：EBX 等</li></ul></li><li><strong>修饰符</strong>：<ul><li><code>=：</code>：表示写入输出</li><li><code>+：</code>：表示读写操作</li><li><code>&amp;：</code>：表示早期释放寄存器</li></ul></li></ul><h4 id="2-在-MSVC-中"><a href="#2-在-MSVC-中" class="headerlink" title="2. 在 MSVC 中"></a>2. 在 MSVC 中</h4><p>使用 <code>__asm</code> 关键字：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">__asm &#123;<br>    mov eax, <span class="hljs-number">1</span><br>    add eax, <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">3</span>, result;<br>    __asm &#123;<br>        mov eax, a<br>        add eax, b<br>        mov result, eax<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-常用指令示例"><a href="#三-常用指令示例" class="headerlink" title="(三)常用指令示例"></a>(三)常用指令示例</h3><h4 id="1-数据传送"><a href="#1-数据传送" class="headerlink" title="1. 数据传送"></a>1. 数据传送</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov eax, 10       ; 将 10 送入 EAX 寄存器<br>mov ebx, eax      ; 将 EAX 的值传给 EBX<br></code></pre></td></tr></table></figure><h4 id="2-算术运算"><a href="#2-算术运算" class="headerlink" title="2. 算术运算"></a>2. 算术运算</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">add eax, ebx      ; EAX = EAX + EBX<br>sub eax, 5        ; EAX = EAX - 5<br>mul ebx           ; EAX = EAX * EBX<br>div ecx           ; EAX = EAX / ECX<br></code></pre></td></tr></table></figure><h4 id="3-条件跳转"><a href="#3-条件跳转" class="headerlink" title="3. 条件跳转"></a>3. 条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">cmp eax, ebx      ; 比较 EAX 和 EBX<br>je equal_label    ; 如果相等，则跳转到 equal_label<br>jg greater_label  ; 如果大于，则跳转到 greater_label<br></code></pre></td></tr></table></figure><h4 id="4-栈操作"><a href="#4-栈操作" class="headerlink" title="4. 栈操作"></a>4. 栈操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">push eax          ; 将 EAX 压入栈<br>pop ebx           ; 从栈中弹出值到 EBX<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
