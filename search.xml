<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PE文件结构学习</title>
      <link href="/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h2><p>资料来源：《逆向工程核心原理》和<a href="https://www.youtube.com/watch?v=oSpeXGHaKAk&amp;t=15123s">PE文件结构格式详解（完整版）【逆向编程】 (youtube.com)</a></p><h3 id="一、PE文件基础"><a href="#一、PE文件基础" class="headerlink" title="一、PE文件基础"></a>一、PE文件基础</h3><h3 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h3><p>Windows：PE</p><p>Linux:elf</p><h3 id="2-PE文件特征"><a href="#2-PE文件特征" class="headerlink" title="2.PE文件特征"></a>2.PE文件特征</h3><p>PE文件指纹</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011858080.png" alt="1735729100495.png"></p><h3 id="3-PE结构"><a href="#3-PE结构" class="headerlink" title="3.PE结构"></a>3.PE结构</h3><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859756.png" alt="1735729120355.png"></p><h4 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h4><ul><li><strong>DOS MZ头</strong>  <strong>IMAGE_DOS_HEADER(64字节)</strong></li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859938.png" alt="1735729155568.png"></p><p><strong>e_magic</strong>：4D5A是DOS签名，不可改</p><p><strong>e_lfanew</strong>：78指向PE头开始位置，要改要一起改。</p><p>上面两个是<strong>PE指纹</strong>，操作系统用来<strong>识别是否是PE文件</strong>，其他地方可以随便改，因为<em>IMAGE_DOS_HEADER</em>是给16位平台看的，而我们现在的环境大部分是32位或者64位。</p><ul><li><strong>MS_DOS Stu</strong>，DOS存根，用来给链接器插入数据，随便改</li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011900211.png" alt="1735729196266.png"></p><h4 id="NT头-IMAGE-NT-HEADERS"><a href="#NT头-IMAGE-NT-HEADERS" class="headerlink" title="NT头 IMAGE_NT_HEADERS"></a>NT头 IMAGE_NT_HEADERS</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line"> DWORD Signature; ``<span class="comment">// PE标识</span></span><br><span class="line"> IMAGE_FILE_HEADER FileHeader; ``<span class="comment">// 标准PE头</span></span><br><span class="line"> IMAGE_OPTIONAL_HEADER32 OptionalHeader; ``<span class="comment">// 扩展PE头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h5 id="PE标识-Signature-4字节"><a href="#PE标识-Signature-4字节" class="headerlink" title="PE标识 Signature 4字节"></a>PE标识 Signature 4字节</h5><p><strong><u>不可改</u></strong>,操作系统启动程序的时候识别这个标识。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011901322.png" alt="1735729196266.png"></p><h5 id="标准PE头-IMAGE-FILE-HEADER-20字节"><a href="#标准PE头-IMAGE-FILE-HEADER-20字节" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER(20字节)"></a>标准PE头 <strong>IMAGE_FILE_HEADER</strong>(20字节)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line"> WORD Machine; <span class="comment">// 可以运行在什么样的CPU上</span></span><br><span class="line"> WORD NumberOfSections; <span class="comment">// 表示节的数量</span></span><br><span class="line"> DWORD TimeDateStamp; <span class="comment">// 编译器填写的时间戳</span></span><br><span class="line"> DWORD PointerToSymbolTable; <span class="comment">// 调试相关</span></span><br><span class="line"> DWORD NumberOfSymbols; <span class="comment">// 调试相关</span></span><br><span class="line"> WORD SizeOfOptionalHeader; <span class="comment">// 扩展PE头的大小</span></span><br><span class="line"> WORD Characteristics; <span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902971.png" alt="1735729302371.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902440.png" alt="1735729314190.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902205.png" alt="1735729331600.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">64 86 -&gt;8664 代表在x64上运行</span><br><span class="line">0F 00 有0x0F个节区</span><br><span class="line">84 D7 68 65 编译器写的时间戳，和文件无关，随便改</span><br><span class="line">调试不管</span><br><span class="line">F0 00 扩展PE头大小，可改</span><br><span class="line">22 00-&gt;0022-&gt; 0000 0000 0010 0010 第2位，第6位有值 对应数据位1，5 分别代表文件可执行，应用程序可以处理大于2GB的地址（代表64位）</span><br></pre></td></tr></table></figure><h5 id="扩展PE头-IMAGE-OPTIONAL-HEADER"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="扩展PE头  IMAGE_OPTIONAL_HEADER"></a>扩展PE头  IMAGE_OPTIONAL_HEADER</h5><h6 id="扩展PE头结构-amp-不同编译器上的差异"><a href="#扩展PE头结构-amp-不同编译器上的差异" class="headerlink" title="扩展PE头结构&amp;不同编译器上的差异"></a>扩展PE头结构&amp;不同编译器上的差异</h6><p>32位上是224字节（E0)（可扩展）</p><p>64位是F0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位为例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER32</span> &#123;</span></span><br><span class="line">    WORD    Magic;                  <span class="comment">// 标志：PE32 是 0x10B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;     <span class="comment">// 链接器的主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;     <span class="comment">// 链接器的次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;             <span class="comment">// 代码段的大小（没用）</span></span><br><span class="line">    DWORD   SizeOfInitializedData;  <span class="comment">// 初始化数据段的大小（没用）</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">// 未初始化数据段的大小（没用）</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;    <span class="comment">// 程序入口点的 RVA</span></span><br><span class="line">    DWORD   BaseOfCode;             <span class="comment">// 代码段的起始 RVA（没用）</span></span><br><span class="line">    DWORD   BaseOfData;             <span class="comment">// 数据段的起始 RVA（没用）</span></span><br><span class="line">    DWORD   ImageBase;              <span class="comment">// 内存镜像基址</span></span><br><span class="line">    DWORD   SectionAlignment;       <span class="comment">// 内存对齐</span></span><br><span class="line">    DWORD   FileAlignment;          <span class="comment">// 文件对齐</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion; <span class="comment">// OS 主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion; <span class="comment">// OS 次版本号</span></span><br><span class="line">    DWORD   SizeOfImage;            <span class="comment">// 镜像的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;          <span class="comment">// 头+节表按照文件对齐后的总大小</span></span><br><span class="line">    DWORD   CheckSum;               <span class="comment">// 校验和</span></span><br><span class="line">    WORD    Subsystem;              <span class="comment">// 子系统（如 GUI、CUI）</span></span><br><span class="line">    WORD    DllCharacteristics;    <span class="comment">// DLL 属性</span></span><br><span class="line">    DWORD   SizeOfStackReserve;     <span class="comment">// 堆栈保留大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;      <span class="comment">// 堆栈提交大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;      <span class="comment">// 堆保留大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;       <span class="comment">// 堆提交大小</span></span><br><span class="line">    DWORD   LoaderFlags;            <span class="comment">// 装载器标志（通常为 0）</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;    <span class="comment">// 数据目录项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">16</span>]; <span class="comment">// 表，结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>字段名称</strong></th><th><strong>32 位 PE（PE32）</strong></th><th><strong>64 位 PE（PE32+）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>Magic</code></td><td><code>0x10B</code></td><td><code>0x20B</code></td><td>标识 PE 文件是 32 位（PE32）还是 64 位（PE32+）。</td></tr><tr><td><code>AddressOfEntryPoint</code></td><td>存在</td><td>存在</td><td>程序入口点的 RVA（相对虚拟地址）。</td></tr><tr><td><code>BaseOfCode</code></td><td>存在</td><td>存在</td><td>代码段的起始 RVA。</td></tr><tr><td><code>BaseOfData</code></td><td>存在</td><td><strong>不存在</strong></td><td>数据段的起始 RVA，<strong>仅在 PE32 中存在</strong>。</td></tr><tr><td><code>ImageBase</code></td><td>32 位地址（默认 0x00400000）</td><td>64 位地址（默认 0x0000000140000000）</td><td>可执行文件加载到内存中的首地址。</td></tr><tr><td><code>SizeOfStackReserve</code></td><td>32 位值</td><td>64 位值</td><td>为线程的堆栈预留的大小。</td></tr><tr><td><code>SizeOfHeapReserve</code></td><td>32 位值</td><td>64 位值</td><td>为堆分配的保留大小。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011903423.png" alt="1735729389033.png"></p><h6 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a><strong><code>Magic</code></strong></h6><p>2个字节，文件的标志</p><p>32 位：10B</p><p>64 位：20B </p><h6 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint"></a><strong><code>AddressOfEntryPoint</code></strong></h6><p>4个字节，程序的入口点地址，即执行开始的位置。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904115.png" alt="1735729398902.png"></p><h6 id="ImageBase"><a href="#ImageBase" class="headerlink" title="ImageBase"></a><strong><code>ImageBase</code></strong></h6><p>4个字节，程序加载的基地址。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904366.png" alt="1735729409663.png"></p><p>AddressOfEntryPoint：<u>042CE910</u></p><p>imagebase:<u>00000010</u></p><p>程序执行入口：（EIP)042CE910+00000010=042CE920</p><h6 id="SectionAlignment"><a href="#SectionAlignment" class="headerlink" title="SectionAlignment"></a><strong><code>SectionAlignment</code></strong></h6><p>节区的内存对齐大小，节区在<strong>内存</strong>中的最小大小。</p><h6 id="FileAlignment"><a href="#FileAlignment" class="headerlink" title="FileAlignment"></a><strong><code>FileAlignment</code></strong></h6><p>节区的文件对齐大小，节区在<strong>磁盘文件</strong>中的最小单位。</p><h6 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a><strong><code>SizeOfImage</code></strong></h6><p>表示在内存中<strong>整个</strong>PE文件映射的大小（包括所有节区和头信息），可比实际的值大。内存对齐以后是SectionAlignment或者FileAlignment的整数倍。</p><h6 id="SizeOfHeaders"><a href="#SizeOfHeaders" class="headerlink" title="SizeOfHeaders"></a><strong><code>SizeOfHeaders</code></strong></h6><p>PE 文件头的大小。是<strong>FileAlignment的整数倍</strong>。</p><h6 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a><strong><code>CheckSum</code></strong></h6><p>校验和，系统用来检测文件是否被修改</p><h6 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a><strong><code>Subsystem</code></strong></h6><p>程序的子系统类型（例如，Windows GUI 或控制台应用程序），用来表示PE文件的特性。</p><h4 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h4><p><strong>IMAGE_SECTION_HEADER</strong> (40字节)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[<span class="number">8</span>];               <span class="comment">// 节名称（最多 8 字节，可能没有结束符）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   PhysicalAddress;   <span class="comment">// 实际已弃用，常为 0</span></span><br><span class="line">        DWORD   VirtualSize;       <span class="comment">// 节的实际大小（内存中的大小）</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;        <span class="comment">// 节在内存中的 RVA（相对虚拟地址）</span></span><br><span class="line">    DWORD   SizeOfRawData;         <span class="comment">// 节在文件中的大小（以 FileAlignment 对齐）</span></span><br><span class="line">    DWORD   PointerToRawData;      <span class="comment">// 节在文件中的偏移（以 FileAlignment 对齐）</span></span><br><span class="line">    DWORD   PointerToRelocations; <span class="comment">// 重定位表的文件偏移（通常为 0，已弃用）</span></span><br><span class="line">    DWORD   PointerToLinenumbers; <span class="comment">// 调试信息的文件偏移（通常为 0）</span></span><br><span class="line">    WORD    NumberOfRelocations;  <span class="comment">// 重定位条目数量（通常为 0）</span></span><br><span class="line">    WORD    NumberOfLinenumbers;  <span class="comment">// 调试行号条目数量（通常为 0）</span></span><br><span class="line">    DWORD   Characteristics;      <span class="comment">// 节的属性标志（权限、类型等）</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>红色框出来的是扩展PE头，下面就是节表</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904634.png" alt="1735729466460.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905916.png" alt="1735729479345.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905144.png" alt=""></p><h5 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h5><p>8字节，当前节的名字，可以随意更改。</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106081.png" alt="image"></h5><p>当前这个节未对齐时的大小，即实际大小。</p><p>实际大小有可能会比Size of Raw Data大，因为未初始化的全局变量在文件中是不占空间的，但是在内存里是有位置的。</p><p><strong>Q</strong>：在内存中展开时以什么为基准呢？</p><p><strong>A</strong>：谁大按谁，如果Vitual Size&gt;Size of Raw Data,则按照Vitual Size展开，反之则按照Size of Raw Data。</p><h5 id="VirtualAddress（RVA）"><a href="#VirtualAddress（RVA）" class="headerlink" title="VirtualAddress（RVA）"></a>VirtualAddress（RVA）</h5><p>在内存中的偏移地址，加上ImageBase则是内存中的真实地址。</p><h5 id="Raw-Size-Size-of-Raw-Data"><a href="#Raw-Size-Size-of-Raw-Data" class="headerlink" title="Raw Size(Size of Raw Data)"></a>Raw Size(Size of Raw Data)</h5><p>文件对齐后的大小</p><h5 id="Raw-Address-File-Pointer-to-Raw-Data"><a href="#Raw-Address-File-Pointer-to-Raw-Data" class="headerlink" title="Raw Address(File Pointer to Raw Data)"></a><strong>Raw Address</strong>(File Pointer to Raw Data)</h5><p>当前节在文件中起始位置</p><h5 id="Reloc-Address"><a href="#Reloc-Address" class="headerlink" title="Reloc Address"></a><strong>Reloc Address</strong></h5><p>节的重定位表（如果有的话）在文件中的偏移地址。</p><h5 id="Line-Numbers、Relocation-Number、Line-Number-Numbers"><a href="#Line-Numbers、Relocation-Number、Line-Number-Numbers" class="headerlink" title="Line Numbers、Relocation Number、Line Number Numbers"></a><strong>Line Numbers</strong>、<strong>Relocation Number</strong>、<strong>Line Number Numbers</strong></h5><p>与调试信息和重定位表相关。</p><h5 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h5><p>节区属性</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106048.png" alt="image"></p><h4 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h4><p>文件对齐和内存对齐的差异：</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106850.png" alt="image"></p><h3 id="4、RVA和FOA的转换"><a href="#4、RVA和FOA的转换" class="headerlink" title="4、RVA和FOA的转换"></a>4、RVA和FOA的转换</h3><p><strong>VA</strong>：虚拟内存的绝对地址。</p><p><strong>RVA</strong>：相对虚拟地址，从ImageBase开始的相对地址。</p><p><strong>FOA</strong>：文件偏移地址</p><p><strong>Q</strong>：想改边一个全局变量的初始值，应该怎么做？</p><p><strong>A</strong>：先区分全局变量有无初始值。如果有初始值，全局变量储存在文件中，如果没有初始值，在文件里就没有位置，在内存展开时才会分配位置。</p><p><1>、判断RVA是否在头部，在的话直接返回</p><p>FOA=RVA</p><p><2>、判断RVA在哪一个节</p><p>RVA&gt;=节.VA</p><p>RVA&lt;=节.VA+当前节内存对其后大小</p><p>差值=RVA-节.VA</p><p><4>、FOA=节.PointerToRawData+差值</p><p>看一下书上的例子，实例下面导入表的计算也有提到</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052107891.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108166.png" alt="image"></p><p><strong>算完RAW记得查看是否和内存中在同一节区！！！</strong>如上图Q3</p><h3 id="5、手撕PE文件"><a href="#5、手撕PE文件" class="headerlink" title="5、手撕PE文件"></a>5、手撕PE文件</h3><h4 id="（1）在空白区添加代码"><a href="#（1）在空白区添加代码" class="headerlink" title="（1）在空白区添加代码"></a>（1）在空白区添加代码</h4><h4 id="（2）扩大节"><a href="#（2）扩大节" class="headerlink" title="（2）扩大节"></a>（2）扩大节</h4><h4 id="（3）删除节"><a href="#（3）删除节" class="headerlink" title="（3）删除节"></a>（3）删除节</h4><h4 id="（4）新添节"><a href="#（4）新添节" class="headerlink" title="（4）新添节"></a>（4）新添节</h4><h4 id="（5）合并节"><a href="#（5）合并节" class="headerlink" title="（5）合并节"></a>（5）合并节</h4><h3 id="6、导出表-amp-导入表"><a href="#6、导出表-amp-导入表" class="headerlink" title="6、导出表&amp;导入表"></a>6、导出表&amp;导入表</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>首先明白，一个可执行程序是有<strong>多个pe文件组成</strong>的。</p><p><strong>导入表（IMP)</strong>：PE文件引用了哪些文件</p><p><strong>导出表(EAT)</strong>：当前的PE文件储存了哪些函数给其他文件用。</p><p><strong>Q</strong>：导出表在哪？</p><p><strong>A</strong>：再扩展PE头最后一个成员</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108437.png" alt="image"></p><h5 id="Dll"><a href="#Dll" class="headerlink" title="Dll"></a>Dll</h5><p>动态链接库</p><p>加载DLL的两种方式</p><ul><li><strong>显式链接</strong>：程序使用DLL时候加载，使用完释放内存。</li><li><strong>隐式链接</strong>：程序开始时一同加载DLL，程序终止时释放内存。</li></ul><h4 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052109509.png" alt="image"></h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052110010.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111005.png" alt="image"></p><p>先找到导出表位置</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111830.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111561.png" alt="image"></p><h4 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h4><p>确定依赖的函数</p><p><strong>导入表位置</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112545.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112232.png" alt="image"></p><p><strong>导入表结构</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112548.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113698.png" alt="image"></p><h5 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h5><p>字符串指针，指向导入函数所属的库文件名字。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113795.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113568.png" alt="image"></p><p>RVA要转成FOA，参考下面的实际计算</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114790.png" alt="image"></p><p>因为指向的是assic码的字符串，所以到第一个00结束</p><h5 id="OringinalFirstThunk-INT"><a href="#OringinalFirstThunk-INT" class="headerlink" title="OringinalFirstThunk-INT"></a>OringinalFirstThunk-INT</h5><p>导入名称表<img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114717.png" alt="image"></p><h5 id="FirstThunk-IAT"><a href="#FirstThunk-IAT" class="headerlink" title="FirstThunk-IAT"></a>FirstThunk-IAT</h5><p>导入地址表</p><h4 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052115276.png" alt="image"></p><p>Export Directory RVA：93 5D 82 09-&gt;0x09825D93(imagebase:0x00000010)查了一下再rdata段-&gt;FOA：0x09825D83</p><p>Export Directory Size：00033669</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116225.png" alt="image"></p><p>看了010半天不对，dumpbin /headers看了一下，然后又开了个exe，发现这个爆红的意思是typora.exe没有导入表导出表。。。(也有可能有加壳？die看了一下没有，但是这个地址太大了不正常)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /headers &quot;D:\Typora\Typora\Typora.exe&quot;</span><br></pre></td></tr></table></figure><p>换个文件来</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116588.png" alt="image"></p><p>Import Directory RVA：0x00003824，在.rdata段，rdata段的RVA是0x00003000，所以相对地址就是0x00000824，rdata段的raw address是0x00001A00，所以FOA是0x00002224，大小是C8字节</p><p><strong>Import Directory RVA</strong>：0x00003824</p><p><strong>.rdata段的 RVA</strong>：0x00003000</p><p><strong>.rdata段的 Raw Address</strong>：0x00001A00</p><p><strong>.rdata段的 Raw Size</strong>：C8 字节（即 200 字节）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相对地址 <span class="operator">=</span> <span class="built_in">Import</span> <span class="built_in">Directory</span> <span class="variable">RVA</span> <span class="operator">-</span> <span class="operator">.</span><span class="variable">rdata</span>段的 <span class="variable">RVA</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00003824</span> <span class="operator">-</span> <span class="number">0</span><span class="variable">x00003000</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00000824</span></span><br><span class="line"></span><br><span class="line"><span class="variable">FOA</span> <span class="operator">=</span> <span class="operator">.</span><span class="variable">rdata</span>段的 <span class="variable">Raw</span> <span class="variable">Address</span> <span class="operator">+</span> 相对地址 <span class="operator">=</span><span class="number">0</span><span class="variable">x00001A00</span> <span class="operator">+</span> <span class="number">0</span><span class="variable">x00000824</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00002224</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116426.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF</title>
      <link href="/2025/01/05/NSSCTF/"/>
      <url>/2025/01/05/NSSCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="easyRE（虚函数表-反调试-内联函数）"><a href="#easyRE（虚函数表-反调试-内联函数）" class="headerlink" title="easyRE（虚函数表+反调试+内联函数）"></a>easyRE（虚函数表+反调试+内联函数）</h2><p><a href="https://www.nssctf.cn/problem/43">[SWPU 2019]easyRE | NSSCTF</a></p><p>没做出来，看了佬的wp才理清思路<a href="https://bbs.kanxue.com/thread-271798.htm#msg_header_h3_2">[原创] SWPUCTF 2019 easyRE-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD v4[<span class="number">30</span>]; <span class="comment">// [esp-6Ch] [ebp-F8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+Ch] [ebp-80h]</span></span><br><span class="line">  _DWORD v6[<span class="number">27</span>]; <span class="comment">// [esp+10h] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+88h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_40EF90</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                                   <span class="comment">// 反调试</span></span><br><span class="line">  <span class="built_in">sub_4026C0</span>(<span class="number">0x6Cu</span>);</span><br><span class="line">  <span class="built_in">sub_401FE0</span>(v6);                               <span class="comment">// vftable虚函数表</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v4[<span class="number">29</span>] = v4;</span><br><span class="line">  <span class="built_in">sub_40F360</span>(v4, v6);</span><br><span class="line">  <span class="built_in">sub_40F080</span>(v4[<span class="number">0</span>], v4[<span class="number">1</span>]);</span><br><span class="line">  v4[<span class="number">28</span>] = v4;</span><br><span class="line">  <span class="built_in">sub_40F360</span>(v4, v6);</span><br><span class="line">  <span class="built_in">sub_40F150</span>(argc, (<span class="type">int</span>)argv);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sub_4021C0</span>(v6);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反调试patch掉就行</p><h4 id="sub-401FE0"><a href="#sub-401FE0" class="headerlink" title="sub_401FE0"></a>sub_401FE0</h4><p>这里创建了一个虚函数表，下面的偏移是对比用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD *__thiscall <span class="title">sub_401FE0</span><span class="params">(_DWORD *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> = &amp;EASYRE::`vftable<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">  this[1] = 0;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 52) = 8;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 53) = 0xEA;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 54) = 0x58;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 55) = 0xDE;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 56) = 0x94;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 57) = 0xD0;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 58) = 0x3B;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 59) = 0xBE;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 60) = 0x88;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 61) = 0xD4;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 62) = 0x32;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 63) = 0xB6;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 64) = 0x14;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 65) = 0x82;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 66) = 0xB7;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 67) = 0xAF;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 68) = 0x14;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 69) = 0x54;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 70) = 0x7F;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 71) = 0xCF;</span></span><br><span class="line"><span class="string">  qmemcpy(this + 0x12, &quot;  03\&quot;3   0 203\&quot;   $ &quot;, 20);</span></span><br><span class="line"><span class="string">  sub_4030A0(this + 0x17);</span></span><br><span class="line"><span class="string">  sub_402DE0(this + 0x1A);</span></span><br><span class="line"><span class="string">  for ( i = 0; i &lt; 40; ++i )</span></span><br><span class="line"><span class="string">    *((_BYTE *)this + i + 12) = 0;</span></span><br><span class="line"><span class="string">  return this;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.rdata:004124E4 90 21 40 00                   ??_7EASYRE@@6B@ dd offset sub_402190    ; DATA XREF: sub_401FE0+2B↑o</span><br><span class="line">.rdata:004124E4                                                                       ; sub_4021C0+A↑o</span><br><span class="line">.rdata:004124E4                                                                       ; sub_40F360+C↑o</span><br><span class="line">.rdata:004124E8 F0 21 40 00                   dd offset sub_4021F0</span><br><span class="line">.rdata:004124EC B0 24 40 00                   dd offset sub_4024B0</span><br><span class="line">.rdata:004124F0 00 25 40 00                   dd offset sub_402500</span><br><span class="line">.rdata:004124F4 F0 22 40 00                   dd offset sub_4022F0</span><br><span class="line">.rdata:004124F8 A0 23 40 00                   dd offset sub_4023A0</span><br><span class="line">.rdata:004124FC E0 26 40 00                   dd offset sub_4026E0</span><br><span class="line">.rdata:00412500 30 27 40 00                   dd offset sub_402730</span><br><span class="line">.rdata:00412504 E0 23 40 00                   dd offset sub_4023E0</span><br><span class="line">.rdata:00412508 A0 28 40 00                   dd offset sub_4028A0</span><br><span class="line">.rdata:0041250C 00 2A 40 00                   dd offset sub_402A00</span><br><span class="line">.rdata:00412510 40 24 40 00                   dd offset sub_402440</span><br><span class="line">.rdata:00412514 00 00 00 00                   align 8</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="sub-40F150"><a href="#sub-40F150" class="headerlink" title="sub_40F150"></a>sub_40F150</h4><p>找到对比函数</p><p> if ( sub_A124B0(va, input) )输出congratulations说明sub_A124B0是我们主要关注的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_40F150</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">10</span>]; <span class="comment">// [esp+Ch] [ebp-38h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+40h] [ebp-4h]</span></span><br><span class="line">  va_list va; <span class="comment">// [esp+54h] [ebp+10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span>(va, a2);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="built_in">sizeof</span>(v6));</span><br><span class="line">  v2 = <span class="built_in">printf</span>(std::cout, <span class="string">&quot;Please input your flag : &quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, sub_40F8F0);</span><br><span class="line">  <span class="built_in">sub_40F930</span>(std::cin, v6);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_4024B0</span>(v6) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">printf</span>(std::cout, &amp;unk_4122F0);        <span class="comment">// congratulations</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, sub_40F8F0);</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sub_4021C0</span>(va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">printf</span>(std::cout, &amp;unk_41231C);        <span class="comment">// sorry，try again</span></span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v5, sub_40F8F0);</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sub_4021C0</span>(va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sub-4024B0"><a href="#sub-4024B0" class="headerlink" title="sub_4024B0"></a>sub_4024B0</h4><p>对照虚函数表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL __thiscall <span class="title">sub_D724B0</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">2</span>] = a2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0xC</span>))(<span class="keyword">this</span>) )<span class="comment">// sub_402500 00D72500</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="built_in">void</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0x18</span>))(<span class="keyword">this</span>);<span class="comment">// sub_4026E0 00D824FC</span></span><br><span class="line">    <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0x28</span>))(<span class="keyword">this</span>) )<span class="comment">// sub_402A00 00D72A00</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化一下就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sub_402500（）</span><br><span class="line">    sub_<span class="number">4026E0</span>（）</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">sub_402A00</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 1</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> 0</span></span><br></pre></td></tr></table></figure><h4 id="sub-D72500"><a href="#sub-D72500" class="headerlink" title="sub_D72500"></a>sub_D72500</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __thiscall <span class="title">sub_D72500</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-B0h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// [esp+14h] [ebp-A8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+24h] [ebp-98h]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">56</span>]; <span class="comment">// [esp+30h] [ebp-8Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">20</span>]; <span class="comment">// [esp+68h] [ebp-54h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">48</span>]; <span class="comment">// [esp+7Ch] [ebp-40h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+B8h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = &amp;<span class="keyword">this</span>[<span class="number">2</span>][<span class="built_in">strlen</span>(<span class="keyword">this</span>[<span class="number">2</span>])];</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">&quot;Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_D726C0</span>(v6, <span class="number">0x38u</span>);                        <span class="comment">// 初始化v6</span></span><br><span class="line">  <span class="built_in">sub_D72B00</span>(v6);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i )</span><br><span class="line">    v8[i] ^= <span class="number">0x10u</span>;                             <span class="comment">// ^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span></span><br><span class="line">  <span class="built_in">sub_D726C0</span>(v7, <span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">sub_D72A70</span>(v8, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v9) = <span class="number">1</span>;</span><br><span class="line">  v2 = (<span class="type">unsigned</span> __int8)<span class="built_in">sub_D74260</span>(<span class="keyword">this</span>[<span class="number">2</span>], v3, v6, v7, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">LOBYTE</span>(v9) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">sub_D72A50</span>(v7);</span><br><span class="line">  v9 = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sub_D726A0</span>();</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501031630537.png" alt="1735892999415.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span><br></pre></td></tr></table></figure><p>有点像正则表达式，估计是flag格式</p><h4 id="sub-A12730"><a href="#sub-A12730" class="headerlink" title="sub_A12730"></a>sub_A12730</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __thiscall <span class="title">sub_A12730</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// bl</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// t2</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+Ch] [ebp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+14h] [ebp-28h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+1Ch] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+20h] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp+24h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp+28h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+2Ch] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp+30h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp+34h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="keyword">this</span>[<span class="number">2</span>] + <span class="number">5</span> * a2 + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i )</span><br><span class="line">    *(&amp;v13 + i) = *(i + v10);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(&amp;v13 + v2);                          <span class="comment">// 取单个字符</span></span><br><span class="line">    _DL = v4;</span><br><span class="line">    __asm &#123; rcl     dl, <span class="number">1</span> &#125;                     <span class="comment">// 循环左移直到CF为1</span></span><br><span class="line">    *(&amp;v15 + v2) = <span class="number">1</span>;                           <span class="comment">// 将1写入v15 v2个字节的位置</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>                                          <span class="comment">// v8=v6左移7位</span></span><br><span class="line">                                                <span class="comment">// v6=v4最低位</span></span><br><span class="line">                                                <span class="comment">// v4去掉最低有效位</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v6 &lt;&lt; <span class="number">7</span>;</span><br><span class="line">      v6 = v4 &amp; <span class="number">1</span>;</span><br><span class="line">      v4 = (v4 &gt;&gt; <span class="number">1</span>) | v8;</span><br><span class="line">      ++v7;                                     <span class="comment">// v7计算v4中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 );                               <span class="comment">// 如果v6为1 即v4的当前最低有效位是 1，继续循环，</span></span><br><span class="line">                                                <span class="comment">// v6为0则结束循环</span></span><br><span class="line">    *(&amp;v16 + v2++) = v7 - <span class="number">1</span>;                    <span class="comment">// 位宽度v16=v7-1</span></span><br><span class="line">    --v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 );</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    *(&amp;v14 + j) = *(&amp;v16 + j) + *(&amp;v15 + j);    <span class="comment">// 右边0的个数+左移至进位个数</span></span><br><span class="line">    *(&amp;v17 + j) = *(&amp;v13 + j) &lt;&lt; *(&amp;v15 + j);   <span class="comment">// flag&lt;&lt;左移至进位个数</span></span><br><span class="line">    *(&amp;v18 + j) = (*(&amp;v13 + j) &lt;&lt; (<span class="number">8</span> - *(&amp;v16 + j))) | ((*(&amp;v13 + j) &gt;&gt; (<span class="number">8</span> - *(&amp;v15 + j))) &lt;&lt; *(&amp;v15 + j));</span><br><span class="line">  &#125;                                             <span class="comment">// [flag&lt;&lt;（8-右边0的个数）]|&#123;[flag&gt;&gt;(8-左移至进位个数）]&lt;&lt;左移至进位个数&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_A12F80</span>(&amp;v13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外面的dowhile其实是在计算左移几位CF为1，里面的dowhile是在计算右边0的个数</p><h4 id="sub-A128A0"><a href="#sub-A128A0" class="headerlink" title="sub_A128A0"></a>sub_A128A0</h4><p>不想看了，大概看看感觉能爆破，不行再回来看</p><p>好吧还是得看</p><p>for循环嵌套if else，大概把上面加密完的flag分为两个部分处理。</p><p>前四次循环走else，对 <code>v15 + i + 20</code> 赋值</p><p>后四次走if，对 <code>v17 + 0x1A</code> 进行操作，更新 <code>v14</code> 并对 <code>v15</code> 执行位操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v17 = this;</span><br><span class="line">v15 = this + 3;</span><br><span class="line">*v15 |= *(v10 + i + 0x10) &lt;&lt; v14;</span><br><span class="line">*v15 |= *(v5 + i + 0x10) &lt;&lt; v14;</span><br><span class="line">*(v15 + i + 20) = *(v8 + i + 0xC) | v7;</span><br></pre></td></tr></table></figure><p>因为我们前面得到了flag格式，可以判断出来while走5次。</p><p>一个参与了加密一个没参与</p><p>这里用了佬简化完的加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;</span><br><span class="line">    v9 = sub_402DC0(v17 + <span class="number">26</span>);</span><br><span class="line">    v14 -= *(<span class="type">unsigned</span> __int8 *)(v9 + i); <span class="comment">// v14的初始值为0x20</span></span><br><span class="line">    *v15 |= res3 &lt;&lt; v14;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    v14 -= <span class="number">8</span> - res1;</span><br><span class="line">    *v15 |= res2 &lt;&lt; v14;</span><br><span class="line">    *((_BYTE *)v15 + i + <span class="number">20</span>) = <span class="number">0</span>的个数 | (<span class="number">16</span> * 左移进位位数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理一下逻辑</p><ul><li>校验flag格式</li><li>加密</li><li>5次循环处理加密，两种结果，一个受字符影响一个独立存在。</li><li>对比</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查左移进位位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_1</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = c &lt;&lt; <span class="number">1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">0x100</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查右边0的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_0</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        c = c &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标识符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_0</span>(<span class="params">c</span>):</span><br><span class="line">    res1 = check_0(c) + check_1(c)</span><br><span class="line">    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1</span><br><span class="line">    res3 = ((c &gt;&gt; (<span class="number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="number">8</span> - check_0(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1)</span><br><span class="line">    <span class="keyword">return</span> [res1, res2, res3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_part</span>(<span class="params">c,s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查字符的分类，并返回符合条件的字符&quot;&quot;&quot;</span></span><br><span class="line">    tmp = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))</span><br><span class="line">    tmp2=check_0(c) | (<span class="number">16</span>*check_1(c))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s2):</span><br><span class="line">        <span class="keyword">if</span> tmp2 ==<span class="built_in">ord</span>(i):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>():</span><br><span class="line">    for_each=string.ascii_lowercase+string.ascii_uppercase+string.digits</span><br><span class="line">    second_part_res = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">    d=<span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)):</span><br><span class="line">        d[i]=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> for_each:</span><br><span class="line">        tmp=check_part(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            d[tmp].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">c,v14</span>):</span><br><span class="line">    exam=&#123;c:generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14=v14-(<span class="number">8</span>-exam[c][<span class="number">0</span>])</span><br><span class="line">    tmp=exam[c][<span class="number">1</span>]&lt;&lt;v14</span><br><span class="line">    <span class="keyword">return</span> tmp,v14</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">c,v14</span>):</span><br><span class="line">    exam=&#123;c:generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14=v14-exam[c][<span class="number">0</span>]</span><br><span class="line">    tmp=exam[c][<span class="number">2</span>]&lt;&lt;v14</span><br><span class="line">    <span class="keyword">return</span> tmp,v14</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查左移进位位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_1</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = c &lt;&lt; <span class="number">1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">0x100</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查右边0的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_0</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        c = c &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标识符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_0</span>(<span class="params">c</span>):</span><br><span class="line">    res1 = check_0(c) + check_1(c)</span><br><span class="line">    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1</span><br><span class="line">    res3 = ((c &gt;&gt; (<span class="number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="number">8</span> - check_0(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1)</span><br><span class="line">    <span class="keyword">return</span> [res1, res2, res3]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_part</span>(<span class="params">c</span>):</span><br><span class="line">    tmp = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))</span><br><span class="line">    tmp2 = check_0(c) | (<span class="number">16</span> * check_1(c))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">        <span class="keyword">if</span> tmp2 == <span class="built_in">ord</span>(i):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>():</span><br><span class="line">    for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits</span><br><span class="line">    second_part_res = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)):</span><br><span class="line">        d[i] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> for_each:</span><br><span class="line">        tmp = check_part(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            d[tmp].append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">c, v14</span>):</span><br><span class="line">    exam = &#123;c: generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14 = v14 - (<span class="number">8</span> - exam[c][<span class="number">0</span>])</span><br><span class="line">    tmp = exam[c][<span class="number">1</span>] &lt;&lt; v14</span><br><span class="line">    <span class="keyword">return</span> tmp, v14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">c, v14</span>):</span><br><span class="line">    exam = &#123;c: generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14 = v14 - exam[c][<span class="number">0</span>]</span><br><span class="line">    tmp = exam[c][<span class="number">2</span>] &lt;&lt; v14</span><br><span class="line">    <span class="keyword">return</span> tmp, v14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算第一个部分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_first_part</span>(<span class="params">s</span>):</span><br><span class="line">    v14 = <span class="number">0x20</span></span><br><span class="line">    tmp, v14 = test_1(s[<span class="number">0</span>], v14)</span><br><span class="line">    tmp2, v14 = test_1(s[<span class="number">1</span>], v14)</span><br><span class="line">    tmp3, v14 = test_1(s[<span class="number">2</span>], v14)</span><br><span class="line">    tmp4, v14 = test_1(s[<span class="number">3</span>], v14)</span><br><span class="line">    tmp5, v14 = test_2(s[<span class="number">0</span>], v14)</span><br><span class="line">    tmp6, v14 = test_2(s[<span class="number">1</span>], v14)</span><br><span class="line">    tmp7, v14 = test_2(s[<span class="number">2</span>], v14)</span><br><span class="line">    tmp8, v14 = test_2(s[<span class="number">3</span>], v14)</span><br><span class="line">    <span class="keyword">return</span> tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查第一个部分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_first_part</span>(<span class="params">second_part, first_part, d</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> d[second_part[<span class="number">0</span>]]:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> d[second_part[<span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> d[second_part[<span class="number">2</span>]]:</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> d[second_part[<span class="number">3</span>]]:</span><br><span class="line">                    tmp = i + j + k + m</span><br><span class="line">                    <span class="keyword">if</span> calc_first_part(tmp) == first_part:</span><br><span class="line">                        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line">d = classify()</span><br><span class="line">s2 = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">s = [<span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;EA&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;DE&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;3B&#x27;</span>, <span class="string">&#x27;BE&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;D4&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;B6&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;B7&#x27;</span>, <span class="string">&#x27;AF&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;7F&#x27;</span>, <span class="string">&#x27;CF&#x27;</span>]</span><br><span class="line">flag = <span class="string">&#x27;swpuctf&#123;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    first_part = <span class="built_in">int</span>(s[<span class="number">3</span> + <span class="number">4</span> * i] + s[<span class="number">2</span> + <span class="number">4</span> * i] + s[<span class="number">1</span> + <span class="number">4</span> * i] + s[<span class="number">4</span> * i], <span class="number">16</span>)</span><br><span class="line">    second_part = s2[i * <span class="number">4</span>:i * <span class="number">4</span> + <span class="number">4</span>]</span><br><span class="line">    res = check_first_part(second_part, first_part, d)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        flag += res</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    flag += res + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">flag += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#swpuctf&#123;we18-l8co-m1e4-58to-swpu&#125;</span></span><br></pre></td></tr></table></figure><h2 id="EasiestRe（双进程-自修改-背包加密）"><a href="#EasiestRe（双进程-自修改-背包加密）" class="headerlink" title="EasiestRe（双进程+自修改+背包加密）"></a>EasiestRe（双进程+自修改+背包加密）</h2><p><a href="https://www.nssctf.cn/problem/40">[SWPU 2019]EasiestRe | NSSCTF</a></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h4><p>进来先看到IsDebuggerPresent，运行一下发现和直接打开的结果不一样，双进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( IsDebuggerPresent() )  <span class="comment">//调试器进程</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">if</span> ( CreateProcessA(Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )  <span class="comment">//正常进程</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  PVOID lpBaseAddress; <span class="comment">// [esp+18h] [ebp-558h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+1Fh] [ebp-551h]</span></span><br><span class="line">  DWORD dwContinueStatus; <span class="comment">// [esp+20h] [ebp-550h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> <span class="title">DebugEvent</span>;</span> <span class="comment">// [esp+28h] [ebp-548h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// [esp+8Fh] [ebp-4E1h]</span></span><br><span class="line">  CONTEXT Context; <span class="comment">// [esp+94h] [ebp-4DCh] BYREF</span></span><br><span class="line">  HANDLE hThread; <span class="comment">// [esp+364h] [ebp-20Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+368h] [ebp-208h]</span></span><br><span class="line">  SIZE_T NumberOfBytesRead[<span class="number">3</span>]; <span class="comment">// [esp+370h] [ebp-200h] BYREF</span></span><br><span class="line">  SIZE_T NumberOfBytesWritten[<span class="number">3</span>]; <span class="comment">// [esp+37Ch] [ebp-1F4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> Buffer[<span class="number">60</span>]; <span class="comment">// [esp+388h] [ebp-1E8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v15[<span class="number">40</span>]; <span class="comment">// [esp+3C4h] [ebp-1ACh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16[<span class="number">16</span>]; <span class="comment">// [esp+3ECh] [ebp-184h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> <span class="title">StartupInfo</span>;</span> <span class="comment">// [esp+3FCh] [ebp-174h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> <span class="title">ProcessInformation</span>;</span> <span class="comment">// [esp+448h] [ebp-128h] BYREF</span></span><br><span class="line">  CHAR Filename[<span class="number">267</span>]; <span class="comment">// [esp+460h] [ebp-110h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;ProcessInformation, <span class="number">0</span>, <span class="keyword">sizeof</span>(ProcessInformation));</span><br><span class="line">  j__memset(&amp;StartupInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(StartupInfo));</span><br><span class="line">  v16[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v16[<span class="number">1</span>] = <span class="number">0x83</span>;</span><br><span class="line">  v16[<span class="number">2</span>] = <span class="number">0x7D</span>;</span><br><span class="line">  v16[<span class="number">3</span>] = <span class="number">0xF8</span>;</span><br><span class="line">  v16[<span class="number">4</span>] = <span class="number">0x18</span>;</span><br><span class="line">  v16[<span class="number">5</span>] = <span class="number">0x7D</span>;</span><br><span class="line">  v16[<span class="number">6</span>] = <span class="number">0x11</span>;</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v15[<span class="number">1</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">2</span>] = <span class="number">0xB6</span>;</span><br><span class="line">  v15[<span class="number">3</span>] = <span class="number">0x55</span>;</span><br><span class="line">  v15[<span class="number">4</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">5</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">6</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">  v15[<span class="number">8</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">9</span>] = <span class="number">4</span>;</span><br><span class="line">  v15[<span class="number">10</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v15[<span class="number">11</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">12</span>] = <span class="number">0xAF</span>;</span><br><span class="line">  v15[<span class="number">13</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">14</span>] = <span class="number">0xFC</span>;</span><br><span class="line">  v15[<span class="number">15</span>] = <span class="number">0x33</span>;</span><br><span class="line">  v15[<span class="number">16</span>] = <span class="number">0xD2</span>;</span><br><span class="line">  v15[<span class="number">17</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">18</span>] = <span class="number">0x75</span>;</span><br><span class="line">  v15[<span class="number">19</span>] = <span class="number">0xF8</span>;</span><br><span class="line">  v15[<span class="number">20</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">21</span>] = <span class="number">0xB6</span>;</span><br><span class="line">  v15[<span class="number">22</span>] = <span class="number">0x4D</span>;</span><br><span class="line">  v15[<span class="number">23</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">24</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">25</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">26</span>] = <span class="number">0xC</span>;</span><br><span class="line">  v15[<span class="number">27</span>] = <span class="number">0x89</span>;</span><br><span class="line">  v15[<span class="number">28</span>] = <span class="number">0x14</span>;</span><br><span class="line">  v15[<span class="number">29</span>] = <span class="number">0x88</span>;</span><br><span class="line">  j__memset(Buffer, <span class="number">0</span>, <span class="number">0x32u</span>);</span><br><span class="line">  NumberOfBytesWritten[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( IsDebuggerPresent() )                    <span class="comment">// 调试器进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetStartupInfoA(&amp;StartupInfo);</span><br><span class="line">    GetModuleFileNameA(<span class="number">0</span>, Filename, <span class="number">0x104u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( CreateProcessA(Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )<span class="comment">// 创建新进程</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="number">1</span>;</span><br><span class="line">LABEL_6:</span><br><span class="line">      <span class="keyword">while</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">        WaitForDebugEvent(&amp;DebugEvent, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        <span class="keyword">switch</span> ( DebugEvent.dwDebugEventCode )  <span class="comment">// 处理调试事件</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">            <span class="keyword">if</span> ( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode == <span class="number">0x80000003</span> )<span class="comment">// 遇到调试断点</span></span><br><span class="line">            &#123;</span><br><span class="line">              v8 = <span class="number">1</span>;                           <span class="comment">// 继续执行程序，跳过当前异常</span></span><br><span class="line">              dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">              lpBaseAddress = DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress;<span class="comment">// 保存异常的地址（即断点地址）</span></span><br><span class="line">              ReadProcessMemory(                <span class="comment">// 读取 35 字节的内存数据到buffer里</span></span><br><span class="line">                ProcessInformation.hProcess,</span><br><span class="line">                DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,</span><br><span class="line">                Buffer,</span><br><span class="line">                <span class="number">0x23u</span>,</span><br><span class="line">                NumberOfBytesRead);</span><br><span class="line">              <span class="keyword">if</span> ( NumberOfBytesRead[<span class="number">0</span>] )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">35</span> &amp;&amp; Buffer[i] == <span class="number">0x90</span>; ++i )<span class="comment">// 检查nop</span></span><br><span class="line">                  ;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> ( i == <span class="number">1</span> )</span><br><span class="line">                v8 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v8 )                         <span class="comment">// v8非0则继续执行，v8为0则跳转到dwContinueStatus = 0x80010001;</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( i )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    Context.ContextFlags = <span class="number">65543</span>;</span><br><span class="line">                    hThread = OpenThread(<span class="number">0x1FFFFFu</span>, <span class="number">0</span>, DebugEvent.dwThreadId);</span><br><span class="line">                    <span class="keyword">if</span> ( !GetThreadContext(hThread, &amp;Context) )</span><br><span class="line">                      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">                    ++Context.Eip;</span><br><span class="line">                    <span class="keyword">if</span> ( SetThreadContext(hThread, &amp;Context) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">                      CloseHandle(hThread);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">LABEL_31:</span><br><span class="line">                    ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x80010001</span>);</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">7</span>:                       <span class="comment">// 将v16的数据写入lpBaseAddress</span></span><br><span class="line">                                                <span class="comment">// 然后读取lpBaseAddress 处的数据并存储在 Buffer 中</span></span><br><span class="line">                                                <span class="comment">// 成功写入 7 字节数据则继续执行程序</span></span><br><span class="line">                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="number">7u</span>, NumberOfBytesWritten);</span><br><span class="line">                    <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">7</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="number">7u</span>, NumberOfBytesRead);</span><br><span class="line">                      dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">30</span>:                      <span class="comment">// v15 中的 30 字节数据写入lpBaseAddress</span></span><br><span class="line">                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v15, <span class="number">0x1Eu</span>, NumberOfBytesWritten);</span><br><span class="line">                    <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">30</span> )</span><br><span class="line">                      dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">default</span>:                      <span class="comment">// i！=4，5，7，30</span></span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              dwContinueStatus = <span class="number">0x80010001</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">            v5 = <span class="number">0</span>;</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">LABEL_33:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinueStatus);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_F53922();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sub-F58A40"><a href="#sub-F58A40" class="headerlink" title="sub_F58A40"></a>sub_F58A40</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text:00F58AF8                 int     3               ; Trap to Debugger</span><br><span class="line">text:00F58AF9                 nop</span><br><span class="line">text:00F58AFA                 nop</span><br><span class="line">text:00F58AFB                 nop</span><br><span class="line">text:00F58AFC                 nop</span><br><span class="line">text:00F58AFD                 nop</span><br><span class="line">text:00F58AFE                 nop</span><br><span class="line">text:00F58AFF                 push    offset aYouAreTooShort ; &quot;you are too short!&quot;</span><br><span class="line">text:00F58B04                 call    printf</span><br></pre></td></tr></table></figure><p>根据上面的分析，遇到int 3会写入v16 7字节的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:                      </span><br><span class="line">                   WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="number">7u</span>, NumberOfBytesWritten);</span><br><span class="line">                   <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">7</span> )</span><br><span class="line">                   &#123;</span><br><span class="line">                     ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="number">7u</span>, NumberOfBytesRead);</span><br><span class="line">                     dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">goto</span> LABEL_33;</span><br></pre></td></tr></table></figure><p>paste data就行</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501051651130.png" alt="image"></p><h4 id="sub-F587E0"><a href="#sub-F587E0" class="headerlink" title="sub_F587E0"></a>sub_F587E0</h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501080247609.png" alt="1736275603403.png"></p><p>30字节的有点长，idapython吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取的字节位置范围：从 0xF58C45 到 0xF58D10</span></span><br><span class="line">start_addr = <span class="number">0x00F58C45</span>  <span class="comment"># 起始地址</span></span><br><span class="line">end_addr = <span class="number">0x00F58D10</span>    <span class="comment"># 结束地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储字节的列表</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历指定地址范围</span></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(start_addr, end_addr + <span class="number">1</span>):  <span class="comment"># 按字节逐个读取</span></span><br><span class="line">    byte = idaapi.get_byte(addr)  <span class="comment"># 获取当前地址的字节</span></span><br><span class="line">    <span class="keyword">if</span> byte != -<span class="number">1</span>:  <span class="comment"># 确保字节有效</span></span><br><span class="line">        data.append(byte)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只提取存储到内存中的字节（每条 mov 指令的最后一个字节）</span></span><br><span class="line">stored_values = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data) - <span class="number">6</span>, <span class="number">7</span>):  <span class="comment"># 每条指令为 7 字节，确保有足够字节</span></span><br><span class="line">    stored_values.append(data[i + <span class="number">6</span>])  <span class="comment"># 存储每条 mov 指令的最后一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印提取的存储字节值作为数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stored values in array:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[&quot;</span> + <span class="string">&quot;, &quot;</span>.join(<span class="string">&quot;0x&#123;:02X&#125;&quot;</span>.<span class="built_in">format</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> stored_values) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[0x90, 0x0F, 0xB6, 0x55, 0xF7, 0x8B, 0x45, 0x08, 0x8B, 0x04, 0x90, 0x0F, 0xAF, 0x45, 0xFC, 0x33, 0xD2, 0xF7, 0x75, 0xF8, 0x0F, 0xB6, 0x4D, 0xF7, 0x8B, 0x45, 0x0C, 0x89, 0x14，0x88]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span>*</span><br><span class="line">data=[<span class="number">0x90</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x55</span>, <span class="number">0xF7</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x08</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x90</span>, <span class="number">0x0F</span>, <span class="number">0xAF</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x33</span>, <span class="number">0xD2</span>, <span class="number">0xF7</span>, <span class="number">0x75</span>, <span class="number">0xF8</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x4D</span>, <span class="number">0xF7</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x0C</span>, <span class="number">0x89</span>, <span class="number">0x14</span>,<span class="number">0x88</span>]</span><br><span class="line">b=<span class="number">0x0F58824</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    ida_bytes.patch_byte(b+i,data[i])</span><br></pre></td></tr></table></figure><p>修完</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __cdecl <span class="title function_">sub_F587E0</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 i; <span class="comment">// [esp+3h] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8u</span>; ++i )</span><br><span class="line">    *(a2 + <span class="number">4</span> * i) = <span class="number">41</span> * *(a1 + <span class="number">4</span> * i) % <span class="number">0x1EBu</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要个in3+3个nop，根据主函数分析不管它</p><h4 id="sub-F583C0"><a href="#sub-F583C0" class="headerlink" title="sub_F583C0"></a>sub_F583C0</h4><p>in3+4个nop，对应case4，main里的处理是eip+1跳过异常</p><p><del>在int3那里下个断点，动调一下看看程序咋处理这里的</del></p><p>忘了双线程了，apply patch to programm，然后运行一下exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:0069842B                               ;   __try &#123; // __except at loc_69845A</span><br><span class="line">.text:0069842B C7 45 FC 00 00 00 00          mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00698432 CC                            int     3                               ; Trap to Debugger</span><br><span class="line">.text:00698433 90                            nop</span><br><span class="line">.text:00698434 90                            nop</span><br><span class="line">.text:00698435 90                            nop</span><br><span class="line">.text:00698436 90                            nop</span><br><span class="line">....</span><br><span class="line">.text:0069845A                               loc_69845A:                             ; DATA XREF: .rdata:stru_7783E8↓o</span><br><span class="line">.text:0069845A                               ;   __except(loc_698454) // owned by 69842B</span><br><span class="line">.text:0069845A 8B 65 E8                      mov     esp, [ebp+ms_exc.old_esp]</span><br></pre></td></tr></table></figure><p>这里直接跳到了loc_69845A，有点像密文密钥之类的，同样的我们keypatch in3 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 3 -&gt; jmp loc_69845A</span><br></pre></td></tr></table></figure><p>然后就是解密了，背包加密网上随便找个脚本改改</p><p>swpuctf{y0u_@re_s0_coo1}</p><h2 id="zer0pts-2020-vmlog（vm）"><a href="#zer0pts-2020-vmlog（vm）" class="headerlink" title="[zer0pts 2020]vmlog（vm）"></a>[zer0pts 2020]vmlog（vm）</h2><p><a href="https://www.nssctf.cn/problem/61">[zer0pts 2020]vmlog | NSSCTF</a></p><p>拿到vm.py和log.txt，vm.py实现了一个自定义的指令集，行为取决于program变量和输入。做vm题的常规思路就是把汇编打印出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> program <span class="keyword">import</span> program</span><br><span class="line"></span><br><span class="line">reg = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">pc = <span class="number">0</span></span><br><span class="line">buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(program)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> pc &lt; <span class="built_in">len</span>(program):</span><br><span class="line">    op = program[pc]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        reg += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> add reg 1 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        reg -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> sub reg 1 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        reg *= mem[p]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mul reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;%&quot;</span>:</span><br><span class="line">        reg = mem[p] % reg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mod reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        reg = mem[p]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>,p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;s&quot;</span>:</span><br><span class="line">        mem[p] = reg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov mem[<span class="subst">&#123;p&#125;</span>] reg #mem=<span class="subst">&#123;mem&#125;</span>,p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        p = (p + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> inc p 1 #p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        p = (p - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> dec p 1 #p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">        a = sys.stdin.buffer.read(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> getchar&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">            reg = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov, reg 0 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            reg += <span class="built_in">ord</span>(a)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov, reg <span class="subst">&#123;<span class="built_in">ord</span>(a)&#125;</span> #input #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;p&quot;</span>:</span><br><span class="line">        buf += <span class="built_in">str</span>(reg)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> buf+=str(reg)&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> cmp reg 0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg == <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">                pc += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> jz &quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> cmp reg 0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg != <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">                pc -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> jnz &quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;M&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(mem)</span><br><span class="line"></span><br><span class="line">    pc += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="comment">#print(f&quot;PC: &#123;pc&#125;, OP: &#123;op&#125;, REG: &#123;reg&#125;, MEM: &#123;mem&#125;, P: &#123;p&#125;, BUF: &#x27;&#123;buf&#125;&#x27;&quot;)</span></span><br></pre></td></tr></table></figure><p>给的log.txt是program+运行日志</p><p>自己再定义一个program.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program = <span class="string">&quot;M+s+&gt;s&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[s&lt;&lt;l&gt;*&lt;s&gt;&gt;l-]&lt;&lt;l-s&gt;l*-s*-s*-s*-s*-s*-s&gt;l*+++++s*-----s****s&gt;&gt;l+s[Ml-s&lt;&lt;l&gt;,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s&gt;&gt;l&lt;s&gt;l+s&lt;l]&gt;l]&lt;&lt;lp&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M+s+&gt;s&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[s&lt;&lt;l&gt;*&lt;s&gt;&gt;l-]&lt;&lt;l-s</span><br><span class="line">&gt;l*-s*-s*-s*-s*-s*-s</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>M</code></strong>：打印初始内存状态，便于调试。</p></li><li><p><code>s</code> 和 <code>l</code></p><p>：将值存储到内存或加载到寄存器。</p><ul><li><code>mem[0]</code> 被设置为一个大值（262−12^{62} - 1262−1），通常用于模运算。</li><li><code>mem[1]</code> 被设置为 2（基数 <code>r</code>）。</li><li><code>mem[2]</code> 被设置为 1（初始哈希值 <code>h</code>）。</li></ul></li><li><p>推断</p><ul><li>这种初始化方式非常典型，常见于滚动哈希算法的实现。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s</span><br></pre></td></tr></table></figure><ul><li><strong><code>[ ,</code></strong>：开始读取输入字符。</li><li><strong><code>&lt;&lt;\*</code></strong>：当前哈希值 <code>h</code> 加上输入字符后，乘以基数 <code>r</code>。</li><li><strong><code>%</code></strong>：对模数 <code>m</code> 取模，防止哈希值溢出。</li><li>推断<ul><li>这是滚动哈希算法的核心公式： h=(h+input)⋅rmod  mh = (h + \text{input}) \cdot r \mod mh=(h+input)⋅rmodm</li></ul></li></ul><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ml-s&lt;&lt;l&gt;,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s&gt;&gt;l&lt;s&gt;l+s&lt;l]&gt;l]&lt;&lt;lp</span><br></pre></td></tr></table></figure><ul><li>循环核心<ul><li><code>[Ml-s&lt;&lt;l&gt;</code>：开始新一轮的哈希值更新，标志位控制。</li><li><code>,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s</code>：对每个输入字符进行滚动哈希更新。</li><li><code>&gt;l+s&lt;l]</code>：设置标志位，继续下一轮输入处理。</li></ul></li><li>推断<ul><li>滚动哈希的本质是对输入字符的逐个处理，结合乘法、加法和模运算。</li></ul></li></ul><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;lp</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>输出最终的哈希值 <code>h</code>（存储在 <code>mem[2]</code>）。</li></ul></li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\LeStoreDownload\webpage\CTF\nssctf\[zer0pts 2020]vmlog\tmp\log.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    prev_h = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            arr = <span class="built_in">eval</span>(l.strip())</span><br><span class="line">            <span class="keyword">if</span> arr[<span class="number">4</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> prev_h:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                        <span class="keyword">if</span> (prev_h + i) * arr[<span class="number">1</span>] % arr[<span class="number">0</span>] == arr[<span class="number">2</span>]:</span><br><span class="line">                            flag += <span class="built_in">chr</span>(i)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                prev_h = arr[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#zer0pts&#123;3asy_t0_f0110w_th3_l0g?&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识IDApython&amp;IDC</title>
      <link href="/2024/12/30/%E5%88%9D%E8%AF%86IDApython/"/>
      <url>/2024/12/30/%E5%88%9D%E8%AF%86IDApython/</url>
      
        <content type="html"><![CDATA[<h2 id="IDApython-amp-IDC"><a href="#IDApython-amp-IDC" class="headerlink" title="IDApython&amp;IDC"></a>IDApython&amp;IDC</h2><p>IDApython官方文档：<a href="https://docs.hex-rays.com/developer-guide/idapython">IDAPython | Hex-Rays Docs</a></p><p>IDC官方文档：<a href="https://docs.hex-rays.com/developer-guide/idc">IDC | Hex-Rays Docs</a></p><h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><h4 id="1-IDC"><a href="#1-IDC" class="headerlink" title="1.IDC"></a>1.IDC</h4><p>与IDA命令行进行交互的模块，提供了很多IDA中指令相关的函数。</p><ul><li><strong><code>idc.get_name(ea)</code></strong>：获取地址 <code>ea</code> 处的名称。</li><li><strong><code>idc.get_func_name(ea)</code></strong>：获取函数地址处的函数名称。</li><li><strong><code>idc.set_name(ea, name)</code></strong>：为地址 <code>ea</code> 设置一个新的名称。</li><li><strong><code>idc.add_entry(ea, name, start, end)</code></strong>：在 <code>ea</code> 处添加一个入口点。</li><li><strong><code>idc.get_func(ea)</code></strong>：获取 <code>ea</code> 处的函数结构。</li></ul><h4 id="2-IDAAPI"><a href="#2-IDAAPI" class="headerlink" title="2.IDAAPI"></a>2.IDAAPI</h4><p>与 IDA 的核心 API 交互的主要模块。包括了对 IDA 核心对象的访问，涵盖了地址、函数、节等许多底层操作。</p><ul><li><p><strong><code>idaapi.get_func(ea)</code></strong>：返回地址 <code>ea</code> 处的函数对象。</p></li><li><p><strong><code>idaapi.get_flags(ea)</code></strong>：返回地址 <code>ea</code> 的标志，表示它是代码、数据还是其他类型。</p></li><li><p><strong><code>idaapi.create_data(ea, size, type)</code></strong>：在地址 <code>ea</code> 处创建数据。</p></li><li><p><strong><code>idaapi.get_strlit_contents(ea)</code></strong>：获取 <code>ea</code> 处的字符串内容。</p></li><li><p><strong><code>idaapi.add_func(ea)</code></strong>：将地址 <code>ea</code> 添加为一个函数。</p></li></ul><h4 id="3-IDAUTILS"><a href="#3-IDAUTILS" class="headerlink" title="3.IDAUTILS"></a>3.IDAUTILS</h4><p>工具函数，帮助在反汇编中自动化和简化分析过程。</p><ul><li><p><strong><code>idautils.Functions(start, end)</code></strong>：遍历在 <code>start</code> 到 <code>end</code> 地址范围内的所有函数。</p></li><li><p><strong><code>idautils.DecodeInstruction(ea)</code></strong>：解码地址 <code>ea</code> 处的指令。</p></li><li><p><strong><code>idautils.FindBinary(start, end, pattern, flags)</code></strong>：在指定范围内查找与模式匹配的二进制数据。</p></li><li><p><strong><code>idautils.Heads(start, end)</code></strong>：遍历地址范围内的所有指令地址。</p></li></ul><h4 id="4-ida-bytes"><a href="#4-ida-bytes" class="headerlink" title="4.ida_bytes"></a>4.ida_bytes</h4><p><code>ida_bytes</code> 提供了对内存区域字节级别操作的函数。</p><ul><li><strong><code>ida_bytes.get_byte(ea)</code></strong>：获取 <code>ea</code> 处的一个字节</li><li><strong><code>ida_bytes.get_word(ea)</code></strong>：获取 <code>ea</code> 处的一个字.</li><li><strong><code>ida_bytes.get_dword(ea)</code></strong>：获取 <code>ea</code> 处的一个双字。</li></ul><h4 id="5-ida-struct"><a href="#5-ida-struct" class="headerlink" title="5.ida_struct"></a>5.ida_struct</h4><p><code>ida_struct</code> 处理 IDA 中的结构体。你可以使用它来读取、创建、修改和设置结构体。</p><ul><li><p><strong><code>ida_struct.get_struc_name(struc)</code></strong>：获取结构体的名称。</p></li><li><p><strong><code>ida_struct.add_struc()</code></strong>：添加一个新的结构体。</p></li><li><p><strong><code>ida_struct.set_struc_member()</code></strong>：设置结构体成员的属性。</p></li></ul><h4 id="6-ida-diskio"><a href="#6-ida-diskio" class="headerlink" title="6.ida_diskio"></a>6.ida_diskio</h4><p><code>ida_diskio</code> 提供了与磁盘 IO 操作相关的函数，例如读取或写入文件。</p><ul><li><p><strong><code>ida_diskio.get_input_file_path()</code></strong>：获取当前输入文件的路径。</p></li><li><p><strong><code>ida_diskio.save_input_file()</code></strong>：保存当前输入文件。</p></li></ul><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="创建-删除函数"><a href="#创建-删除函数" class="headerlink" title="创建/删除函数"></a>创建/删除函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idc.add_func(<span class="number">0x401000</span>, <span class="number">0x401050</span>)  <span class="comment"># Create a function starting at 0x401000 and ending at 0x401050</span></span><br><span class="line">idc.del_func(<span class="number">0x401000</span>)  <span class="comment"># Delete the function at 0x401000</span></span><br></pre></td></tr></table></figure><h4 id="获取函数的名称"><a href="#获取函数的名称" class="headerlink" title="获取函数的名称"></a>获取函数的名称</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_func_name(ea)</span><br></pre></td></tr></table></figure><h4 id="遍历所有函数并打印其有效地址和名称"><a href="#遍历所有函数并打印其有效地址和名称" class="headerlink" title="遍历所有函数并打印其有效地址和名称"></a>遍历所有函数并打印其有效地址和名称</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions(): func_name = idc.get_func_name(func_ea); <span class="built_in">print</span>(<span class="built_in">hex</span>(func_ea), func_name)</span><br></pre></td></tr></table></figure><h4 id="列出对地址的交叉引用"><a href="#列出对地址的交叉引用" class="headerlink" title="列出对地址的交叉引用"></a>列出对地址的交叉引用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(<span class="number">0x401000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Xref to 0x401000 from <span class="subst">&#123;<span class="built_in">hex</span>(xref.frm)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="列出地址的交叉引用："><a href="#列出地址的交叉引用：" class="headerlink" title="列出地址的交叉引用："></a>列出地址的交叉引用：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsFrom(<span class="number">0x401000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Xref from 0x401000 to <span class="subst">&#123;<span class="built_in">hex</span>(xref.to)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="遍历所有交叉引用并打印"><a href="#遍历所有交叉引用并打印" class="headerlink" title="遍历所有交叉引用并打印"></a>遍历所有交叉引用并打印</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ref <span class="keyword">in</span> idautils.XrefsTo(ea):</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">hex</span>(ref.frm))</span><br></pre></td></tr></table></figure><h4 id="文本-指令搜索"><a href="#文本-指令搜索" class="headerlink" title="文本/指令搜索"></a>文本/指令搜索</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#搜索字符串</span></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索整个内存区域的字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_string</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> idautils.Strings():</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> ea:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found string at <span class="subst">&#123;<span class="built_in">hex</span>(ea)&#125;</span>: <span class="subst">&#123;ea&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 &quot;Hello&quot; 字符串</span></span><br><span class="line">search_string(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#搜索汇编指令</span></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_asm_instruction</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="comment"># 遍历整个程序的所有指令</span></span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> idautils.Heads(idc.get_segm_by_name(<span class="string">&quot;.text&quot;</span>), idc.get_segm_end(idc.get_segm_by_name(<span class="string">&quot;.text&quot;</span>))):</span><br><span class="line">        disasm = idc.GetDisasm(ea)  <span class="comment"># 获取地址处的反汇编指令</span></span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> disasm:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found instruction at <span class="subst">&#123;<span class="built_in">hex</span>(ea)&#125;</span>: <span class="subst">&#123;disasm&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 &quot;mov eax, ebx&quot; 指令</span></span><br><span class="line">search_asm_instruction(<span class="string">&quot;mov eax, ebx&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA, Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识TCP</title>
      <link href="/2024/12/27/%E5%88%9D%E8%AF%86TCP/"/>
      <url>/2024/12/27/%E5%88%9D%E8%AF%86TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="一、TCP特点"><a href="#一、TCP特点" class="headerlink" title="一、TCP特点"></a>一、TCP特点</h3><ol><li><p>面向连接的协议，在传输数据前需要建立一条可靠连接</p></li><li><p>流式协议，TCP将数据看作字节流。传输过程中数据是可以被分割为多个数据包在接收端重新组装的。</p></li><li><p>TCP通过校验和\序列号和确认应答来确保数据的可靠传输，出错回重新传输。</p></li><li><p>服务器被动连接，客户端主动连接。</p></li></ol><h3 id="二、TCP编程"><a href="#二、TCP编程" class="headerlink" title="二、TCP编程"></a>二、TCP编程</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><h5 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1.创建套接字socket()"></a>1.创建套接字socket()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"> </span><br><span class="line">功能：</span><br><span class="line">    创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">    domain：通信域，协议族</span><br><span class="line">      AF_UNIX 本地通信</span><br><span class="line">      AF_INET ipv4网络协议</span><br><span class="line">      AF_INET6 ipv6网络协议</span><br><span class="line">      AF_PACKET 底层接口</span><br><span class="line">    type：套接字的类型</span><br><span class="line">      SOCK_STREAM 流式套接字（tcp）</span><br><span class="line">      SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line">      SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line">    protocol：附加协议，如果不需要，则设置为<span class="number">0</span></span><br><span class="line"> </span><br><span class="line">返回值：</span><br><span class="line">    成功：文件描述符</span><br><span class="line">    失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-绑定套接字bind"><a href="#2-绑定套接字bind" class="headerlink" title="2.绑定套接字bind()"></a>2.绑定套接字bind()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：</span><br><span class="line">    将套接字与网络信息结构体绑定</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket的返回值</span><br><span class="line">    addr：网络信息结构体</span><br><span class="line">      通用结构体（一般不用）</span><br><span class="line">      struct sockaddr</span><br><span class="line">      网络信息结构体 sockaddr_in</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">addrlen：</span><br><span class="line">    addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure><h5 id="3-监听套接字listen"><a href="#3-监听套接字listen" class="headerlink" title="3.监听套接字listen()"></a>3.监听套接字listen()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将套接字设置为被动监听状态，这样做之后就可以接收到连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数返回值</span><br><span class="line">    backlog：允许通信连接的主机个数，一般设置为<span class="number">5</span>、<span class="number">10</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="4-接收连接accept"><a href="#4-接收连接accept" class="headerlink" title="4.接收连接accept()"></a>4.接收连接accept()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数的返回值</span><br><span class="line">    addr：接收到的客户端的信息结构体（自动填充，定义变量即可）</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，这个新的文件描述符专门与指定的客户端进行通信的）</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="5-通信recv-send"><a href="#5-通信recv-send" class="headerlink" title="5.通信recv()/send()"></a>5.通信recv()/send()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">功能：</span><br><span class="line">    接收数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符</span><br><span class="line">客户端：socket函数的返回值</span><br><span class="line">服务器：accept函数的返回值</span><br><span class="line">    buf：保存接收到的数据</span><br><span class="line">    len：buf的长度</span><br><span class="line">    flags：标志位</span><br><span class="line">      <span class="number">0</span> 阻塞</span><br><span class="line">      MSG_DONTWAIT 非阻塞</span><br><span class="line">返回值：</span><br><span class="line">    成功：接收的字节数</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line">如果发送端关闭文件描述符或者关闭进程，则recv函数会返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"> </span><br><span class="line">功能：</span><br><span class="line">    发送数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符</span><br><span class="line"> </span><br><span class="line">客户端：</span><br><span class="line">    socket函数的返回值</span><br><span class="line">服务器：</span><br><span class="line">    accept函数的返回值</span><br><span class="line"> </span><br><span class="line">     buf：发送的数据</span><br><span class="line">     len：buf的长度</span><br><span class="line">     flags：标志位</span><br><span class="line">       <span class="number">0</span> 阻塞</span><br><span class="line">       MSG_DONTWAIT 非阻塞</span><br><span class="line"> </span><br><span class="line">返回值：</span><br><span class="line">    成功：发送的字节数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6.关闭套接字()"></a>6.关闭套接字()</h5><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><h5 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket()"></a>1.socket()</h5><h5 id="2-connect"><a href="#2-connect" class="headerlink" title="2.connect()"></a>2.connect()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给服务器发送客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数的返回值</span><br><span class="line">    addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line">    addrlen：add的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="3-send-recv"><a href="#3-send-recv" class="headerlink" title="3.send()/recv()"></a>3.send()/recv()</h5><h5 id="4-close"><a href="#4-close" class="headerlink" title="4.close()"></a>4.close()</h5><h3 id="三、OSI模型"><a href="#三、OSI模型" class="headerlink" title="三、OSI模型"></a>三、OSI模型</h3><div class="table-container"><table><thead><tr><th>应用层</th><th>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等等</th></tr></thead><tbody><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP、等等</td></tr><tr><td>会话层</td><td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等等</td></tr><tr><td>传输层</td><td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等等</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等等</td></tr><tr><td>物理层</td><td>例如铜缆、网线、光缆、无线电等等</td></tr></tbody></table></div><p><img src="C:\Users\zmycm\AppData\Roaming\Typora\typora-user-images\image-20241124204619077.png" alt="image-20241124204619077"></p><h2 id="DTLS"><a href="#DTLS" class="headerlink" title="DTLS"></a>DTLS</h2><h3 id="1-1DTLS特点作用"><a href="#1-1DTLS特点作用" class="headerlink" title="1.1DTLS特点作用"></a>1.1DTLS特点作用</h3><p><strong>DTLS</strong>: 是一种面向<strong>无连接</strong>的协议，<strong>基于 UDP</strong>，<strong>作用</strong>为给UDP提供端到端的安全通道，就像SSL/TLS对TCP的作用一样。</p><p>SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。</p><p>没用到，用到再来补充</p>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86汇编&amp;内联汇编</title>
      <link href="/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h2 id="X86汇编学习"><a href="#X86汇编学习" class="headerlink" title="X86汇编学习"></a>X86汇编学习</h2><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>CPU控制整个计算机运作和运算。要想让CPU工作，就需要向它提供<strong>指令</strong>和<strong>数据</strong>。</p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><h5 id="（1）-汇编指令"><a href="#（1）-汇编指令" class="headerlink" title="（1）.汇编指令"></a>（1）.汇编指令</h5><p>直接被CPU执行的指令</p><h5 id="（2）-伪指令"><a href="#（2）-伪指令" class="headerlink" title="（2）.伪指令"></a>（2）.伪指令</h5><p>指导汇编器工作的指令，不生成机械码。</p><ul><li>段定义指令：如SEGMENT、ENDS，用于定义和结束一个段。</li><li>数据定义指令：如DB、DW，用于定义字节或字数据。</li><li>常量定义指令：如EQU，用于定义常量。</li></ul><h5 id="3-符号指令"><a href="#3-符号指令" class="headerlink" title="(3).符号指令"></a>(3).符号指令</h5><p>用于标识变量、常量、代码段等，在汇编过程中被替换为具体的地址或值。它们没有对应的机器码。</p><ul><li><p><strong>标签</strong>：用于标识代码中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">LABEL</span>: ; 定义一个标签<span class="selector-tag">LABEL</span></span><br></pre></td></tr></table></figure></li><li><p><strong>宏定义</strong>：如<code>MACRO</code>，用于定义宏，简化代码编写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYMACRO MACRO ; 宏定义内容 ENDM</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-CPU对存储器的读写"><a href="#3-CPU对存储器的读写" class="headerlink" title="3.CPU对存储器的读写"></a>3.CPU对存储器的读写</h4><ol><li>存储单元的地址</li><li>控制信息</li><li>读或者写的数据</li></ol><h4 id="4-地址总线"><a href="#4-地址总线" class="headerlink" title="4.地址总线"></a>4.地址总线</h4><p>CPU通过地址总线来<strong>指定存储器单元</strong>。</p><p>一个CPU有N根地址线，则它的地址总线宽度为N，最多可以寻找2的N次方给内存单元。</p><p>CPU通过地址总线传入存储器的必须是一个内存单元的<strong>物理地址</strong>。</p><h4 id="5-数据总线"><a href="#5-数据总线" class="headerlink" title="5.数据总线"></a>5.数据总线</h4><p>CPU与内存或其他器件之间<strong>数据传送</strong>是通过数据总线进行的。</p><h4 id="6-控制总线"><a href="#6-控制总线" class="headerlink" title="6.控制总线"></a>6.控制总线</h4><p>CPU<strong>对外部器件的控制</strong>是通过控制总线进行的。</p><h4 id="7-内存地址空间"><a href="#7-内存地址空间" class="headerlink" title="7.内存地址空间"></a>7.内存地址空间</h4><p>8086CPU地址总线宽度为20，可以定位2的20次方个内存单元，那么内存地址空间为1MB。</p><h3 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h3><h4 id="（一）、通用寄存器"><a href="#（一）、通用寄存器" class="headerlink" title="（一）、通用寄存器"></a>（一）、通用寄存器</h4><h5 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="1.数据寄存器"></a>1.数据寄存器</h5><h6 id="（1）作为完整的32位数据寄存器"><a href="#（1）作为完整的32位数据寄存器" class="headerlink" title="（1）作为完整的32位数据寄存器"></a>（1）作为完整的32位数据寄存器</h6><ul><li>EAX，EBX，ECX，EDX</li></ul><h6 id="（2）下半部分作为16位寄存器"><a href="#（2）下半部分作为16位寄存器" class="headerlink" title="（2）下半部分作为16位寄存器"></a>（2）下半部分作为16位寄存器</h6><ul><li>AX：累加器</li><li>BX：基址寄存器</li><li>CX：计数寄存器</li><li>DX：数据寄存器</li></ul><h6 id="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"><a href="#（3）16位寄存器的下半部分和上半部分再作为8位寄存器" class="headerlink" title="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"></a>（3）16位寄存器的下半部分和上半部分再作为8位寄存器</h6><ul><li>AH,AL,BLH,BL</li><li>CH,CL,DH,DL</li></ul><h5 id="2-指针寄存器"><a href="#2-指针寄存器" class="headerlink" title="2.指针寄存器"></a>2.指针寄存器</h5><ul><li>指令指针（IP）</li><li>堆栈指针（SP）</li><li>基本指针（BP）</li></ul><h5 id="3-索引寄存器"><a href="#3-索引寄存器" class="headerlink" title="3.索引寄存器"></a>3.索引寄存器</h5><ul><li>源索引（SI）</li><li>DI</li></ul><h5 id="4-数据寄存器"><a href="#4-数据寄存器" class="headerlink" title="4.数据寄存器"></a>4.数据寄存器</h5><h4 id="（二）、控制寄存器"><a href="#（二）、控制寄存器" class="headerlink" title="（二）、控制寄存器"></a>（二）、控制寄存器</h4><p>将32位指令指针寄存器和32位标志寄存器组合。</p><h5 id="通用标志位"><a href="#通用标志位" class="headerlink" title="通用标志位"></a>通用标志位</h5><ul><li><strong>溢出标志（OF）</strong> -<u>有符号</u>算术运算后数据的高阶位（最左位）的溢出。</li><li><strong>方向标记（DF）</strong> -DF值为0时，字符串操作为从左至右的方向；当DF值为1时，字符串操作为从右至左的方向。</li><li><strong>中断标志（IF）</strong> -当值为0时，它禁用外部中断，而当值为1时，它使能中断。</li><li><strong>陷阱标志（TF）</strong> -允许在单步模式下设置处理器的操作。我们使用的DEBUG程序设置了陷阱标志，因此我们可以一次逐步执行一条指令。</li><li><strong>符号标志（SF）</strong> -正结果将SF的值清除为0，负结果将其设置为1。</li><li><strong>零标志（ZF）</strong> -非零结果将零标志清零，零结果将其清零。</li><li><strong>辅助进位标志（AF）</strong> -包含经过算术运算后从位3到位4的进位；用于专业算术。当1字节算术运算引起从第3位到第4位的进位时，将设置AF。</li><li><strong>奇偶校验标志（PF）</strong> -偶数个1位将奇偶校验标志清为0，奇数个1位将奇偶校验标志清为1。</li><li><strong>进位标志（CF）</strong> -在算术运算后，它包含一个高位（最左边）的0或1进位。</li></ul><h4 id="（三）、段寄存器"><a href="#（三）、段寄存器" class="headerlink" title="（三）、段寄存器"></a>（三）、段寄存器</h4><ul><li><strong>CS</strong>：<u><strong>代码段寄存器</strong></u>，包含当前正在执行的代码的段基址。</li><li><strong>DS</strong>：<strong><u>数据段寄存器</u></strong>，通常包含程序正在操作的数据的段基址。</li><li><strong>SS</strong>：<strong><u>堆栈段寄存器</u></strong>，包含当前堆栈的段基址。</li><li><strong>ES</strong>：<strong><u>附加段寄存器</u></strong>，用于存储其他数据段的基址。</li><li><strong>FS</strong></li><li><strong>GS</strong></li></ul><h4 id="（四）8086CPU给出物理地址的方法"><a href="#（四）8086CPU给出物理地址的方法" class="headerlink" title="（四）8086CPU给出物理地址的方法"></a>（四）8086CPU给出物理地址的方法</h4><p><strong>物理地址=段地址x16+偏移地址</strong></p><p>用两个16位地址（段地址、偏移地址）合成一个20位物理地址</p><p>段地址 x 16 是十六进制<strong>段地址数据左移一位</strong></p><h3 id="（三）、内存和寻址"><a href="#（三）、内存和寻址" class="headerlink" title="（三）、内存和寻址"></a>（三）、内存和寻址</h3><h4 id="段分布"><a href="#段分布" class="headerlink" title="段分布"></a>段分布</h4><ul><li><strong>text</strong>: 存放的是二进制机器码，用于存储程序中已初始化的全局变量和静态变量，只读</li><li><strong>.data</strong>: 用于存储程序中已初始化的全局变量和静态变量。非默认值</li><li><strong>.bss</strong>：存放未初始化的全局变量，或者默认初始化的全局变量。这一部分在二进制文件中不占硬盘空间，即不会真实存储这些为初始化的变量，而是在程序加载到内存时再分配。当然肯定需要有个标识，告诉该怎么分配内存</li><li><strong>.rodata</strong>：存放只读数据，如常量数据</li></ul><h4 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h4><p>.DATA声明静态数据区</p><p><strong>在汇编中只有一维数组</strong>，只有没有二维和多维数组。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li><strong>立即寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 123 ; rax = 123</span><br></pre></td></tr></table></figure><ul><li><strong>寄存器寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rax, rbx ; rax = rax + rbx</span><br></pre></td></tr></table></figure><ul><li><strong>直接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [someVariable] ; eax = contents of memory at address someVariable</span><br></pre></td></tr></table></figure><ul><li><strong>间接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx] ; eax = contents of memory at address stored in rbx</span><br></pre></td></tr></table></figure><ul><li><strong>基址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+4] ; eax = contents of memory at address (rbx + 4)</span><br></pre></td></tr></table></figure><ul><li><strong>索引寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+rcx*4] ; eax = contents of memory at address (rbx + rcx*4)</span><br></pre></td></tr></table></figure><ul><li><strong>基址变址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+rcx+4] ; eax = contents of memory at address (rbx + rcx + 4)</span><br></pre></td></tr></table></figure><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。</p><p>它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt="img"></p><h3 id="（五）、指令"><a href="#（五）、指令" class="headerlink" title="（五）、指令"></a>（五）、指令</h3><h4 id="lea和mov指令"><a href="#lea和mov指令" class="headerlink" title="lea和mov指令"></a>lea和mov指令</h4><p>LEA指令将其第二个操作对象指定的地址放入其第一个操作对象指定的寄存器中。</p><p>MOV指令将其第二操作对象（即寄存器内容、内存内容或常量值）所引用的数据项复制到其第一操作对象（即寄存器或内存）所引用的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebx]     ; 将EBX中的地址所指向的内存中的4个字节移动到EAX中</span><br><span class="line">mov [var], ebx     ; 将EBX的内容移到内存地址var的4个字节中(注意，不加中括号的var是一个32位地址常量，加中括号才是取地址指向的内容)</span><br><span class="line">mov eax, [esi-4] ; 将内存地址ESI+(-4)上的4个字节移入EAX</span><br><span class="line">mov [esi+eax], cl ; 将CL的内容移到地址为ESI+EAX的单字节中</span><br><span class="line">mov edx, [esi+4*ebx] ; 将地址为ESI+4*EBX的4字节数据移动到EDX中</span><br></pre></td></tr></table></figure><h4 id="ADD、SUB指令"><a href="#ADD、SUB指令" class="headerlink" title="ADD、SUB指令"></a>ADD、SUB指令</h4><p>用于对字节，字和双字大小的二进制数据进行简单的加/减，即分别用于添加或减去8位，16位或32位操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;con&gt;</span><br><span class="line">sub al, ah ; AL ← AL - AH</span><br><span class="line">sub eax, 216 ; 从存储在EAX中的值中减去216</span><br></pre></td></tr></table></figure><h4 id="INC和DEC指令"><a href="#INC和DEC指令" class="headerlink" title="INC和DEC指令"></a>INC和DEC指令</h4><p>目标操作数可以是8位，16位或32位操作数。</p><p>INC指令用于将操作数加1。</p><p>DEC指令用于将操作数减1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INC EBX      ;  32-bit 寄存器 自增1</span><br><span class="line">INC DL       ;  8-bit 寄存器 自增1</span><br><span class="line">INC [count]  ;  变量count  自增1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="imul、idiv"><a href="#imul、idiv" class="headerlink" title="imul、idiv"></a>imul、idiv</h4><p>整数乘除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">imul &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;mem&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中</span><br><span class="line">imul esi, edi, 25 ; ESI → EDI * 25</span><br><span class="line"></span><br><span class="line">idiv &lt;reg32&gt;</span><br><span class="line">idiv &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中</span><br><span class="line">idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="and-or-xor指令"><a href="#and-or-xor指令" class="headerlink" title="and, or, xor指令"></a><strong>and, or, xor</strong>指令</h4><p>按位与、或和异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">and &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">and &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line">and eax, 0fH ; 清除EAX的除最后4位以外的所有位</span><br><span class="line">xor edx, edx ; 将EDX的内容设置为零</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="not、neg指令"><a href="#not、neg指令" class="headerlink" title="not、neg指令"></a>not、neg指令</h4><p>NOT 指令触发（翻转）操作对象中的所有位。其结果被称为反码。</p><p>NEG是汇编指令中的求补指令，对操作对象执行求补运算：用零减去操作对象，然后结果返回操作对象。</p><p>（将操作对象按位取反后加1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">not &lt;reg&gt;</span><br><span class="line">not &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="shl-shr指令"><a href="#shl-shr指令" class="headerlink" title="shl, shr指令"></a><strong>shl, shr</strong>指令</h4><p> 左移，右移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line">shl &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line">shl &lt;reg&gt;,&lt;cl&gt;</span><br><span class="line">shl &lt;mem&gt;,&lt;cl&gt;</span><br><span class="line"></span><br><span class="line">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）</span><br><span class="line">shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值</span><br></pre></td></tr></table></figure><h4 id="JMP及衍生"><a href="#JMP及衍生" class="headerlink" title="JMP及衍生"></a>JMP及衍生</h4><p>无条件跳转</p><div class="table-container"><table><thead><tr><th>JMP</th><th>无条件跳转指令</th></tr></thead><tbody><tr><td><strong>JC</strong></td><td>进位时跳转</td></tr><tr><td><strong>JO</strong></td><td>溢出时跳转</td></tr><tr><td><strong>JE</strong>/<strong>JZ</strong></td><td>相等/零时跳转</td></tr><tr><td><strong>JS</strong></td><td>负数时跳转</td></tr><tr><td><strong>JP</strong>/<strong>JPE</strong></td><td>奇偶校验时跳转</td></tr><tr><td></td></tr></tbody></table></div><h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><p>比较两个操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP DX, 00  ; 将DX值与0进行比较</span><br><span class="line">JE  L7      ; 如果等于，则跳转到标签L7</span><br></pre></td></tr></table></figure><h4 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h4><p>实现循环（计数型循环）</p><p>CX = CX -1</p><p>判断CX中的值，不为0则继续跳转；为0则向下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOOP    label</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="六-、调用约定"><a href="#六-、调用约定" class="headerlink" title="(六)、调用约定"></a>(六)、调用约定</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h4><p>操作系统为用户态运行的进程与硬件设备之间进行交互提供了一组接口。</p><p>实质上就是<strong><em>\</em>函数调用**</strong>，只不过调用的是<strong><em>\</em>系统函数**</strong>，处于内核态而已</p><p>在Linux中，EAX寄存器是负责传递系统调用号的。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="（一）、内联函数"><a href="#（一）、内联函数" class="headerlink" title="（一）、内联函数"></a>（一）、内联函数</h3><p>内联汇编是指在高级语言中嵌入汇编代码，，减少函数调用。</p><h3 id="（二）、内联汇编语法"><a href="#（二）、内联汇编语法" class="headerlink" title="（二）、内联汇编语法"></a>（二）、内联汇编语法</h3><h4 id="1-在-GCC-中"><a href="#1-在-GCC-中" class="headerlink" title="1. 在 GCC 中"></a>1. 在 GCC 中</h4><p>使用 <code>asm</code> 或 <code>__asm__</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly-code&quot;</span> : output : input : clobbered_registers);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, result;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;addl %%ebx, %%eax&quot;</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span>(result)           <span class="comment">// 输出约束，`a` 表示使用 EAX 寄存器</span></span><br><span class="line">    : <span class="string">&quot;a&quot;</span>(a), <span class="string">&quot;b&quot;</span>(b)         <span class="comment">// 输入约束，`b` 表示使用 EBX 寄存器</span></span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);                 <span class="comment">// 通知编译器条件码被修改</span></span><br></pre></td></tr></table></figure><h4 id="关键约束："><a href="#关键约束：" class="headerlink" title="关键约束："></a>关键约束：</h4><ul><li><strong>操作数约束</strong>：<ul><li><code>&quot;r&quot;</code>：任意寄存器</li><li><code>&quot;m&quot;</code>：内存操作数</li><li><code>&quot;i&quot;</code>：立即数</li><li><code>&quot;a&quot;</code>：EAX</li><li><code>&quot;b&quot;</code>：EBX 等</li></ul></li><li><strong>修饰符</strong>：<ul><li><code>=：</code>：表示写入输出</li><li><code>+：</code>：表示读写操作</li><li><code>&amp;：</code>：表示早期释放寄存器</li></ul></li></ul><h4 id="2-在-MSVC-中"><a href="#2-在-MSVC-中" class="headerlink" title="2. 在 MSVC 中"></a>2. 在 MSVC 中</h4><p>使用 <code>__asm</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">    mov eax, <span class="number">1</span></span><br><span class="line">    add eax, <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>, result;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, b</span><br><span class="line">        mov result, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-常用指令示例"><a href="#三-常用指令示例" class="headerlink" title="(三)常用指令示例"></a>(三)常用指令示例</h3><h4 id="1-数据传送"><a href="#1-数据传送" class="headerlink" title="1. 数据传送"></a>1. 数据传送</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 10       ; 将 10 送入 EAX 寄存器</span><br><span class="line">mov ebx, eax      ; 将 EAX 的值传给 EBX</span><br></pre></td></tr></table></figure><h4 id="2-算术运算"><a href="#2-算术运算" class="headerlink" title="2. 算术运算"></a>2. 算术运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add eax, ebx      ; EAX = EAX + EBX</span><br><span class="line">sub eax, 5        ; EAX = EAX - 5</span><br><span class="line">mul ebx           ; EAX = EAX * EBX</span><br><span class="line">div ecx           ; EAX = EAX / ECX</span><br></pre></td></tr></table></figure><h4 id="3-条件跳转"><a href="#3-条件跳转" class="headerlink" title="3. 条件跳转"></a>3. 条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, ebx      ; 比较 EAX 和 EBX</span><br><span class="line">je equal_label    ; 如果相等，则跳转到 equal_label</span><br><span class="line">jg greater_label  ; 如果大于，则跳转到 greater_label</span><br></pre></td></tr></table></figure><h4 id="4-栈操作"><a href="#4-栈操作" class="headerlink" title="4. 栈操作"></a>4. 栈操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push eax          ; 将 EAX 压入栈</span><br><span class="line">pop ebx           ; 从栈中弹出值到 EBX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
