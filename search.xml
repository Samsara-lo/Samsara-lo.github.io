<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>llvm&amp;ollvm初探</title>
      <link href="/2025/07/11/llvm/"/>
      <url>/2025/07/11/llvm/</url>
      
        <content type="html"><![CDATA[<h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><p>LLVM的核心思想是将编译器分为前端和后端两个部分，前端负责将源代码转换为中间表示LLVM Intermediate Representation （IR）（以库的形式提供接口），后端负责将中间表示转换为目标机器的汇编代码。<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111616684.png" alt=""></p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>三种表示：</p><ul><li>.ll 格式：人类可以阅读的文本。</li><li>.bc 格式：适合机器存储的二进制文件。</li><li>内存表示</li></ul><h2 id="LLVM-Pass"><a href="#LLVM-Pass" class="headerlink" title="LLVM Pass"></a>LLVM Pass</h2><blockquote><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html#the-immutablepass-class">https://llvm.org/docs/WritingAnLLVMPass.html#the-immutablepass-class</a></p></blockquote><p>Pass就是“遍历一遍IR，可以同时对它做一些操作”的意思，Pass 是 中间 IR 处理环节的主要模块。<br>llvm pass的作用：</p><ul><li>插桩</li><li>优化机器无关的代码</li></ul><h3 id="ModulePass-基于模块"><a href="#ModulePass-基于模块" class="headerlink" title="ModulePass (基于模块)"></a>ModulePass (基于模块)</h3><p>如果函数传递不需要任何模块或不可变传递，则模块传递可以使用接口的函数级传递（例如支配者）来提供检索分析结果的函数。</p><h3 id="FunctionPass-基于函数"><a href="#FunctionPass-基于函数" class="headerlink" title="FunctionPass (基于函数)"></a>FunctionPass (基于函数)</h3><h3 id="CallGraphPass-基于调用图"><a href="#CallGraphPass-基于调用图" class="headerlink" title="CallGraphPass (基于调用图)"></a>CallGraphPass (基于调用图)</h3><h3 id="LoopPass-基于循环"><a href="#LoopPass-基于循环" class="headerlink" title="LoopPass (基于循环)"></a>LoopPass (基于循环)</h3><h3 id="PASS-注册方式"><a href="#PASS-注册方式" class="headerlink" title="PASS 注册方式"></a>PASS 注册方式</h3><p>1、修改 PassRegistry.def 和 PassBuilder.cpp 文件，直接追加 Pass 定义进去。<br>2、是用插件接口进行注册</p><h3 id="LLVM-Pass-实现「指令替代混淆」"><a href="#LLVM-Pass-实现「指令替代混淆」" class="headerlink" title="LLVM Pass 实现「指令替代混淆」"></a>LLVM Pass 实现「指令替代混淆」</h3><div class="table-container"><table><thead><tr><th>步骤</th><th>操作</th></tr></thead><tbody><tr><td>注册</td><td>通过 <code>llvmGetPassPluginInfo()</code> 注册</td></tr><tr><td>遍历</td><td>遍历 <code>Function</code> / <code>BasicBlock</code></td></tr><tr><td>修改</td><td>进行 IR 控制流改造（添加跳转 / switch / 伪逻辑）</td></tr></tbody></table></div><blockquote><p>参考：<a href="https://3cly.github.io/2023/12/26/llvmpass%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2/">https://3cly.github.io/2023/12/26/llvmpass%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2/</a></p></blockquote><ol><li>Pass 的注册方式：插件式注册，使用 llvmGetPassPluginInfo() 提供插件信息给 LLVM。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="comment">//llvm 版本号环境取值</span></span><br><span class="line">          <span class="string">&quot;mba-sub&quot;</span>,              <span class="comment">//插件名字</span></span><br><span class="line">        LLVM_VERSION_STRING,  <span class="comment">//插件版本号 都是随便传</span></span><br><span class="line">          [](PassBuilder &amp;PB) &#123;   <span class="comment">// 第四个是一个回调，</span></span><br><span class="line">          <span class="comment">// 用于告诉 PassBuilder：当用户传了 &quot;mba-sub&quot; 时，就注册你自己的 MBASub Pass。</span></span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(   </span><br><span class="line">                [](StringRef Name, FunctionPassManager &amp;FPM,</span><br><span class="line">                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;mba-sub&quot;</span>) &#123;</span><br><span class="line">                    FPM.<span class="built_in">addPass</span>(<span class="built_in">MBASub</span>());</span><br><span class="line">      <span class="comment">//FPM.addPass (MBASub ()) 这行代码向函数级别 Pass 管理器 FPM 中添加了一个 MBASub Pass 的实例。</span></span><br><span class="line">    <span class="comment">// 在这里，MBASub () 表示创建了 MBASub 结构体的一个实例 (默认构造函数)，并将其添加到 Pass 管理器中</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load-pass-plugin ./libMBASub.so -passes=mba-sub &lt; input.ll &gt; output.ll</span><br></pre></td></tr></table></figure><ol><li><p>定义 Pass 本体（MBASub）<br>定义了一个结构体 <code>MBASub</code>，继承自<code>llvm::PassInfoMixin&lt;MBASub&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MBASub</span> : <span class="keyword">public</span> llvm::PassInfoMixin&lt;MBASub&gt; &#123;</span><br><span class="line">  <span class="function">llvm::PreservedAnalyses <span class="title">run</span><span class="params">(llvm::Function &amp;F, llvm::FunctionAnalysisManager &amp;)</span></span>;</span><br><span class="line">  <span class="comment">//run() 是入口，遍历函数中所有基本块</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">runOnBasicBlock</span><span class="params">(llvm::BasicBlock &amp;B)</span></span>;</span><br><span class="line">  <span class="comment">//runOnBasicBlock() 实际处理每个基本块中的指令；</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="comment">//isRequired() 返回 true 表示这个 Pass 默认启用（不是分析 Pass）。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>指令替换核心逻辑：将 a - b 替换为 (a + ~b) + 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MBASub::runOnBasicBlock</span><span class="params">(BasicBlock &amp;BB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> Inst = BB.<span class="built_in">begin</span>(); Inst != BB.<span class="built_in">end</span>(); ++Inst) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *BinOp = <span class="built_in">dyn_cast</span>&lt;BinaryOperator&gt;(Inst);</span><br><span class="line">    <span class="comment">//dyn_cast&lt;BinaryOperator&gt;：从通用 Instruction 类型动态转为二元操作类型；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!BinOp) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> Opcode = BinOp-&gt;<span class="built_in">getOpcode</span>();   <span class="comment">//getOpcode() 判断是不是 sub 指令；</span></span><br><span class="line">    <span class="keyword">if</span> (Opcode != Instruction::Sub || !BinOp-&gt;<span class="built_in">getType</span>()-&gt;<span class="built_in">isIntegerTy</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    IRBuilder&lt;&gt; <span class="built_in">Builder</span>(BinOp);         <span class="comment">//IRBuilder&lt;&gt; 用于构造 IR 新指令；</span></span><br><span class="line">    Instruction *NewValue = BinaryOperator::<span class="built_in">CreateAdd</span>(</span><br><span class="line">        Builder.<span class="built_in">CreateAdd</span>(BinOp-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>),</span><br><span class="line">                          Builder.<span class="built_in">CreateNot</span>(BinOp-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>))),</span><br><span class="line">        ConstantInt::<span class="built_in">get</span>(BinOp-&gt;<span class="built_in">getType</span>(), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ReplaceInstWithInst</span>(&amp;BB, Inst, NewValue);</span><br><span class="line">      <span class="comment">//使用 ReplaceInstWithInst() 替换原始指令。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ollvm"><a href="#ollvm" class="headerlink" title="ollvm"></a>ollvm</h2><blockquote><p><a href="https://oacia.dev/ollvm-study/">ollvm三种混淆模式的反混淆思路</a></p><h3 id="虚假控制流-BCF-Bogus-Control-Flow"><a href="#虚假控制流-BCF-Bogus-Control-Flow" class="headerlink" title="虚假控制流 BCF (Bogus Control Flow)"></a>虚假控制流 BCF (Bogus Control Flow)</h3><p><a href="https://samsara-lo.github.io/2025/06/15/ollvm-BCF%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">ollvm_BCF 源码阅读</a></p></blockquote><p>原理：</p><ul><li>虚假控制流混淆通过加入包含不透明谓词的条件跳转（永真or永假）和不可达的基本块，来干扰 IDA 的控制流分析和 F5 反汇编。</li></ul><p>反混淆：<br>1、将全局变量赋值并将 segment 设为只读。</p><ul><li>对于常规的 ollvm 的 bcf 混淆来说，bcf 的不透明谓词都是处于 .bss段 中。</li><li>Edit-&gt;Segments-&gt;Edit segment 将 Write 复选框取消勾选， .bss段 就设为只读</li></ul><p>2、d810 </p><p>3、idapython patch 不透明谓词</p><h3 id="指令替换（Instruction-Substitution）"><a href="#指令替换（Instruction-Substitution）" class="headerlink" title="指令替换（Instruction Substitution）"></a>指令替换（Instruction Substitution）</h3><p>原理：</p><ul><li>用于将程序中的原始指令替换为等效但更难理解和还原的指令序列。</li></ul><p>反混淆：<br>1、d810<br>2、GAMBA</p><h3 id="控制流平坦化（FLA）"><a href="#控制流平坦化（FLA）" class="headerlink" title="控制流平坦化（FLA）"></a>控制流平坦化（FLA）</h3><p>原理：</p><ul><li>通过一个主分发器来控制程序基本块的执行流程<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111615099.png" alt=""></li><li>序言：函数的第一个执行的基本块</li><li>主 (子) 分发器：控制程序跳转到下一个待执行的基本块</li><li>retn 块：函数出口</li><li>真实块：混淆前的基本块，程序真正执行工作的块</li><li>预处理器：跳转到主分发器</li></ul><p>各块之间的规则：</p><ol><li>函数的开始地址为序言的地址</li><li>序言的后继为主分发器</li><li>后继为主分发器的块为预处理器</li><li>后继为预处理器的块为真实块</li><li>无后继的块为retn块</li><li>剩下的为无用块</li></ol><p>反混淆：<br>1、<strong>找到真实块</strong>。手撕；idapython 通过各个块之间的联系通过一定的规则找真实块；可以用 unicorn 或 angr 得到函数的 CFG, 利用规则匹配出真实块…<br>方法多种多样，但是核心都是找到真实块，除真实块和序言块外，其余的块都是虚假块，我们需要 NOP 掉他们。<br>2、<strong>得到真实块之间的联系</strong>。模拟执行pr真机调试打断点 trace。<br>3、用跳转汇编指令将每个真实块<strong>串</strong>起来。</p><h3 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h3><p>原理：</p><ul><li>编写一个pass将其中的字符串信息使用一些加密算法进行加密，然后特定的时间进行还原。一般含有字符串混淆、函数名混淆、不在init_array解密等。</li></ul><p>反混淆：<br>（1）特征搜索：一般在so中可以直接搜索datadiv_decode，一般很多编写解密函数进行操作是这个函数，针对这种情况，一般可以通过frida hook就可以拿到解密后的值，然后进行patch<br>（2）init_array中解密：字符串解密操作在init_arrray中进行，一般可以通过模拟执行init_array，然后将解密后的字符串全部保存下来<br>（3）jni_onload解密：在jni_onload函数中进行解密操作，这时候就要进行inlinehook拿到解密后寄存器的值，也可以进行hook，也可以使用unicorn进行操作</p>]]></content>
      
      
      <categories>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
            <tag> ollvm </tag>
            
            <tag> obfuscation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的多线程</title>
      <link href="/2025/07/08/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/07/08/Linux%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="程序执行单位"><a href="#程序执行单位" class="headerlink" title="程序执行单位"></a>程序执行单位</h2><p> <strong>程序</strong>：静态代码<br> <strong>进程</strong>：对操作系统正在运行的程序的一种抽象。<strong>进程是资源分配的最基本的单位</strong>，运行一个程序会创建一个或多个进程</p><p> <strong>线程</strong>：一个进程由多个线程组成，每个线程都在进程的上下文中，共享同样代码和全局数据。</p><ul><li><p>多线程比多进程更容易共享数据，线程更高效</p><p><strong>协程</strong>：是⼀种⽐线程更加轻量级的存在。正如⼀个进程可以拥有多个线程⼀样，⼀个线程也可以拥有多个协程。</p><ul><li>最重要的是，协程不是被操作系统内核所管理，⽽完全是由程序所控制（也就是在<strong>用户态</strong>中执⾏）。</li></ul></li></ul><blockquote><p>进程是资源管理的最小单位，而线程是程序执行的最小单位</p></blockquote><h2 id="进程机制详解"><a href="#进程机制详解" class="headerlink" title="进程机制详解"></a>进程机制详解</h2><h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h3><ul><li>是<strong>资源分配</strong>的基本单位。</li><li>每个进程拥有自己<strong>独立</strong>的地址空间、代码段、数据段、文件描述符等。</li><li>进程之间<strong>不能直接访问</strong>彼此的内存空间（除非共享内存等 IPC 手段）。</li></ul><h3 id="PCB（Process-Control-Block）"><a href="#PCB（Process-Control-Block）" class="headerlink" title="PCB（Process Control Block）"></a>PCB（Process Control Block）</h3><p>每一个进程在内核中都有一个对应的数据结构来描述它的状态，称为 进程控制块（PCB，Process Control Block），在 Linux 中是 task_struct 结构体。</p><p>task_struct 中包含以下核心内容：</p><ul><li>pid: 当前进程的进程 ID。</li><li>ppid: 父进程的 ID。</li><li>state: 进程状态（运行中、就绪、阻塞、僵尸等）。</li><li>mm: 内存描述符，包含代码段、数据段、堆、栈等信息。</li><li>files: 文件描述符表。</li><li>sched: 调度信息。</li><li>signal: 信号处理表。</li><li>children: 子进程列表。</li></ul><blockquote><p>可以通过 ps, top, htop, /proc/[pid] 等接口查看这些信息。</p></blockquote><h3 id="fork-创建新进程"><a href="#fork-创建新进程" class="headerlink" title="fork() 创建新进程"></a>fork() 创建新进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br></pre></td></tr></table></figure><p>调用 fork() 后，系统会创建一个与当前进程几乎一模一样的子进程，它们拥有<strong>独立的地址空间</strong>，但初始内容一致。</p><p>区分方式：</p><ul><li>父进程：fork() 返回子进程的 PID。</li><li>子进程：fork() 返回 0。</li></ul><blockquote><p>注意：父子进程<strong>地址空间是复制的，但彼此独立</strong>（写时复制机制COW）。</p></blockquote><p>当多线程进程调用fork（）时，<strong>仅会将发起调用的线程复制到子进程中</strong>。子进程中该线程的线程ID与父进程中发起fork（）调用线程的线程ID相一致。<br>其他线程均在子进程中消失，也不会为这些线程调用清理函数以及针对线程特有数据的解构函数。</p><p><strong>fork的两个典型用法</strong><br>(1) 一个进程创建一个自身的副本</p><ul><li>网络服务器的典型用法。</li></ul><p>(2) 一个进程想要执行另一个程序。首先调用fork创建一个自身的副本，然后其中一个子进程调用exec把自身替换成新的程序。</p><ul><li>shell之类程序的典型用法。</li></ul><h3 id="pid-与-ppid"><a href="#pid-与-ppid" class="headerlink" title="pid 与 ppid"></a>pid 与 ppid</h3><p>pid（Process ID）：进程的唯一标识，由<strong>内核分配</strong>。</p><p>ppid（Parent PID）：父进程的 pid，在 task_struct 中通过 real_parent 字段引用。</p><blockquote><p>当父进程结束，子进程的 ppid 会被自动改为 1，即 init（或 systemd）接管，防止出现孤儿进程。</p></blockquote><h3 id="exec-：用新程序替换当前进程映像"><a href="#exec-：用新程序替换当前进程映像" class="headerlink" title="exec()：用新程序替换当前进程映像"></a>exec()：用新程序替换当前进程映像</h3><p>fork() 复制一个进程，而 exec() 则是替换当前进程所运行的程序，保留 PID 等属性<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> *<span class="type">const</span> envp[])</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;  </span><br></pre></td></tr></table></figure></p><h3 id="wait-与-waitpid"><a href="#wait-与-waitpid" class="headerlink" title="wait() 与 waitpid()"></a>wait() 与 waitpid()</h3><p>父进程需要等待子进程执行完毕，以回收其资源（否则子进程可能变成<strong>僵尸进程</strong>，Z状态）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>或者使用 <code>waitpid(pid, &amp;status, options)</code> 精确等待某个子进程。</p><p>僵尸进程出现的原因：</p><ul><li>子进程退出后，仍保留其 task_struct 中的一部分（如退出码）供父进程读取。</li><li>如果父进程从不调用 wait()，子进程退出后就会一直残留在 Z 状态。</li></ul><p>Linux 内核会通过 <code>do_exit() → release_task()</code> 来清理资源。</p><h2 id="线程机制详解"><a href="#线程机制详解" class="headerlink" title="线程机制详解"></a>线程机制详解</h2><p><strong>线程是 CPU 调度的基本单位，而进程是资源分配的单位。</strong><br>虽然我们通常把“多线程”理解为一个进程内部并发执行的多个控制流，但在 Linux 的实现中，线程和进程的本质其实非常接近，它们都由统一的内核结构 task_struct 表示。</p><h3 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h3><ul><li>是<strong>CPU 调度</strong>的最小单位。</li><li>属于进程的一部分，<strong>多个线程共享同一个进程</strong>的资源（比如内存空间、文件等），但每个线程有自己的栈（stack）和寄存器（register context）。</li><li>使用线程可以<strong>更轻量地实现并发</strong>。</li></ul><p>在 Linux 中，线程并不是一个特殊的概念。线程就是一种特殊形式的进程，我们称之为 <strong>轻量级进程</strong>（LWP，Light Weight Process）。</p><ul><li>每个线程在内核中都由 task_struct 表示。</li><li>所有线程共享相同的进程资源（内存空间、文件描述符、信号处理器等）。</li><li>多个线程组成一个“线程组”，由 主线程（Group Leader） 管理。</li></ul><h3 id="协程（Coroutine）"><a href="#协程（Coroutine）" class="headerlink" title="协程（Coroutine）"></a>协程（Coroutine）</h3><ul><li><strong>用户态</strong>实现的“轻量线程”，切换时不需要进入内核态。</li><li>非抢占，靠用户调度。</li><li>Linux 用户空间实现：ucontext、libco、libuv、boost::coroutine、Python asyncio 等。</li></ul><h3 id="线程与进程的本质区别"><a href="#线程与进程的本质区别" class="headerlink" title="线程与进程的本质区别"></a>线程与进程的本质区别</h3><div class="table-container"><table><thead><tr><th>特性</th><th>进程（Process）</th><th>线程（Thread）</th></tr></thead><tbody><tr><td>地址空间</td><td>不共享（独立）</td><td>共享（同一进程）</td></tr><tr><td>文件描述符表</td><td>独立</td><td>通常共享</td></tr><tr><td>栈空间</td><td>独立</td><td>独立</td></tr><tr><td>调度</td><td>独立调度单元</td><td>也是独立调度单元</td></tr><tr><td>通信方式</td><td>需要 IPC（管道、信号等）</td><td>直接通过共享内存</td></tr></tbody></table></div><blockquote><p>每个线程和进程都对应一个 task_struct，只是线程共享了更多资源。</p></blockquote><h3 id="clone-线程的创建机制"><a href="#clone-线程的创建机制" class="headerlink" title="clone() 线程的创建机制"></a>clone() 线程的创建机制</h3><p>Linux 中线程和进程的创建都通过一个底层的系统调用 clone()。</p><p>函数原型（简化）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><br>clone() 的关键点：</p><ul><li>flags 参数决定子进程与父进程共享哪些资源。</li><li>创建“线程”的关键是设置合适的 flags，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM        <span class="comment">// 共享内存空间</span></span><br><span class="line">CLONE_FS        <span class="comment">// 共享文件系统信息（cwd 等）</span></span><br><span class="line">CLONE_FILES     <span class="comment">// 共享文件描述符</span></span><br><span class="line">CLONE_SIGHAND   <span class="comment">// 共享信号处理器</span></span><br><span class="line">CLONE_THREAD    <span class="comment">// 加入父线程所在的线程组</span></span><br></pre></td></tr></table></figure>使用这些标志组合，就可以创建一个“线程”而非独立进程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 多线程 </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heaven&#39;s Gate or Hell&#39;s Gate</title>
      <link href="/2025/07/07/%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8or%E5%9C%B0%E7%8B%B1%E4%B9%8B%E9%97%A8/"/>
      <url>/2025/07/07/%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8or%E5%9C%B0%E7%8B%B1%E4%B9%8B%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="天堂之门"><a href="#天堂之门" class="headerlink" title="天堂之门"></a>天堂之门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Windows-架构概览"><a href="#Windows-架构概览" class="headerlink" title="Windows 架构概览"></a>Windows 架构概览</h3><div class="table-container"><table><thead><tr><th>用户层</th><th>内核层</th></tr></thead><tbody><tr><td>32 位或 64 位进程</td><td>始终为 64 位内核</td></tr></tbody></table></div><ul><li>Windows 的内核（ntoskrnl.exe）<strong>永远是 64 位</strong>。</li><li>即使运行的是 32 位程序，它也是通过 WOW64 子系统（Windows-on-Windows64） 模拟运行的</li></ul><h3 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h3><p>WOW64 是 Windows x64 系统的一个兼容子系统，用于支持 32 位应用的运行。</p><blockquote><p>在 64 位系统中为 32 位程序提供一个运行时环境。</p></blockquote><p>WOW64 的三大组件：<br>| 模块               | 位数   | 作用                      |<br>| ———————— | —— | ———————————- |<br>| <strong>wow64.dll</strong>    | 32 位 | 桥接层，将 32 → 64 位参数封装     |<br>| <strong>wow64win.dll</strong> | 64 位 | 处理 GUI / 用户模式接口         |<br>| <strong>wow64cpu.dll</strong> | 64 位 | CPU 上的 thunk 机制（切换执行模式） |</p><ul><li>拦截 32 位程序对系统调用的请求</li><li>转换成 64 位调用，并在内核中执行</li><li>再把结果转换回 32 位，返回给原程序</li></ul><h3 id="CPU-分段模型"><a href="#CPU-分段模型" class="headerlink" title="CPU 分段模型"></a>CPU 分段模型</h3><ul><li><p>x86 CPU 使用段选择子（Segment Selector）控制代码在哪个段执行。</p></li><li><p>每个代码段有一个描述符，控制：基址、权限、位数（32/64）等</p><ul><li><p><code>0x23</code>是 32 位代码段（常见于用户层）</p></li><li><p><code>0x33</code>是 64 位代码段（WOW64 环境中的64段）</p></li></ul></li></ul><h3 id="ret-与-retf"><a href="#ret-与-retf" class="headerlink" title="ret 与 retf"></a>ret 与 retf</h3><div class="table-container"><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>ret</code></td><td>只 pop 一个返回地址，<strong>返回当前代码段内</strong></td></tr><tr><td><code>retf</code></td><td>pop 返回地址 + 段选择子，<strong>返回其他段（跨段）</strong></td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x33         ; 64 位段选择子</span><br><span class="line">push addr         ; 目标RIP（64位代码地址）</span><br><span class="line">retf              ; --&gt; 切换到 64 位代码段</span><br></pre></td></tr></table></figure><p>改变 CS:RIP 为 0x33:addr，从而跳到 64 位模式</p><h2 id="Heaven’s-Gate"><a href="#Heaven’s-Gate" class="headerlink" title="Heaven’s Gate"></a>Heaven’s Gate</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>天堂之门Heaven’s Gate 是一种在32位WoW64进程中执行64位代码，以及直接调用64位WIN32 API函数的技术。</p><ul><li>在 32 位进程中执行 64 位系统调用</li><li>绕过某些对 32 位 API Hook 的监控（例如 ntdll.dll inline hook）</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="32-位程序执行过程"><a href="#32-位程序执行过程" class="headerlink" title="32 位程序执行过程"></a>32 位程序执行过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[32位程序]</span><br><span class="line">    ↓</span><br><span class="line">user32.dll（32位）</span><br><span class="line">    ↓</span><br><span class="line">kernel32.dll（32位）</span><br><span class="line">    ↓</span><br><span class="line">ntdll.dll（32位）        ← EDR经常hook这里</span><br><span class="line">    ↓</span><br><span class="line">WOW64（模式切换）</span><br><span class="line">    ↓</span><br><span class="line">ntdll.dll（64位）        ← 真正执行 syscall</span><br><span class="line">    ↓</span><br><span class="line">syscall → 内核函数</span><br></pre></td></tr></table></figure><ul><li>在 32 位系统里，进入内核常用的是 <code>int 0x2e</code></li><li>在 64 位系统中，进入内核的是 <code>syscall</code> 指令</li></ul><h3 id="WOW64-切换流程"><a href="#WOW64-切换流程" class="headerlink" title="WOW64 切换流程"></a>WOW64 切换流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   32位程序</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line"> ntdll.dll (32位)</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line"> wow64.dll (32位)</span><br><span class="line">       │</span><br><span class="line">       ▼  ← 通过 INT 2E or Wow64Transition</span><br><span class="line"> CPU 切换到 64 位（via wow64cpu.dll）</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line"> ntdll.dll (64位)</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">   syscall</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">ntoskrnl.exe（内核） </span><br></pre></td></tr></table></figure><p><strong>Wow64Transition</strong>:通过 CPU 特殊指令和上下文转换，让用户态线程从 32 位代码段跳入 64 位段执行</p><h3 id="天堂之门的实现思路"><a href="#天堂之门的实现思路" class="headerlink" title="天堂之门的实现思路"></a>天堂之门的实现思路</h3><p>1、将cs段寄存器设为0x33，切换到64位模式<br>2、从gs:0x60读取64位PEB<br>3、从64位PEB中定位64位ntdll基址<br>4、遍历ntdll64导出表，读取ZwOpenProcess函数地址<br>5、构造64位函数调用</p><p>如果需要调用的是ntdll之外的函数，以kernel32.dll中的CreateFile函数为例，还需要：<br>1、遍历ntdll64导出表，读取LdrLoadDll函数地址<br>2、调用LdrLoadDll(“kernel32.dll”)加载64位kernel32.dll<br>3、从64位的kernel32中读取GetProcAddress等函数，获取CreateFile函数地址<br>4、调用CreateFile函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x33         ; 64 位代码段</span><br><span class="line">push offset_64    ; 64 位代码地址</span><br><span class="line">retf              ; 真正跳到 64 位执行</span><br></pre></td></tr></table></figure><blockquote><p>拜读文章：<br>    <a href="https://bbs.kanxue.com/thread-270153.htm"> [原创]天堂之门 (Heaven’s Gate) C语言实现</a><br>    <a href="https://wbenny.github.io/2018/11/04/wow64-internals.html">WoW64 内部结构</a><br>    <a href="https://clovershrub.github.io/2024/02/02/%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8/index.html">天堂之门</a></p></blockquote><h1 id="地狱之门"><a href="#地狱之门" class="headerlink" title="地狱之门"></a>地狱之门</h1><p>地狱之门是一种在<strong>64 位进程中主动构造系统调用指令 syscall</strong> 的方法，目的是<strong>绕过用户层 API</strong>（如 ntdll.dll）的 Hook 与监控。</p><p>传统的系统调用路径：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program → ntdll.dll → syscall</span><br></pre></td></tr></table></figure><br>地狱之门:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program → 读取 ntdll.dll → 解析 syscall ID → 手动 syscall</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见加密算法整理</title>
      <link href="/2025/07/06/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2025/07/06/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="TEA家族"><a href="#TEA家族" class="headerlink" title="TEA家族"></a>TEA家族</h1><p><strong>TEA算法每一次可以操作64bit(8byte)，采用128bit(16byte)作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮(可以改变)。</strong></p><p>TEA系列算法中均使用了一个<strong>DELTA常数</strong>，但DELTA的值对算法并无什么影响，只是为了避免不良的取值，推荐DELTA的值取为黄金分割数(5√-2)/2与232的乘积，取整后的十六进制值为<strong>0x9e3779B9</strong>(也可以改变)，用于保证每一轮加密都不相同。</p><p><strong>XTEA</strong>：使用与TEA相同的简单运算，但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。<br>Block TEA算法可以对32位的任意整数倍长度的变量块进行加解密的操作，该算法将XTEA轮循函数依次应用于块中的每个字，并且将它附加于被应用字的邻字。</p><p><strong>XXTEA</strong>使用跟Block TEA相似的结构，但在处理块中每个字时利用了相邻字，且用拥有<strong>两个输入量的MX函数</strong>代替了XTEA轮循函数。上面提到的相邻字其实就是数组中相邻的项。</p><div class="table-container"><table><thead><tr><th>算法</th><th>年代</th><th>设计目标</th><th>缺点 / 改进动因</th></tr></thead><tbody><tr><td><strong>TEA</strong></td><td>1994</td><td>简洁、快速的加密算法</td><td>存在<strong>相关密钥攻击</strong>，弱点已知</td></tr><tr><td><strong>XTEA</strong></td><td>1997</td><td>修复 TEA 的弱点</td><td>算法结构仍然容易分析</td></tr><tr><td><strong>XXTEA</strong></td><td>1998</td><td>完全重构的块加密算法</td><td>更安全，结构非 Feistel</td></tr></tbody></table></div><h2 id="Feistel结构"><a href="#Feistel结构" class="headerlink" title="Feistel结构"></a>Feistel结构</h2><ul><li>TEA和XTEA<strong>都是</strong>Feistel网络</li><li>XXTEA<strong>完全摆脱</strong>Feustel网络</li></ul><p>Feistel 网络（Feistel Network）是一种<strong>加密算法的结构框架</strong>。<br>设计理念：</p><blockquote><p>把一个东西“拆成左右两半”，然后通过反复、对称的方式迭代加密。</p></blockquote><h3 id="Feistel-网络结构图"><a href="#Feistel-网络结构图" class="headerlink" title="Feistel 网络结构图"></a>Feistel 网络结构图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始明文块:  (L0, R0)   <span class="comment">#原始数据被拆成的两部分</span></span><br><span class="line"></span><br><span class="line">一轮加密操作：</span><br><span class="line">L1 = R0</span><br><span class="line">R1 = L0 ⊕ F(R0, K0)   <span class="comment">#轮函数</span></span><br><span class="line"></span><br><span class="line">输出密文块: (L1, R1)</span><br></pre></td></tr></table></figure><h2 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h2><ul><li>分组加密:<br>TEA算法将64位明文分成两个32位的部分（V0 和V1），使用128位密钥分成四个32位的部分（K0，K1，K2，K3）。</li><li><p>迭代过程：<br>算法通过多次迭代（循环）进行加密，每次迭代对明文分组进行变换。</p><ul><li><p>变换:<br>每次迭代都会对明文分组进行非线性变换，包括加法、左移、右移等操作。</p></li><li><p>密钥使用：:<br>密钥的每个部分在每轮迭代中都会被使用，以确保加密的安全性。</p></li><li><p>Delta (δ):<br>常量δ（0x9e3779b9）在每一轮迭代中累加，使得每轮的加密与前一轮不同，从而提升抗差分攻击能力。</p></li></ul></li><li><p>循环次数:<br>算法的循环次数影响加密的强度。建议使用32轮或64轮的迭代，可以根据具体应用场景调整。</p></li></ul><ul><li>解密:<br>解密过程与加密过程相似，但方向相反，使用相同的密钥和循环次数即可。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ecbtea_encrypt</span><span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], i;</span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">        v1 += ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h2></li><li>不再使用对称结构，而是交替处理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">sum += delta;</span><br><span class="line">v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h2><p>扩展了加密块大小，可以处理<strong>任意长度</strong>的数据块（至少64位）。</p><ul><li>将数据分成32位字数组（V[0]…V[n-1]）</li><li>仍使用128位密钥（K0-K3）</li></ul><p>优点</p><ul><li>可变块大小：可以处理任意长度数据块</li><li>更强的安全性：更复杂的混合函数</li><li>整体处理：对整个数据块进行操作</li><li>保持简单性：实现仍相对简单<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line">rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">sum = rounds * delta;</span><br><span class="line"><span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">    e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = n<span class="number">-1</span>; p &gt; <span class="number">0</span>; p--) &#123;</span><br><span class="line">        z = V[p<span class="number">-1</span>];</span><br><span class="line">        V[p] -= ((z &lt;&lt; <span class="number">4</span> ^ z &gt;&gt; <span class="number">5</span>) + z) ^ (sum + K[(p &amp; <span class="number">3</span>) ^ e]);</span><br><span class="line">    &#125;</span><br><span class="line">    z = V[n<span class="number">-1</span>];</span><br><span class="line">    V[<span class="number">0</span>] -= ((z &lt;&lt; <span class="number">4</span> ^ z &gt;&gt; <span class="number">5</span>) + z) ^ (sum + K[(<span class="number">0</span> &amp; <span class="number">3</span>) ^ e]);</span><br><span class="line">    sum -= delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="DES-amp-AES"><a href="#DES-amp-AES" class="headerlink" title="DES &amp; AES"></a>DES &amp; AES</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p><strong>特性：</strong></p><ul><li><strong>分组加密</strong>：每次加密 <strong>64 位</strong>（8 字节） 的明文块。</li><li>密钥长度：<strong>64 位密钥</strong>（其中 8 位用于奇偶校验，有效密钥是 56 位）。</li><li>加密轮数：<strong>16 轮</strong> Feistel 结构。</li></ul><p><strong>加密过程:</strong><br>1、初始置换（IP）<br>2、分为左右两部分 L0 和 R0。<br>3、进入 16 轮迭代，每轮：</p><ul><li>利用子密钥对右半部分做 Feistel 函数（包含扩展、异或、S-box 替代、P置换）</li><li>与左半部分异或，交换左右。</li></ul><p>4、最终置换（IP⁻¹）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">明文 (64 位)</span><br><span class="line">  ↓ IP 初始置换</span><br><span class="line">分为 L0 和 R0 各 32 位</span><br><span class="line">  ↓ 进入 16 轮迭代：</span><br><span class="line">      Li = Ri-1</span><br><span class="line">      Ri = Li-1 ⊕ F(Ri-1, Ki)</span><br><span class="line">  ↓ 合并 L16 和 R16</span><br><span class="line">  ↓ IP⁻¹ 逆置换</span><br><span class="line">→ 密文</span><br></pre></td></tr></table></figure><br>每轮结构：Feistel Round<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：Li-1, Ri-1, Ki</span><br><span class="line">F(Ri-1, Ki):</span><br><span class="line">    - 扩展置换 E (32 → 48 位)</span><br><span class="line">    - 与子密钥 Ki 异或</span><br><span class="line">    - S-box 替换（8 个 S-box：48 → 32 位）</span><br><span class="line">    - P 置换（重排）</span><br><span class="line">输出：</span><br><span class="line">    Li = Ri-1</span><br><span class="line">    Ri = Li-1 ⊕ F(Ri-1, Ki)</span><br></pre></td></tr></table></figure></p><h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><blockquote><p>3DES = DES × 3</p></blockquote><h3 id="密钥模式"><a href="#密钥模式" class="headerlink" title="密钥模式"></a>密钥模式</h3><p>3DES 使用 3 个子密钥（K1、K2、K3）：</p><ul><li><strong>3-key 模式</strong>：K1 ≠ K2 ≠ K3 → 共 168 位密钥；</li><li><strong>2-key 模式</strong>：K1 = K3 → 共 112 位密钥；</li><li><strong>1-key 模式</strong>：K1 = K2 = K3 → 实际就是普通 DES，不推荐使用。</li></ul><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>默认使用 <strong>EDE</strong> 模式：Encrypt → Decrypt → Encrypt</p><p>${\displaystyle {\textrm {ciphertext}}=E<em>{K3}（D</em>{K2}（E_{K1}（{\textrm {plaintext}}）））.}$</p><ul><li>第一次：使用 K1 加密；</li><li>第二次：使用 K2 解密（增加复杂性）；</li><li>第三次：使用 K3 再加密，得到最终密文。</li></ul><h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><p>${\displaystyle {\textrm {plaintext}}=D<em>{K1}（E</em>{K2}（D_{K3}（{\textrm {ciphertext}}））））.}$<br>使用 K3 解密,使用 K2 加密 ，然后使用 K1 解密 </p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>分组加密</strong>：以 <strong>128 位（16 字节）</strong>为一个分组处理。</li><li>支持三种密钥长度：<ul><li>AES-128：10 轮</li><li>AES-192：12 轮</li><li>AES-256：14 轮</li></ul></li></ul><h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p>初始轮：</p><ul><li>AddRoundKey</li></ul><p>主轮（重复 9~13 次）：</p><ul><li>字节代换SubBytes      → 字节替换（S-box）</li><li>行移位ShiftRows     → 行移位</li><li>列混淆MixColumns    → 列混合</li><li>轮密钥加AddRoundKey   → 异或子密钥</li></ul><p>最终轮（无 MixColumns）：</p><ul><li>SubBytes</li><li>ShiftRows</li><li>AddRoundKey</li></ul><p>1、SubBytes（S-box 替换）</p><ul><li>AES 的 S-box 是基于 GF(2⁸) 有限域逆元 + 仿射变换，非线性极强。</li><li>每个字节独立替换，提升抗差分攻击能力。<blockquote><p>例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。</p></blockquote></li></ul><p>2、ShiftRows（行移位）<br>第 24 行左移 13 位，实现字节扩散。</p><p>3、 MixColumns（列混合）</p><ul><li>每列与固定矩阵相乘</li><li>计算在 GF(2⁸) 上完成</li></ul><p>4、 AddRoundKey（轮密钥异或）</p><ul><li>每轮都与 128 位子密钥异或，确保密钥参与每轮。</li></ul><h3 id="AES-ECB"><a href="#AES-ECB" class="headerlink" title="AES_ECB"></a>AES_ECB</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&#x27;secret!!secret!!&#x27;</span>  <span class="comment"># 秘钥必须为 16 字节或者 16 字节的倍数的字节型数据</span></span><br><span class="line">text = <span class="string">b&#x27;TextTextTextText&#x27;</span>  <span class="comment"># 明文必须为 16 字节或者 16 字节的倍数的字节型数据，如果不够 16 字节需要进行补全</span></span><br><span class="line">aes = AES.new(password, AES.MODE_ECB)  <span class="comment"># 创建一个 aes 对象</span></span><br><span class="line"><span class="comment"># AES.MODE_ECB 表示模式是 ECB 模式</span></span><br><span class="line">en_text = aes.encrypt(text)  <span class="comment"># 加密明文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;密文：&quot;</span>, en_text)  <span class="comment"># 加密明文，bytes 类型</span></span><br><span class="line">de_text = aes.decrypt(en_text)  <span class="comment"># 解密密文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文：&quot;</span>, de_text)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">密文： b&#x27;\t9\x9b\xc5\x19E\xeb4oL\x1a`\xc7\x8b\xd4\xb2&#x27;</span></span><br><span class="line"><span class="string">明文： b&#x27;TextTextTextText&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ollvm_BCF源码阅读</title>
      <link href="/2025/06/15/ollvm-BCF%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2025/06/15/ollvm-BCF%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="虚假控制流-BCF-Bogus-Control-Flow"><a href="#虚假控制流-BCF-Bogus-Control-Flow" class="headerlink" title="虚假控制流 BCF (Bogus Control Flow)"></a>虚假控制流 BCF (Bogus Control Flow)</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li>虚假控制流混淆通过加入包含不透明谓词的条件跳转（永真or永假）和不可达的基本块，来干扰 IDA 的控制流分析和 F5 反汇编。</li></ul><h2 id="反混淆："><a href="#反混淆：" class="headerlink" title="反混淆："></a>反混淆：</h2><p>1、将全局变量赋值并将 segment 设为只读。</p><ul><li>对于常规的 ollvm 的 bcf 混淆来说，bcf 的不透明谓词都是处于 .bss段 中。</li><li>Edit-&gt;Segments-&gt;Edit segment 将 Write 复选框取消勾选， .bss段 就设为只读</li></ul><p>2、d810 </p><p>3、idapython patch 不透明谓词</p><h2 id="源码位置："><a href="#源码位置：" class="headerlink" title="源码位置："></a>源码位置：</h2><p>obfuscator\lib\Transforms\Obfuscation\BogusControlFlow.cpp</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Pass结构与参数"><a href="#Pass结构与参数" class="headerlink" title="Pass结构与参数"></a>Pass结构与参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BogusControlFlow</span> : <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ID; <span class="comment">// Pass identification</span></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="built_in">BogusControlFlow</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="built_in">BogusControlFlow</span>(<span class="type">bool</span> flag) : <span class="built_in">FunctionPass</span>(ID) &#123;<span class="keyword">this</span>-&gt;flag = flag; <span class="built_in">BogusControlFlow</span>();&#125;</span><br></pre></td></tr></table></figure><p>继承自 LLVM 的 FunctionPass。<br>在 LLVM Pass 设计中，ID 用于标识插件自身，flag 可用来控制是否对目标函数实际作用（如按用户参数选择）。这里有两个构造函数，用于接收可选参数。</p><h2 id="pass流程主入口"><a href="#pass流程主入口" class="headerlink" title="pass流程主入口"></a>pass流程主入口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span></span>&#123;            <span class="comment">//Pass的核心入口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ObfTimes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;BogusControlFlow application number -bcf_loop=x must be x &gt; 0&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !((ObfProbRate &gt; <span class="number">0</span>) &amp;&amp; (ObfProbRate &lt;= <span class="number">100</span>)) ) &#123;</span><br><span class="line">      <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;BogusControlFlow application basic blocks percentage -bcf_prob=x must be 0 &lt; x &lt;= 100&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查混淆轮数（ObfTimes）和概率参数（ObfProbRate）是否合法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">toObfuscate</span>(flag,&amp;F,<span class="string">&quot;bcf&quot;</span>)) &#123; <span class="comment">//判断此函数是否要混淆</span></span><br><span class="line">      <span class="built_in">bogus</span>(F);</span><br><span class="line">      <span class="built_in">doF</span>(*F.<span class="built_in">getParent</span>());    <span class="comment">//在全模块层面做一次doF（全局修饰，例如混淆所有恒真的条件）</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="comment">// end of runOnFunction()</span></span><br></pre></td></tr></table></figure><h3 id="随机选择、遍历每个基本块"><a href="#随机选择、遍历每个基本块" class="headerlink" title="随机选择、遍历每个基本块"></a>随机选择、遍历每个基本块</h3><p><code>bogus(F)</code>的主要逻辑是：循环要混淆多少轮，每轮遍历函数当前全部基本块。对每个BasicBlock按概率 ObfProbRate 随机决定是否插入虚假控制流——选中后调用addBogusFlow(basicBlock, F)。其中插入虚假流程会导致新生成3个基本块，因此统计量需相应自增。每一轮循环处理后，firstTime位设为false，避免重复初始化统计变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bogus</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">    ++NumFunction;              </span><br><span class="line">    <span class="type">int</span> NumBasicBlocks = <span class="number">0</span>;     </span><br><span class="line">    <span class="type">bool</span> firstTime = <span class="literal">true</span>;      </span><br><span class="line">    <span class="type">bool</span> hasBeenModified = <span class="literal">false</span>; </span><br><span class="line">    <span class="type">int</span> NumObfTimes = ObfTimes;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::list&lt;BasicBlock *&gt; basicBlocks;</span><br><span class="line">        <span class="comment">// --- 1. 把当前F的所有基本块收集到list里 ---</span></span><br><span class="line">        <span class="keyword">for</span>(Function::iterator i = F.<span class="built_in">begin</span>(); i != F.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">            basicBlocks.<span class="built_in">push_back</span>(&amp;*i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 2. 遍历所有基本块，按概率挑选 ---</span></span><br><span class="line">        <span class="keyword">while</span>(!basicBlocks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            NumBasicBlocks ++;</span><br><span class="line">            BasicBlock *basicBlock = basicBlocks.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// -- 3. 按概率决定是否对该块混淆 --</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">int</span>)cryptoutils-&gt;<span class="built_in">get_range</span>(<span class="number">100</span>) &lt; ObfProbRate)&#123;</span><br><span class="line">                hasBeenModified = <span class="literal">true</span>;</span><br><span class="line">                ++NumModifiedBasicBlocks;        <span class="comment">// 混淆的块计数</span></span><br><span class="line">                NumAddedBasicBlocks += <span class="number">3</span>;        <span class="comment">// 每次新增3个BB</span></span><br><span class="line">                FinalNumBasicBlocks += <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// --- 核心：对该块做bogus混淆 ----</span></span><br><span class="line">                <span class="built_in">addBogusFlow</span>(basicBlock, F);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// -- 4. pop掉已经处理过的块 --</span></span><br><span class="line">            basicBlocks.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// -- 5. 第一次遍历时，用于记录统计 --</span></span><br><span class="line">            <span class="keyword">if</span>(firstTime)&#123;</span><br><span class="line">                ++InitNumBasicBlocks;</span><br><span class="line">                ++FinalNumBasicBlocks;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        firstTime = <span class="literal">false</span>;         <span class="comment">// 只在第一轮初始化时统计</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(--NumObfTimes &gt; <span class="number">0</span>);       <span class="comment">// 视混淆轮数多次叠加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="拆分基本块，制造分支点"><a href="#拆分基本块，制造分支点" class="headerlink" title="拆分基本块，制造分支点"></a>拆分基本块，制造分支点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock::iterator i1 = basicBlock-&gt;<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span>(basicBlock-&gt;<span class="built_in">getFirstNonPHIOrDbgOrLifetime</span>())</span><br><span class="line">    i1 = (BasicBlock::iterator)basicBlock-&gt;<span class="built_in">getFirstNonPHIOrDbgOrLifetime</span>();</span><br><span class="line">Twine *var = <span class="keyword">new</span> <span class="built_in">Twine</span>(<span class="string">&quot;originalBB&quot;</span>);</span><br><span class="line">BasicBlock *originalBB = basicBlock-&gt;<span class="built_in">splitBasicBlock</span>(i1, *var);</span><br></pre></td></tr></table></figure><p>将当前basicBlock按照首个非phi与非调试/声明作用域指令拆分：第一块只保留phi与必要的头部信息，剩余的内容新生成 originalBB。这样后续插入分支时可保证ir合法性，不会破坏phi变量。新originalBB成了插入跳转的目标。</p><h3 id="创建原始块的变形副本"><a href="#创建原始块的变形副本" class="headerlink" title="创建原始块的变形副本"></a>创建原始块的变形副本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Twine * var3 = <span class="keyword">new</span> <span class="built_in">Twine</span>(<span class="string">&quot;alteredBB&quot;</span>);</span><br><span class="line">BasicBlock *alteredBB = <span class="built_in">createAlteredBasicBlock</span>(originalBB, *var3, &amp;F);</span><br></pre></td></tr></table></figure><p>生成了一份originalBB的深拷贝，并按后续代码在其中间随机插入了垃圾指令</p><h3 id="控制流扇出与插入恒真判定"><a href="#控制流扇出与插入恒真判定" class="headerlink" title="控制流扇出与插入恒真判定"></a>控制流扇出与插入恒真判定</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备条件恒为真的IR</span></span><br><span class="line">Value * LHS = ConstantFP::<span class="built_in">get</span>(Type::<span class="built_in">getFloatTy</span>(F.<span class="built_in">getContext</span>()), <span class="number">1.0</span>);</span><br><span class="line">Value * RHS = ConstantFP::<span class="built_in">get</span>(Type::<span class="built_in">getFloatTy</span>(F.<span class="built_in">getContext</span>()), <span class="number">1.0</span>);</span><br><span class="line">Twine * var4 = <span class="keyword">new</span> <span class="built_in">Twine</span>(<span class="string">&quot;condition&quot;</span>);</span><br><span class="line">FCmpInst * condition = <span class="keyword">new</span> <span class="built_in">FCmpInst</span>(*basicBlock, FCmpInst::FCMP_TRUE , LHS, RHS, *var4);</span><br><span class="line">BranchInst::<span class="built_in">Create</span>(originalBB, alteredBB, (Value *)condition, basicBlock);</span><br></pre></td></tr></table></figure><p>实际上就是1.0和1.0做浮点比较，谓词FCMP_TRUE代表“永远为真”。<br>再用它构造条件分支，如果 condition 为真跳 originalBB，否则跳 alteredBB。<br>但实际上一直走 originalBB。最后会由doF将该恒真判断替换成更复杂的表达式。</p><h3 id="让alteredBB循环回originalBB"><a href="#让alteredBB循环回originalBB" class="headerlink" title="让alteredBB循环回originalBB"></a>让alteredBB循环回originalBB</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BranchInst::<span class="built_in">Create</span>(originalBB, alteredBB);</span><br></pre></td></tr></table></figure><p>alteredBB 的终止指令直接跳回 originalBB</p><h3 id="再次拆分-originalBB-的结尾，伪造-return-alteredBF-跳转"><a href="#再次拆分-originalBB-的结尾，伪造-return-alteredBF-跳转" class="headerlink" title="再次拆分 originalBB 的结尾，伪造 return / alteredBF 跳转"></a>再次拆分 originalBB 的结尾，伪造 return / alteredBF 跳转</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock::iterator i = originalBB-&gt;<span class="built_in">end</span>();</span><br><span class="line">Twine * var5 = <span class="keyword">new</span> <span class="built_in">Twine</span>(<span class="string">&quot;originalBBpart2&quot;</span>);</span><br><span class="line">BasicBlock * originalBBpart2 = originalBB-&gt;<span class="built_in">splitBasicBlock</span>(--i , *var5);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在 originalBB 末尾再插入一条恒为真的判断</span></span><br><span class="line">Twine * var6 = <span class="keyword">new</span> <span class="built_in">Twine</span>(<span class="string">&quot;condition2&quot;</span>);</span><br><span class="line">FCmpInst * condition2 = <span class="keyword">new</span> <span class="built_in">FCmpInst</span>(*originalBB, CmpInst::FCMP_TRUE , LHS, RHS, *var6);</span><br><span class="line">BranchInst::<span class="built_in">Create</span>(originalBBpart2, alteredBB, (Value *)condition2, originalBB);</span><br></pre></td></tr></table></figure><h3 id="克隆原始基本块并插入垃圾指令"><a href="#克隆原始基本块并插入垃圾指令" class="headerlink" title="克隆原始基本块并插入垃圾指令"></a>克隆原始基本块并插入垃圾指令</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock * alteredBB = llvm::<span class="built_in">CloneBasicBlock</span> (basicBlock, VMap, Name, F);</span><br><span class="line"><span class="comment">// 为每条指令做operand/Phi remap等</span></span><br><span class="line"><span class="comment">// ...遍历 alteredBB-&gt;begin(), e= alteredBB-&gt;end()</span></span><br><span class="line"><span class="comment">// 根据opcode随机插入诸如取反&amp;加法/移位/乘法等冗余垃圾算术操作</span></span><br></pre></td></tr></table></figure><p>用 LLVM 提供的 CloneBasicBlock API 深拷贝一个IR基本块，然后对其中每条指令做参数和 phi 节点等的 remapping，保证各指向正确，然后按照类型继续在合适位置插入垃圾指令。</p><h3 id="全局替换恒真判定条件"><a href="#全局替换恒真判定条件" class="headerlink" title="全局替换恒真判定条件"></a>全局替换恒真判定条件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）遍历找所有 FCMP_TRUE 的分支</span></span><br><span class="line"><span class="comment">//（2）统一替换成复杂不透明谓词：(y &lt; 10) || ((x*(x+1)) % 2 == 0)</span></span><br><span class="line">opX = <span class="keyword">new</span> <span class="built_in">LoadInst</span> ((Value *)x, <span class="string">&quot;&quot;</span>, (*i));</span><br><span class="line">opY = <span class="keyword">new</span> <span class="built_in">LoadInst</span> ((Value *)y, <span class="string">&quot;&quot;</span>, (*i));</span><br><span class="line">op = BinaryOperator::<span class="built_in">Create</span>(Instruction::Sub, (Value *)opX,</span><br><span class="line">    ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(M.<span class="built_in">getContext</span>()), <span class="number">1</span>, <span class="literal">false</span>), <span class="string">&quot;&quot;</span>, (*i));</span><br><span class="line">op1 = BinaryOperator::<span class="built_in">Create</span>(Instruction::Mul, (Value *)opX, op, <span class="string">&quot;&quot;</span>, (*i));</span><br><span class="line">op = BinaryOperator::<span class="built_in">Create</span>(Instruction::URem, op1,</span><br><span class="line">    ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(M.<span class="built_in">getContext</span>()), <span class="number">2</span>, <span class="literal">false</span>), <span class="string">&quot;&quot;</span>, (*i));</span><br><span class="line">condition = <span class="keyword">new</span> <span class="built_in">ICmpInst</span>((*i), ICmpInst::ICMP_EQ, op,</span><br><span class="line">    ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(M.<span class="built_in">getContext</span>()), <span class="number">0</span>, <span class="literal">false</span>));</span><br><span class="line">condition2 = <span class="keyword">new</span> <span class="built_in">ICmpInst</span>((*i), ICmpInst::ICMP_SLT, opY,</span><br><span class="line">    ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(M.<span class="built_in">getContext</span>()), <span class="number">10</span>, <span class="literal">false</span>));</span><br><span class="line">op1 = BinaryOperator::<span class="built_in">Create</span>(Instruction::Or, (Value *)condition,</span><br><span class="line">    (Value *)condition2, <span class="string">&quot;&quot;</span>, (*i));</span><br><span class="line">BranchInst::<span class="built_in">Create</span>(((BranchInst*)*i)-&gt;<span class="built_in">getSuccessor</span>(<span class="number">0</span>),</span><br><span class="line">    ((BranchInst*)*i)-&gt;<span class="built_in">getSuccessor</span>(<span class="number">1</span>),(Value *) op1,</span><br><span class="line">    ((BranchInst*)*i)-&gt;<span class="built_in">getParent</span>());</span><br><span class="line">(*i)-&gt;<span class="built_in">eraseFromParent</span>();</span><br></pre></td></tr></table></figure><p>总而言之是将所有的假跳转复杂化</p><h3 id="pass-混淆思路核心"><a href="#pass-混淆思路核心" class="headerlink" title="pass 混淆思路核心"></a>pass 混淆思路核心</h3><p>1、随机选取基本块<br>2、将其一拆三，并构造冗余always-true条件和虚假分支<br>3、插入带有垃圾指令的altered副本块<br>4、算法完成后，再把这些恒真的 predicate 全变成复杂的“不透明谓词”<br>5、达到控制流与符号流分析难度大幅提升的效果</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> obfuscation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA使用技巧</title>
      <link href="/2025/03/26/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2025/03/26/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>这两天做题的时候同届的pwn师傅sakura来问有没有可以修改IDA局部变量的方法。研究了一下感觉很有意思，于是单独开一篇文章记录我经常用到的IDA小技巧。</p><h1 id="修改局部变量"><a href="#修改局部变量" class="headerlink" title="修改局部变量"></a>修改局部变量</h1><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>IDA有两种实现方式，我在网上查到可以force new variable，但是我一直没成功。</p><h3 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h3><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260152493.png" alt=""></p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>因为可以观察到都是分开赋值的</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260206208.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260207597.png" alt=""></p><p>我们在var_5那边按U</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260211783.png" alt=""></p><p>我们的目标是分出一个char+int，因为我得需求是让v2[0]单独分出来变成char，v2[1]-v2[4]变成四字节的int，所以我们选择1+4</p><p>在01的地方按N重命名成i，在05的地方选择建立数组（可以按A）在N成opcode</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260220412.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260222223.png" alt=""></p><p>回到executeBrainfuck按F5</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260223664.png" alt=""></p><p>接着来改汇编</p><p>因为IDA在反编译的时候，会根据变量的访问方式和指令来推断变量类型</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260230570.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     dword ptr [rbp+opcode+1], 0  ; 赋值了 4 个字节</span><br></pre></td></tr></table></figure><p>opcode[1]之后是 4 个连续的字节，IDA会推测opcode[5]这样的存储</p><p>我们把它nop掉</p><p>1、<code>opcode+1</code>字节数显着地<code>4</code>初始化，IDA 无法确认它是内存的一部分，因此可能会被拆除<code>int</code>。</p><p>2.IDA偏向于最简单的数据结构，因此<code>[rbp-5h]</code>直接赋值<code>signed __int8 opcode</code>，而<code>[rbp-4h]</code>作为<code>int opcode_1</code>处理。</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260234728.png" alt=""></p><p>在opcode那里按Y转换函数类型+按N重命名i就好了</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260236267.jpg" alt=""></p><h2 id="Ghidra一把梭"><a href="#Ghidra一把梭" class="headerlink" title="Ghidra一把梭"></a>Ghidra一把梭</h2><p>考虑到是pwn的师傅，所以不推荐（）ghidra挺麻烦的但是足够底层，确实好用</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260158257.jpg" alt=""></p><h1 id="伪代码对应汇编"><a href="#伪代码对应汇编" class="headerlink" title="伪代码对应汇编"></a>伪代码对应汇编</h1><p>可以实现点伪代码哪里汇编会相应跳转，汇编同理，patch的时候好用</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503260202020.png" alt=""></p><h1 id="修复枚举值"><a href="#修复枚举值" class="headerlink" title="修复枚举值"></a>修复枚举值</h1><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503261654447.png" alt=""></p><p>以ptrace函数为例，这里的12LL表示一个功能号。在12上面按M，点击yes，ctrl+F搜索ptrace，这里是PTRACE_GETREGS</p><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202503261657409.png" alt=""></p><h1 id="positive-sp-value"><a href="#positive-sp-value" class="headerlink" title="positive sp value"></a>positive sp value</h1><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507110038454.png" alt=""></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>函数堆栈不平衡：<br>1、函数头尾是否平衡<br>2、永假跳转&amp;破坏栈指针的nop掉</p><blockquote><p>其实能反编译的可以都不用管，网上很多方法都只是为了反编译服务没有真的解决问题，具体的问题得追具体的堆栈。<br>实在不会直接Alt+K改显示负数的堆栈一个个试就行。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="打开栈指针显示"><a href="#打开栈指针显示" class="headerlink" title="打开栈指针显示"></a>打开栈指针显示</h3><p>Options-General<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507110043765.png" alt=""></p><p>在0x411940的位置按Alt+K，可以理解为没有<code>push ebp</code>前SP是0，<code>push ebp</code>完是0x4。<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507110109594.png" alt=""></p><p>堆栈是从高处往低处生长的。<br>函数调用（call）一般会<strong>压栈返回地址</strong>，函数内会使用 push 压参数，调用完毕后会通过 ret 或 ret x（其中 x 是参数大小）来恢复栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:004119FA -04    cmp     ebp, esp</span><br><span class="line">;这是对比当前栈指针 esp 和基址指针 ebp。</span><br><span class="line">;如果这两个相等，说明函数栈帧还“干净”，没有栈溢出或未平衡的 push/pop 操作。</span><br><span class="line">;否则，就是 栈不平衡的迹象（也就是函数执行过程中破坏了栈结构）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:004119FC -04    call    j___RTC_CheckEsp</span><br><span class="line">;MSVC 编译器生成的运行时检测函数，主要用于调试和运行时检查目的。</span><br><span class="line">;检查 cmp ebp, esp 的结果，如果 esp 与 ebp 不相等，就可能抛出错误或崩溃提示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:00411A01 -04    mov     esp, ebp</span><br><span class="line">;无论前面 esp 被破坏得多严重，这条语句是强制把栈恢复到原始基址，保证函数退出时栈是干净的。</span><br></pre></td></tr></table></figure><h3 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h3><p>在 x86 体系中，函数调用是通过堆栈传参的，每次 call 函数都会把返回地址压入堆栈，参数也一般是通过 push 入栈。<br>而函数执行完后，需要恢复这些 push。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数调用处（main）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 2        ; 参数 b</span><br><span class="line">push 1        ; 参数 a</span><br><span class="line">call add      ; 跳转并保存返回地址到栈里</span><br><span class="line">add esp, 8    ; 清理参数（2个 × 4字节）</span><br></pre></td></tr></table></figure><br>函数返回处（add）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebp+8]   ; a</span><br><span class="line">add eax, [ebp+0Ch] ; b</span><br><span class="line">pop ebp</span><br><span class="line">ret                ; 弹出返回地址</span><br></pre></td></tr></table></figure></p><ul><li>比如少了 少了 <code>add esp, 8</code> 或 <code>ret 8</code>堆栈就会不平衡</li></ul><p>当执行 call 指令时，CPU 会自动做两件事：<br>1、把下一条指令的地址（返回地址）压栈（即 ESP 所指的地方）；<br>2、跳转到函数体的地址（call 指向的函数）执行；</p><h1 id="Decompile-as-call"><a href="#Decompile-as-call" class="headerlink" title="Decompile as call"></a>Decompile as call</h1><p>IDA官方：<a href="https://hex-rays.com/blog/igors-tip-of-the-week-71-decompile-as-call#:~:text=Invoke%20Edit%20%3E%20Other%20%3E%20Decompile%20as%20call%E2%80%A6,use%3A%20void%20__usercall%20mtsgpr3%28unsigned%20int%3Cr30%3E%29%20int%20__usercall%20mftb%3Cr3%3E%28%29%3B">Decompile as call （反编译为调用)</a><br>Invoke Edit &gt; Other &gt; Decompile as call…<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507110248927.png" alt=""><br>Decompile as call 主要用于<strong>在反编译视图中将某个不可识别的指令或未知函数强制当作函数调用处理。</strong></p><p><strong>__usercall</strong>： 是一种伪函数声明语法，可以手动指定调用约定、输入/输出寄存器等。</p><h1 id="too-big-stack-frame"><a href="#too-big-stack-frame" class="headerlink" title="too big stack frame"></a>too big stack frame</h1><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111451810.png" alt=""></p><p><strong>打开栈指针显示</strong><br>Options-General<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507110043765.png" alt=""><br>官方文档：<a href="https://hex-rays.com/blog/igors-tip-of-the-week-147-fixing-stack-frame-is-too-big#:~:text=To%20fix%2C%20double-click%20the%20variable%20or%20press%20Ctrl,editor%2C%20then%20undefine%20%28U%29%20the%20wrong%20stackvar%20%28s%29.">Fixing “stack frame is too big”</a><br>你总览先扒拉一下看看哪里SP不对</p><ul><li>错误创建的（按下立即作数）</li><li>故意诱导的（垃圾代码是指实际未使用的大堆栈偏移量）</li></ul><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111457121.png" alt=""><br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111500819.png" alt=""></p><p>其实和positive sp value解方法差不多，哪里不对修哪里。第一个异常增加esp，nop掉，第二个修改局部变量大小（上面贴的🔗和我文中上面都有讲怎么改）</p><h1 id="已知结构体大小创建结构体"><a href="#已知结构体大小创建结构体" class="headerlink" title="已知结构体大小创建结构体"></a>已知结构体大小创建结构体</h1><blockquote><p>IDA9.0/IDA9.1找不到Structure：<a href="https://github.com/CynicRus/StructureCreatorPlugin-for-IDA-9.0">https://github.com/CynicRus/StructureCreatorPlugin-for-IDA-9.0</a><br>local types也可以我用不习惯</p></blockquote><p><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111524952.png" alt=""><br>在Structure窗口()<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ins/Del : 插入/删除结构体</span><br><span class="line">D/A/* : 创建结构体成员（数据型/ASCII字符型/数组型）</span><br><span class="line">N : 重命名结构体或结构体成员</span><br><span class="line">U : 删除结构体成员</span><br></pre></td></tr></table></figure></p><ul><li><strong>ins创建结构体</strong></li><li><strong>D 创建字段</strong></li><li><p><strong><code>*</code> 修改数组大小</strong><br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111548776.png" alt=""></p></li><li><p><strong>添加数组间隔</strong><br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111547158.png" alt=""></p></li></ul><h1 id="跳转表修复"><a href="#跳转表修复" class="headerlink" title="跳转表修复"></a>跳转表修复</h1><p>GCC在编译超过5个switch的结构时会用跳表进行优化<br>Edit -&gt; Other —&gt; Specify switch<br><img src="https://raw.githubusercontent.com/Samsara-lo/TyporaPics/main/test/202507111556203.png" alt=""></p><ul><li>Address of Jump table：跳表的地址</li><li>Number of elements：跳转表项数</li><li>Size of table element：跳转每项的字节数</li><li>Element shift amount：这个一般情况下都是零，和跳表计算时的方式有关，</li><li>Element base value：设置为计算跳转地址时给跳表元素加的值，</li><li>Start of the switch idiom：这个默认就行，就是获取跳表值的语句的地址</li><li>Input register of switch：设置为用于给跳表寻址的寄存器</li><li>First(lowest) input value：就是 switch 的最小值了</li><li>Default jump address：也就是 default 的跳转位置，其实有时候可以不填，但是最好还是填上，这个一般在上方不远处的 cmp 指令附近。</li></ul><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI_agent_zer0_to_one（二）</title>
      <link href="/2025/03/16/AI-agent-zer0-to-one%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/03/16/AI-agent-zer0-to-one%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="AI-Agent-架构设计"><a href="#AI-Agent-架构设计" class="headerlink" title="AI Agent 架构设计"></a><strong>AI Agent 架构设计</strong></h2><h3 id="Agent-架构的基本组件"><a href="#Agent-架构的基本组件" class="headerlink" title="Agent 架构的基本组件"></a><strong>Agent 架构的基本组件</strong></h3><p>AI Agent的架构通常包含以下基本组件：感知模块、推理引擎和行动执行模块。这些组件共同工作，使Agent能够感知环境、做出决策并采取行动。</p><p><strong>感知模块</strong>：负责从环境中收集信息，并将其转换为Agent可以处理的格式。</p><p>关键特点：</p><ol><li>多模态感知：处理视觉、听觉、触觉等多种输入。</li><li>数据预处理：滤波、归一化、特征提取等。</li><li>传感器融合：整合多个传感器的数据。</li></ol><p><strong>推理引擎：</strong>Agent的”大脑”，负责处理感知到的信息，做出决策，并生成行动计划。</p><p>关键特点：</p><ol><li>知识表示：存储和组织Agent的知识和信念。</li><li>推理机制：基于规则、概率或神经网络的推理。</li><li>学习能力：从经验中更新知识和策略。</li></ol><p><strong>行动执行模块：</strong>将推理引擎的决策转化为具体的行动，并与环境进行交互。</p><p>关键特点：</p><ol><li>动作映射：将高级决策转换为低级控制命令。</li><li>反馈控制：根据执行结果调整行动。</li><li>安全机制：确保行动不会危及Agent或环境。</li></ol><h3 id="常见的-Agent-架构"><a href="#常见的-Agent-架构" class="headerlink" title="常见的 Agent 架构"></a><strong>常见的 Agent 架构</strong></h3><p><strong>反应式架构：</strong>直接将感知映射到行动，不需要内部状态或复杂的推理过程。</p><p>特点：</p><ol><li>快速响应</li><li>低计算复杂度</li><li>适合简单、明确的任务环境</li></ol><p><strong>分层架构：</strong>将Agent的功能划分为多个层次，每个层次负责不同抽象级别的任务。</p><p>特点：</p><ol><li>模块化设计</li><li>支持不同时间尺度的决策</li><li><p>适合复杂任务和长期规划</p><p><strong>BDI 架构：</strong>Belief-Desire-Intention，一种基于人类推理的Agent模型，包含信念（对世界的认知）、欲望（目标）和意图（计划）三个关键组件。</p></li></ol><p>特点：</p><ol><li>模拟人类推理过程</li><li>支持复杂的目标导向行为</li><li>适合动态、不确定的环境</li></ol><h3 id="多-Agent-系统MAS设计"><a href="#多-Agent-系统MAS设计" class="headerlink" title="多 Agent 系统MAS设计"></a><strong>多 Agent 系统MAS设计</strong></h3><p>涉及多个交互的智能Agent，这些Agent可以协作或竞争来解决复杂问题。设计多Agent系统需要考虑Agent间的通信、协作机制以及整体系统的组织结构。</p><p><strong>多Agent系统（MAS）架构设计模式</strong></p><p><strong>概述：</strong>一种用于设计和实现复杂分布式系统的架构方法。</p><ul><li>核心概念：<ul><li><strong>智能代理</strong>：智能代理是MAS的基本构建单元。每个代理具有感知、决策和行动的能力。代理可以是软件实体或物理实体，如机器人。</li><li><strong>环境</strong>：环境是代理感知和行动的场所。环境可以是物理世界、虚拟世界或混合世界。</li><li><strong>通信</strong>：代理之间通过通信进行信息交换和协作。通信可以是直接的（如消息传递）或间接的（如通过环境）。</li><li><strong>协作</strong>：代理通过协作来实现共同的目标。协作可以是显式的（如任务分配）或隐式的（如行为协调）。</li><li><strong>自治</strong>：代理具有自主决策的能力，可以根据环境变化和自身目标进行调整。</li></ul></li><li><p>MAS的系统架构：</p><ul><li><strong>感知层</strong>：负责从环境中获取信息。</li><li><strong>决策层</strong>：负责根据感知信息进行决策。</li><li><strong>行动层</strong>：负责执行决策并影响环境。</li><li><p><strong>通信层</strong>：负责代理之间的信息交换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[感知层] --&gt; B[决策层]</span><br><span class="line">    B --&gt; C[行动层]</span><br><span class="line">    B --&gt; D[通信层]</span><br><span class="line">    D --&gt; B</span><br><span class="line"></span><br><span class="line">%% 自定义样式</span><br><span class="line">classDef default fill:#ffffff,stroke:#000000,color:#000000;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>代理架构模式：</p><ul><li><strong>反应式代理</strong>：基于感知-行动规则，快速响应环境变化。</li><li><strong>认知代理</strong>：具有内部状态和推理能力，能够进行复杂决策。</li><li><strong>混合代理</strong>：结合反应式和认知特性，兼具快速响应和复杂决策能力。</li></ul></li><li>协作模式：决定了代理如何协同工作以实现共同目标。<ul><li><strong>合同网协议</strong>：通过竞标和合同机制进行任务分配。</li><li><strong>黑板系统</strong>：代理通过共享的黑板进行信息交换和协作。</li><li><strong>拍卖机制</strong>：通过拍卖方式进行资源分配和任务分配。</li></ul></li><li>通信模式：决定了代理之间的信息交换方式：<ul><li><strong>点对点通信</strong>：代理之间直接进行信息交换。</li><li><strong>广播通信</strong>：代理向所有其他代理发送信息。</li><li><strong>多播通信</strong>：代理向特定组的代理发送信息。</li></ul></li><li>组织模式：决定了代理的组织结构和角色分配。<ul><li><strong>层次结构</strong>：代理按照层次进行组织，上层代理负责协调和管理下层代理。</li><li><strong>平面结构</strong>：所有代理处于同一层次，具有相同的权利和责任。</li><li><strong>团队结构</strong>：代理被组织成多个团队，每个团队负责特定的任务或功能。</li></ul></li><li>适应性模式：决定了代理如何应对环境变化和任务变化。<ul><li><strong>学习机制</strong>：代理通过学习算法（如强化学习）来提高性能。</li><li><strong>进化机制</strong>：代理通过进化算法（如遗传算法）来优化行为。</li><li><strong>自组织机制</strong>：代理通过自组织机制（如蚁群优化）来实现全局协调。</li></ul></li><li>安全与信任模式：确保代理系统的安全性和可靠性。<ul><li><strong>身份认证</strong>：确保代理的身份真实性。</li><li><strong>访问控制</strong>：限制代理对资源的访问权限。</li><li><strong>信任管理</strong>：通过信任模型评估代理的可信度。</li></ul></li><li><p>反应式代理：通过简单的感知-行动规则进行决策。</p><ul><li>响应速度快，适用于动态变化的环境。</li><li><p>缺乏长期规划能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Algorithm ReactiveAgent</span><br><span class="line">  Input: Perception p</span><br><span class="line">  Output: Action a</span><br><span class="line"></span><br><span class="line">  RuleSet R = &#123;r1, r2, ..., rn&#125; // Set of perception-action rules</span><br><span class="line">  for each rule r in R do</span><br><span class="line">    if r.condition(p) is true then</span><br><span class="line">      return r.action</span><br><span class="line">  end for</span><br><span class="line">  return null // No applicable action</span><br></pre></td></tr></table></figure></li></ul></li><li><p>认知代理：具有内部状态和推理能力，能够进行复杂决策</p><ul><li>具有复杂决策能力，适用于复杂任务。</li><li><p>计算复杂度高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Algorithm CognitiveAgent</span><br><span class="line">  Input: Perception p, InternalState s</span><br><span class="line">  Output: Action a</span><br><span class="line"></span><br><span class="line">  BeliefSet B = UpdateBeliefs(p, s)</span><br><span class="line">  DesireSet D = GenerateDesires(B)</span><br><span class="line">  IntentionSet I = SelectIntentions(D)</span><br><span class="line">  Plan P = GeneratePlan(I)</span><br><span class="line">  ExecutePlan(P)</span><br><span class="line">  UpdateState(s, P)</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p>协作算法：实现代理之间的协作。</p><ul><li>灵活性高，适用于动态任务分配。</li><li><p>通信开销大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithm ContractNet</span><br><span class="line">  Input: Task t</span><br><span class="line">  Output: AssignedAgent a</span><br><span class="line"></span><br><span class="line">  AnnounceTask(t)</span><br><span class="line">  Bids = CollectBids()</span><br><span class="line">  BestBid = SelectBestBid(Bids)</span><br><span class="line">  AssignTask(BestBid.agent, t)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通信协议：定义代理之间的信息交换格式</p><p>  KQML优点：</p><ul><li>标准化程度高，适用于异构系统。</li><li><p>缺点是学习曲线陡峭。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message KQMLMessage</span><br><span class="line">  Performative: String // e.g., &quot;ask&quot;, &quot;tell&quot;, &quot;achieve&quot;</span><br><span class="line">  Sender: AgentID</span><br><span class="line">  Receiver: AgentID</span><br><span class="line">  Content: String</span><br><span class="line">  Language: String // e.g., &quot;Prolog&quot;, &quot;LISP&quot;</span><br><span class="line">  Ontology: String</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>代理决策模型</strong></p><p>通常基于马尔可夫决策过程（MDP）。</p><ul><li>状态空间 $S$：代理可能处于的所有状态的集合。</li><li>动作空间 $A$：代理可能采取的所有动作的集合。</li><li>状态转移函数 $P(s’|s,a)$：在状态 $s$ 执行动作 $a$ 后转移到状态 $s’$ 的概率。</li><li>奖励函数 $R(s,a)$：在状态 $s$ 执行动作 $a$ 所获得的即时奖励。</li></ul><p>常见的博弈模型：</p><ul><li><strong>零和博弈</strong>：一个代理的收益等于另一个代理的损失。</li><li><strong>合作博弈</strong>：代理通过合作实现共同利益。</li><li><strong>非合作博弈</strong>：代理独立决策以最大化自身利益。<ul><li>纳什均衡，表示在给定策略组合下，任何代理都无法通过单方面改变策略而获得更高收益。</li></ul></li></ul><p><strong>Agent间通信协议</strong></p><p>定义了Agent之间交换信息的方式和格式。</p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI安全 </tag>
            
            <tag> AI agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI_agent_zer0_to_one（一）</title>
      <link href="/2025/03/14/AI-agent-zer0-to-one%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/03/14/AI-agent-zer0-to-one%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="AI-Agent-概述与理论基础"><a href="#AI-Agent-概述与理论基础" class="headerlink" title="AI Agent 概述与理论基础"></a><strong>AI Agent 概述与理论基础</strong></h2><h3 id="AI-Agent-的定义-amp-特点"><a href="#AI-Agent-的定义-amp-特点" class="headerlink" title="AI Agent 的定义&amp;特点"></a><strong>AI Agent 的定义&amp;特点</strong></h3><p>AI Agent：智能代理，一种能够感知环境并在其中采取行动以实现特定目标的计算系统</p><ol><li>交互方式：<ul><li>传统AI系统：通常是被动的，只在接收到输入时才进行处理。</li><li>AI Agent：主动与环境交互，持续感知和行动。</li></ul></li><li>决策能力：<ul><li>传统AI系统：往往基于预定义的规则或模型进行决策。</li><li>AI Agent：能够根据环境变化动态调整决策策略。</li></ul></li><li>学习能力：<ul><li>传统AI系统：学习能力有限，通常需要人工调整。</li><li>AI Agent：具有持续学习和自我改进的能力。</li></ul></li><li>目标导向：<ul><li>传统AI系统：通常专注于解决特定问题。</li><li>AI Agent：能够处理多个目标，并在目标之间进行权衡。</li></ul></li><li>适应性：<ul><li>传统AI系统：对环境变化的适应能力较弱。</li><li>AI Agent：能够快速适应新环境和新任务。</li></ul></li></ol><h3 id="AI-Agent-的类型与应用领域"><a href="#AI-Agent-的类型与应用领域" class="headerlink" title="AI Agent 的类型与应用领域"></a><strong>AI Agent 的类型与应用领域</strong></h3><h3 id="基于规则的-Agent"><a href="#基于规则的-Agent" class="headerlink" title="基于规则的 Agent"></a><strong>基于规则的 Agent</strong></h3><p>通过预定义的规则来做出决策和执行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RuleBasedAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.rules = &#123;</span><br><span class="line">            <span class="string">&quot;sunny&quot;</span>: <span class="string">&quot;去公园&quot;</span>,</span><br><span class="line">            <span class="string">&quot;rainy&quot;</span>: <span class="string">&quot;待在家&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cloudy&quot;</span>: <span class="string">&quot;去购物中心&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decide</span>(<span class="params">self, weather</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.rules.get(weather, <span class="string">&quot;无法决定&quot;</span>)</span><br><span class="line"></span><br><span class="line">agent = RuleBasedAgent()</span><br><span class="line"><span class="built_in">print</span>(agent.decide(<span class="string">&quot;sunny&quot;</span>))  <span class="comment"># 输出：去公园</span></span><br></pre></td></tr></table></figure><h3 id="学习型-Agent"><a href="#学习型-Agent" class="headerlink" title="学习型 Agent"></a><strong>学习型 Agent</strong></h3><p>从经验中学习，不断改进其性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QLearningAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, states, actions, learning_rate=<span class="number">0.1</span>, discount_factor=<span class="number">0.9</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.q_table = np.zeros((states, actions))</span><br><span class="line">        <span class="variable language_">self</span>.lr = learning_rate</span><br><span class="line">        <span class="variable language_">self</span>.gamma = discount_factor</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, state, action, reward, next_state</span>):</span><br><span class="line">        current_q = <span class="variable language_">self</span>.q_table[state, action]</span><br><span class="line">        next_max_q = np.<span class="built_in">max</span>(<span class="variable language_">self</span>.q_table[next_state])</span><br><span class="line">        new_q = current_q + <span class="variable language_">self</span>.lr * (reward + <span class="variable language_">self</span>.gamma * next_max_q - current_q)</span><br><span class="line">        <span class="variable language_">self</span>.q_table[state, action] = new_q</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_action</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">return</span> np.argmax(<span class="variable language_">self</span>.q_table[state])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">agent = QLearningAgent(states=<span class="number">10</span>, actions=<span class="number">4</span>)</span><br><span class="line">agent.update(state=<span class="number">0</span>, action=<span class="number">1</span>, reward=<span class="number">5</span>, next_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="自主-Agent"><a href="#自主-Agent" class="headerlink" title="自主 Agent"></a><strong>自主 Agent</strong></h3><p>具有高度的独立性，能够在没有直接人类干预的情况下做出决策和执行任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutonomousAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.position = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.goal = (<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">self</span>.obstacles = <span class="built_in">set</span>([(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sense_environment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 模拟环境感知</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;current_position&quot;</span>: <span class="variable language_">self</span>.position,</span><br><span class="line">            <span class="string">&quot;nearby_obstacles&quot;</span>: [obs <span class="keyword">for</span> obs <span class="keyword">in</span> <span class="variable language_">self</span>.obstacles <span class="keyword">if</span> <span class="variable language_">self</span>.distance(obs, <span class="variable language_">self</span>.position) &lt; <span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plan_path</span>(<span class="params">self, env_data</span>):</span><br><span class="line">        <span class="comment"># 简化的路径规划</span></span><br><span class="line">        current_pos = env_data[<span class="string">&quot;current_position&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> current_pos == <span class="variable language_">self</span>.goal:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Goal reached&quot;</span></span><br><span class="line">        </span><br><span class="line">        possible_moves = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">        best_move = <span class="built_in">min</span>(possible_moves, key=<span class="keyword">lambda</span> move: <span class="variable language_">self</span>.distance(</span><br><span class="line">            (current_pos[<span class="number">0</span>] + move[<span class="number">0</span>], current_pos[<span class="number">1</span>] + move[<span class="number">1</span>]),</span><br><span class="line">            <span class="variable language_">self</span>.goal</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> best_move</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_action</span>(<span class="params">self, action</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(action, <span class="built_in">tuple</span>):</span><br><span class="line">            <span class="variable language_">self</span>.position = (<span class="variable language_">self</span>.position[<span class="number">0</span>] + action[<span class="number">0</span>], <span class="variable language_">self</span>.position[<span class="number">1</span>] + action[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.position</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">self, pos1, pos2</span>):</span><br><span class="line">        <span class="keyword">return</span> ((pos1[<span class="number">0</span>] - pos2[<span class="number">0</span>])**<span class="number">2</span> + (pos1[<span class="number">1</span>] - pos2[<span class="number">1</span>])**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            env_data = <span class="variable language_">self</span>.sense_environment()</span><br><span class="line">            action = <span class="variable language_">self</span>.plan_path(env_data)</span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">&quot;Goal reached&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            new_position = <span class="variable language_">self</span>.execute_action(action)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Moved to <span class="subst">&#123;new_position&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">agent = AutonomousAgent()</span><br><span class="line">agent.run()</span><br></pre></td></tr></table></figure><h2 id="AI-Agent-的核心技术"><a href="#AI-Agent-的核心技术" class="headerlink" title=" AI Agent 的核心技术"></a><strong> AI Agent 的核心技术</strong></h2><h3 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a><strong>机器学习基础</strong></h3><p><strong>监督学习：</strong>通过标记数据来训练模型，目标是学习输入到输出的映射，常用于分类和回归问题。</p><p><strong>无监督学习 ：</strong>处理未标记的数据，目标是发现数据中的隐藏结构。目标是发现数据的内在结构，常用于聚类、降维和异常检测。</p><p><strong>强化学习：</strong>通过与环境交互来学习最优策略的方法。目标是最大化累积奖励，适用于序列决策问题。</p><ul><li>关键概念：<ul><li>状态（State）</li><li>动作（Action）</li><li>奖励（Reward）</li><li>策略（Policy）</li><li>价值函数（Value Function）</li></ul></li></ul><h3 id="深度学习技术"><a href="#深度学习技术" class="headerlink" title="深度学习技术"></a><strong>深度学习技术</strong></h3><p>深度学习是机器学习的一个子领域，它使用多层神经网络来学习数据的层次表示。在AI Agent开发中，深度学习技术能够处理高维度、非结构化的数据，如图像、音频和文本。</p><p><strong>神经网络基础：</strong>深度学习的基础，它模仿了人脑的结构和功能。</p><ul><li>关键概念：<ul><li>神经元（Neuron）</li><li>激活函数（Activation Function）</li><li>权重和偏置（Weights and Biases）</li><li>前向传播（Forward Propagation）</li><li>反向传播（Backpropagation）</li></ul></li></ul><p><strong>卷积神经网络 (CNN)</strong>：处理网格结构数据（如图像）时表现出色<strong>，</strong>局部连接、权重共享、空间或时间下采样</p><ul><li>关键组件：<ul><li>卷积层</li><li>池化层</li><li>全连接层</li></ul></li></ul><p><strong>循环神经网络 (RNN)：</strong>适用于处理序列数据，如时间序列或自然语言。能处理变长序列、具有内部状态（记忆）、可以捕捉长期依赖关系。</p><ul><li>变体：<ul><li>长短期记忆网络（LSTM）</li><li>门控循环单元（GRU）</li></ul></li></ul><p><strong>注意力机制与 Transformer：</strong>能偶并行处理序列、捕捉长距离依赖、计算效率高。</p><p>注意力机制允许模型在处理输入时关注最相关的部分。</p><p>Transformer架构基于自注意力机制，在各种NLP任务中取得了突破性进展。</p><h3 id="自然语言处理-NLP"><a href="#自然语言处理-NLP" class="headerlink" title="自然语言处理 (NLP)"></a><strong>自然语言处理 (NLP)</strong></h3><p>自然语言处理是AI Agent与人类进行语言交互的关键技术。它使Agent能够理解、生成和处理人类语言。</p><p><strong>文本分类：</strong>文本分类是NLP的基础任务之一，它将文本分配到预定义的类别中。</p><ul><li>情感分析</li><li>垃圾邮件检测</li><li>新闻分类</li></ul><p><strong>命名实体识别NER：</strong>识别文本中的命名实体（如人名、地名、组织名等）并将其分类的任务。</p><ul><li>情感分析</li><li>垃圾邮件检测</li><li>新闻分类</li></ul><p><strong>情感分析：</strong>旨在确定文本中表达的情感态度（如积极、消极或中性）。</p><ul><li>社交媒体监控</li><li>客户反馈分析</li><li><p>市场研究</p><p><strong>机器翻译：</strong>将文本从一种语言自动翻译成另一种语言的任务。</p></li><li><p>跨语言通信</p></li><li>多语言内容创建</li><li>国际商务</li></ul><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a><strong>计算机视觉</strong></h3><p>计算机视觉使AI Agent能够理解和处理视觉信息。</p><p><strong>图像分类：</strong>识别图像中主要对象或场景的任务。</p><ul><li>医学诊断</li><li>自动标记</li><li>内容过滤</li></ul><p><strong>目标检测：</strong>识别图像中的对象&amp;定位它们的位置。</p><ul><li>自动驾驶</li><li>安全监控</li><li>零售分析</li></ul><p><strong>图像分割：</strong>将图像划分为多个语义区域，为每个像素分配一个类别标签。</p><ul><li>医学图像分析</li><li>自动驾驶场景理解</li><li>增强现实</li></ul><p><strong>人脸识别：</strong>涉及检测、对齐和识别人脸。</p><ul><li>安全系统</li><li>用户认证</li><li>社交媒体标记</li></ul><h3 id="决策与规划"><a href="#决策与规划" class="headerlink" title="决策与规划"></a><strong>决策与规划</strong></h3><p>AI Agent自主行动的核心能力，使其能够在复杂环境中做出明智的选择并制定长期策略。</p><p><strong>决策树：</strong>一种直观的决策模型，适用于分类和回归任务。</p><ul><li>风险评估</li><li>客户分类</li><li>医疗诊断</li></ul><p><strong>蒙特卡洛树搜索（MCTS）</strong>：一种用于决策过程的启发式搜索算法，特别适用于具有大状态空间的问题。</p><ul><li>游戏AI（如围棋）</li><li>路径规划</li><li>资源分配</li></ul><p><strong>A*算法</strong>：一种用于图形搜索和路径规划的启发式算法。</p><ul><li>导航系统</li><li>机器人路径规划</li><li>游戏AI寻路</li></ul><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI安全 </tag>
            
            <tag> AI agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的大模型搭建之旅</title>
      <link href="/2025/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/"/>
      <url>/2025/01/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h1 id="一、搭建开发环境"><a href="#一、搭建开发环境" class="headerlink" title="一、搭建开发环境"></a>一、搭建开发环境</h1><ul><li><h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a><strong>python3</strong></h2></li><li><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a><strong>pytorch</strong></h2></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy tqdm matplotlib</span><br></pre></td></tr></table></figure><ul><li><h2 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a><strong>依赖库</strong></h2></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy tqdm matplotlib</span><br></pre></td></tr></table></figure><ul><li><h2 id="vscode-Jupyter"><a href="#vscode-Jupyter" class="headerlink" title="vscode / Jupyter"></a><strong>vscode / Jupyter</strong></h2></li></ul><h1 id="二、准备一个数据集"><a href="#二、准备一个数据集" class="headerlink" title="二、准备一个数据集"></a>二、准备一个数据集</h1><ul><li><a href="https://blog.salesforceairesearch.com/the-wikitext-long-term-dependency-language-modeling-dataset/">WikiText</a></li><li><a href="https://github.com/jcpeterson/openwebtext">OpenWebText</a></li><li>anythingelse</li></ul><h2 id="1-准备环境（以openwebtext为例）"><a href="#1-准备环境（以openwebtext为例）" class="headerlink" title="1.准备环境（以openwebtext为例）"></a>1.准备环境（以openwebtext为例）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JCPETERSON/OpenwebText.git</span><br><span class="line"><span class="built_in">cd</span> OpenwebText</span><br></pre></td></tr></table></figure><p>python版本得高一点，我用的3.12，3.8不行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>如果老报错版本问题就直接下（没报错就不改）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4 certifi chardet cssselect feedfinder2 feedparser htmlmin idna jieba3k lxml newspaper3k nltk numpy pandas pillow python-dateutil pytorch-pretrained-bert pytz pyyaml recordtype requests-file requests singledispatch six soupsieve spacy tinysegmenter tldextract tqdm urllib3 urlparse2 pycurl pebble chardet transformers</span><br></pre></td></tr></table></figure><h2 id="2-加载-amp-预处理数据"><a href="#2-加载-amp-预处理数据" class="headerlink" title="2.加载&amp;预处理数据"></a>2.加载&amp;预处理数据</h2><h3 id="1-、直接下载Pushshift-数据"><a href="#1-、直接下载Pushshift-数据" class="headerlink" title="(1)、直接下载Pushshift 数据"></a>(1)、直接下载<a href="https://mega.nz/folder/EZZD0YwJ#9_PlEQzdMVLaNdKv_ICNVQ">Pushshift 数据</a></h3><p>这里面的url是已经去重了的，正常流程如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提取 URL</span><br><span class="line">python extract_urls.py --single_file pushshift_dumps/RS_v2_2005-06.xz</span><br><span class="line"></span><br><span class="line">想提取一个时间范围内的 URL</span><br><span class="line">python extract_urls.py --year_start 2016 --year_end 2018</span><br><span class="line"></span><br><span class="line">去重 URL</span><br><span class="line">python deduplicate_urls.py --input_dir url_dumps</span><br></pre></td></tr></table></figure><h3 id="2-、下载HTML数据"><a href="#2-、下载HTML数据" class="headerlink" title="(2)、下载HTML数据"></a>(2)、下载HTML数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 download.py D:\Tools\openwebtext\URLs\RS_2011-01.bz2.deduped.txt --n_procs 100 --scraper raw --chunk_size 100000 --compress --<span class="built_in">timeout</span> 30</span><br></pre></td></tr></table></figure><p>将抓取的 HTML 页面存储在 <code>scraped</code> 文件夹中，并压缩存档。</p><p>等挺久的，挂着睡觉了。默认它done了就是好了（）</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501281514200.png" alt="1738029502506.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501281515362.png" alt="1738029524605.png"></p><h3 id="3-、从HTML中提取文本"><a href="#3-、从HTML中提取文本" class="headerlink" title="(3)、从HTML中提取文本"></a>(3)、从HTML中提取文本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade newspaper3k</span><br></pre></td></tr></table></figure><p>把extract_text.py里的save_parsed_file改成如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_parsed_file</span>(<span class="params">filename, text, out_dir</span>):</span><br><span class="line">    <span class="comment"># 获取文件的完整路径</span></span><br><span class="line">    file_path = os.path.join(out_dir, filename)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保目录存在，如果不存在则创建</span></span><br><span class="line">    os.makedirs(os.path.dirname(file_path), exist_ok=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">        handle.write(text)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501281514962.png" alt="1738048415160.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 extract_text.py --html_archive scraped/RS_2011-01-1_data.xz --n_procs 100</span><br></pre></td></tr></table></figure><p>从 HTML 中提取出文本内容并保存为 <code>.txt</code> 文件.</p><p>—如果中间有报错重新来的话，记得把原来提取的文件删掉，文件夹在scraped里</p><h3 id="4-、分词处理"><a href="#4-、分词处理" class="headerlink" title="(4)、分词处理"></a>(4)、分词处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download en_core_web_sm</span><br></pre></td></tr></table></figure><p>更改tokenize_text.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_encoding</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检测文件的实际编码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw_data = f.read(<span class="number">1024</span>)  <span class="comment"># 读取文件的前 1KB 数据</span></span><br><span class="line">    result = chardet.detect(raw_data)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&#x27;encoding&#x27;</span>] <span class="keyword">or</span> <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 如果检测失败，默认返回 &#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_tokenized_text</span>(<span class="params">output_dir, filename, text</span>):</span><br><span class="line">    <span class="comment"># 构建完整输出路径</span></span><br><span class="line">    text_file = os.path.join(output_dir, filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保目标目录存在</span></span><br><span class="line">    os.makedirs(os.path.dirname(text_file), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(text_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fo:</span><br><span class="line">        fo.write(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokenizeSpacy</span>(<span class="params">args</span>):</span><br><span class="line">    nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>)  <span class="comment"># 加载 spaCy 模型</span></span><br><span class="line">    extraction_file_paths = glob.glob(args.input_glob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> extraction_file_path <span class="keyword">in</span> extraction_file_paths:</span><br><span class="line">        path, filename = os.path.split(extraction_file_path)</span><br><span class="line">        text_file = os.path.join(</span><br><span class="line">            args.output_dir, filename.replace(<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.tokenized.txt&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保输出目录存在</span></span><br><span class="line">        os.makedirs(os.path.dirname(text_file), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测文件编码</span></span><br><span class="line">        file_encoding = detect_encoding(extraction_file_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 打开输入文件和输出文件</span></span><br><span class="line">            <span class="keyword">with</span> io.<span class="built_in">open</span>(extraction_file_path, <span class="string">&#x27;r&#x27;</span>, encoding=file_encoding) <span class="keyword">as</span> fi, \</span><br><span class="line">                    io.<span class="built_in">open</span>(text_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fo:</span><br><span class="line"></span><br><span class="line">                omitted_line_count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(line.strip()) &gt; <span class="number">0</span>:  <span class="comment"># 忽略空行</span></span><br><span class="line">                        doc = nlp(line)</span><br><span class="line">                        fo.write(<span class="string">&#x27; &#x27;</span>.join([x.text <span class="keyword">for</span> x <span class="keyword">in</span> doc]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        omitted_line_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Omitted <span class="subst">&#123;omitted_line_count&#125;</span> empty lines from <span class="subst">&#123;filename&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Failed to decode <span class="subst">&#123;extraction_file_path&#125;</span> with encoding <span class="subst">&#123;file_encoding&#125;</span>. Skipping this file.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--input_glob&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;*.txt&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--output_dir&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;tokenized&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--tokenizer&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;spacy&#x27;</span>, choices=[<span class="string">&#x27;spacy&#x27;</span>, <span class="string">&#x27;gpt2&#x27;</span>])</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--combine&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1e8</span>, <span class="built_in">help</span>=<span class="string">&quot;min tokens per file in gpt2 mode&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--file_bs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&quot;files per batch in gpt2 mode&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析命令行参数</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    os.makedirs(args.output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据 tokenizer 选择执行的函数</span></span><br><span class="line">    <span class="keyword">if</span> args.tokenizer == <span class="string">&#x27;spacy&#x27;</span>:</span><br><span class="line">        tokenizeSpacy(args)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;GPT-2 tokenizer is not implemented in this version.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 tokenize_text.py --input_glob <span class="string">&quot;parsed/RS_2011-01/*.txt&quot;</span> --output_dir tokenized</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501282028656.png" alt="1738067274379.png"></p><h1 id="三、构建和训练-GPT-类似模型"><a href="#三、构建和训练-GPT-类似模型" class="headerlink" title="三、构建和训练 GPT 类似模型"></a>三、构建和训练 GPT 类似模型</h1><p>下面的文件层级关系如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gpt_project/</span><br><span class="line">├── model/</span><br><span class="line">│   ├── gpt.py</span><br><span class="line">│   ├── transformer_block.py</span><br><span class="line">├── data/</span><br><span class="line">│   ├── dataset.py</span><br><span class="line">│   ├── tokenizer.py  # 可选</span><br><span class="line">│   ├── tokenized/  # 存放所有分词好的 .txt 文件</span><br><span class="line">├── train/</span><br><span class="line">│   ├── train.py  # 训练代码</span><br><span class="line">|——train_model/</span><br><span class="line">|</span><br><span class="line">├── inference.py  # 生成文本</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501292326878.png" alt="1738164364319.png"></p><h2 id="1-dataset-py"><a href="#1-dataset-py" class="headerlink" title="1. dataset.py"></a>1. <strong>dataset.py</strong></h2><p>用于处理数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dataset.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDataset</span>(torch.utils.data.Dataset):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, directory_path, seq_length, tokenizer</span>):</span><br><span class="line">        <span class="variable language_">self</span>.seq_length = seq_length</span><br><span class="line">        <span class="variable language_">self</span>.tokenizer = tokenizer</span><br><span class="line">        <span class="variable language_">self</span>.data = []</span><br><span class="line">        <span class="variable language_">self</span>.vocab = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.inverse_vocab = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步：统计所有单词的频率</span></span><br><span class="line">        word_counter = Counter()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历 directory_path 目录中的所有 .tokenized.txt 文件</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory_path):</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&quot;.tokenized.txt&quot;</span>):</span><br><span class="line">                file_path = os.path.join(directory_path, filename)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    words = f.read().split()</span><br><span class="line">                    word_counter.update(words)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二步：创建词汇表，给每个单词分配一个 ID</span></span><br><span class="line">        <span class="variable language_">self</span>.vocab = &#123;word: idx + <span class="number">1</span> <span class="keyword">for</span> idx, (word, _) <span class="keyword">in</span> <span class="built_in">enumerate</span>(word_counter.items())&#125;</span><br><span class="line">        <span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>] = <span class="number">0</span>  <span class="comment"># 为 padding 添加一个 ID</span></span><br><span class="line">        <span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;unk&gt;&#x27;</span>] = <span class="built_in">len</span>(<span class="variable language_">self</span>.vocab)  <span class="comment"># 为未知单词添加一个 ID</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建逆词汇表</span></span><br><span class="line">        <span class="variable language_">self</span>.inverse_vocab = &#123;idx: word <span class="keyword">for</span> word, idx <span class="keyword">in</span> <span class="variable language_">self</span>.vocab.items()&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第三步：将文本转换为 token ID</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory_path):</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&quot;.tokenized.txt&quot;</span>):</span><br><span class="line">                file_path = os.path.join(directory_path, filename)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    words = f.read().split()</span><br><span class="line">                    <span class="comment"># 将每个单词转换为 token ID，如果不在词汇表中则使用 &lt;unk&gt;</span></span><br><span class="line">                    token_ids = [<span class="variable language_">self</span>.vocab.get(word, <span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;unk&gt;&#x27;</span>]) <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line">                    <span class="variable language_">self</span>.data.append(token_ids)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将数据转化为训练所需的序列形式</span></span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="variable language_">self</span>.pad_sequence(seq) <span class="keyword">for</span> seq <span class="keyword">in</span> <span class="variable language_">self</span>.data]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        input_text = <span class="variable language_">self</span>.data[idx]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 编码输入文本</span></span><br><span class="line">        input_ids = torch.tensor(input_text)  <span class="comment"># 转换为 tensor</span></span><br><span class="line">        target_ids = input_ids.clone()  <span class="comment"># 使用输入作为目标</span></span><br><span class="line">        <span class="keyword">return</span> input_ids, target_ids</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pad_sequence</span>(<span class="params">self, seq</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;填充序列到 seq_length&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(seq) &lt; <span class="variable language_">self</span>.seq_length:</span><br><span class="line">            <span class="comment"># 使用 pad token 填充</span></span><br><span class="line">            seq += [<span class="variable language_">self</span>.vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]] * (<span class="variable language_">self</span>.seq_length - <span class="built_in">len</span>(seq))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果超出 seq_length，则截断</span></span><br><span class="line">            seq = seq[:<span class="variable language_">self</span>.seq_length]</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    def __getitem__(self, idx):</span></span><br><span class="line"><span class="string">        input_ids = torch.tensor(self.data[idx], dtype=torch.long)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 如果输入序列长度小于 seq_length，进行填充</span></span><br><span class="line"><span class="string">        padding_length = self.seq_length - input_ids.size(0)</span></span><br><span class="line"><span class="string">        if padding_length &gt; 0:</span></span><br><span class="line"><span class="string">            padding = torch.tensor([self.vocab[&#x27;&lt;pad&gt;&#x27;]] * padding_length, dtype=torch.long)</span></span><br><span class="line"><span class="string">            input_ids = torch.cat([input_ids, padding], dim=0)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 设置 target_ids 为 input_ids 的下一个 token（即语言模型的训练目标）</span></span><br><span class="line"><span class="string">        target_ids = input_ids[1:].clone()</span></span><br><span class="line"><span class="string">        target_ids = torch.cat([target_ids, torch.tensor([self.vocab[&#x27;&lt;pad&gt;&#x27;]], dtype=torch.long)])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return input_ids, target_ids</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-gpt-py"><a href="#2-gpt-py" class="headerlink" title="2.gpt.py"></a>2.gpt.py</h2><p>实现 GPT 模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gpt.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Adding to sys.path:&quot;</span>, project_root)</span><br><span class="line">sys.path.append(project_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.transformer_block <span class="keyword">import</span> TransformerBlock</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, num_layers, num_heads, hidden_dim, max_length</span>):</span><br><span class="line">        <span class="built_in">super</span>(GPT, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.hidden_dim = hidden_dim  <span class="comment"># 添加 hidden_dim 变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, num_heads, num_layers, max_length</span>):</span><br><span class="line">        <span class="built_in">super</span>(GPT, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        <span class="variable language_">self</span>.position_embedding = nn.Embedding(max_length, embed_size)</span><br><span class="line">        <span class="variable language_">self</span>.blocks = nn.ModuleList([</span><br><span class="line">            TransformerBlock(embed_size, num_heads, embed_size * <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_layers)</span><br><span class="line">        ])</span><br><span class="line">        <span class="variable language_">self</span>.fc_out = nn.Linear(embed_size, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        batch_size, seq_length = x.shape</span><br><span class="line">        positions = torch.arange(<span class="number">0</span>, seq_length).expand(batch_size, seq_length)</span><br><span class="line">        x = <span class="variable language_">self</span>.embedding(x) + <span class="variable language_">self</span>.position_embedding(positions)</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">            x = block(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fc_out(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, input_ids, max_length=<span class="number">100</span>, temperature=<span class="number">1.0</span>, top_k=<span class="number">50</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取初始输出</span></span><br><span class="line">        generated_ids = input_ids</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_length):</span><br><span class="line">            outputs = <span class="variable language_">self</span>(generated_ids)</span><br><span class="line">            logits = outputs  <span class="comment"># 假设模型的输出是 logits</span></span><br><span class="line">            logits = logits[:, -<span class="number">1</span>, :]  <span class="comment"># 只关注最新生成的 token</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 应用温度采样</span></span><br><span class="line">            logits = logits / temperature</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Top-K 采样</span></span><br><span class="line">            <span class="keyword">if</span> top_k &gt; <span class="number">0</span>:</span><br><span class="line">                top_k_values, top_k_indices = torch.topk(logits, top_k)</span><br><span class="line">                top_k_probs = F.softmax(top_k_values, dim=-<span class="number">1</span>)</span><br><span class="line">                next_token = torch.multinomial(top_k_probs, <span class="number">1</span>)</span><br><span class="line">                next_token = top_k_indices.gather(-<span class="number">1</span>, next_token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 默认采样</span></span><br><span class="line">                probs = F.softmax(logits, dim=-<span class="number">1</span>)</span><br><span class="line">                next_token = torch.multinomial(probs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加生成的 token 到输入序列</span></span><br><span class="line">            generated_ids = torch.cat([generated_ids, next_token], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generated_ids</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="3-transformer-block-py"><a href="#3-transformer-block-py" class="headerlink" title="3.transformer_block.py"></a>3.transformer_block.py</h2><p>用于实现 GPT 模型的一个基本组件——Transformer 块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># transformer_block.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AttentionHead</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_size, head_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.q = nn.Linear(embed_size, head_size, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.k = nn.Linear(embed_size, head_size, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.v = nn.Linear(embed_size, head_size, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.scale = head_size ** -<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        q = <span class="variable language_">self</span>.q(x)</span><br><span class="line">        k = <span class="variable language_">self</span>.k(x)</span><br><span class="line">        v = <span class="variable language_">self</span>.v(x)</span><br><span class="line">        scores = torch.matmul(q, k.transpose(-<span class="number">2</span>, -<span class="number">1</span>)) * <span class="variable language_">self</span>.scale</span><br><span class="line">        attention = torch.softmax(scores, dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.matmul(attention, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_size, num_heads, feed_forward_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.attention = nn.MultiheadAttention(embed_dim=embed_size, num_heads=num_heads)</span><br><span class="line">        <span class="variable language_">self</span>.ff = nn.Sequential(</span><br><span class="line">            nn.Linear(embed_size, feed_forward_size),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(feed_forward_size, embed_size),</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.norm1 = nn.LayerNorm(embed_size)</span><br><span class="line">        <span class="variable language_">self</span>.norm2 = nn.LayerNorm(embed_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        attention_out, _ = <span class="variable language_">self</span>.attention(x, x, x)</span><br><span class="line">        x = <span class="variable language_">self</span>.norm1(x + attention_out)</span><br><span class="line">        ff_out = <span class="variable language_">self</span>.ff(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.norm2(x + ff_out)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-generate-py"><a href="#4-generate-py" class="headerlink" title="4. generate.py"></a>4. <strong>generate.py</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> model.gpt <span class="keyword">import</span> GPT</span><br><span class="line"><span class="keyword">from</span> data.tokenizer <span class="keyword">import</span> SimpleTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_text</span>(<span class="params">prompt, model, tokenizer, max_length=<span class="number">50</span></span>):</span><br><span class="line">    tokens = tokenizer.encode(prompt)</span><br><span class="line">    input_data = torch.tensor([tokens])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_length):</span><br><span class="line">            output = model(input_data)</span><br><span class="line">            next_token = torch.argmax(output[:, -<span class="number">1</span>, :], dim=-<span class="number">1</span>)</span><br><span class="line">            input_data = torch.cat([input_data, next_token.unsqueeze(<span class="number">0</span>)], dim=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> next_token.item() == tokenizer.word_to_idx[<span class="string">&quot;&lt;END&gt;&quot;</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokenizer.decode(input_data[<span class="number">0</span>].tolist())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    vocab_size = <span class="number">10000</span></span><br><span class="line">    embed_size = <span class="number">128</span></span><br><span class="line">    num_heads = <span class="number">8</span></span><br><span class="line">    num_layers = <span class="number">4</span></span><br><span class="line">    max_length = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load pretrained model</span></span><br><span class="line">    model = GPT(vocab_size, embed_size, num_heads, num_layers, max_length)</span><br><span class="line">    tokenizer = SimpleTokenizer(vocab_size)</span><br><span class="line">    tokenizer.build_vocab(<span class="string">&quot;This is a small test corpus &lt;END&gt;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    prompt = <span class="string">&quot;This is a&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(generate_text(prompt, model, tokenizer))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-train-py"><a href="#5-train-py" class="headerlink" title="5.train.py"></a>5.<strong>train.py</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train/train.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Adding to sys.path:&quot;</span>, project_root)</span><br><span class="line">sys.path.append(project_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> data.dataset <span class="keyword">import</span> TextDataset</span><br><span class="line"><span class="keyword">from</span> model.gpt <span class="keyword">import</span> GPT</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> AdamW</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> StepLR</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> GPT2LMHeadModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在外部加载模型和分词器</span></span><br><span class="line">model = GPT2LMHeadModel.from_pretrained(<span class="string">&#x27;gpt2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="comment"># 加载分词器</span></span><br><span class="line">    tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;gpt2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置设备</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    model.to(device)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 配置数据集</span></span><br><span class="line">    dataset = TextDataset(directory_path=<span class="string">&quot;data/tokenized&quot;</span>, seq_length=<span class="number">128</span>, tokenizer=tokenizer)</span><br><span class="line">    data_loader = DataLoader(dataset, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置优化器</span></span><br><span class="line">    optimizer = AdamW(model.parameters(), lr=<span class="number">1e-5</span>)</span><br><span class="line">    scheduler = StepLR(optimizer, step_size=<span class="number">5</span>, gamma=<span class="number">0.5</span>)  <span class="comment"># 每5个epoch减少学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 假设训练3个epoch</span></span><br><span class="line">        total_loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> batch_idx, (input_ids, target_ids) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            input_ids = input_ids.to(device)</span><br><span class="line">            target_ids = target_ids.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            outputs = model(input_ids, labels=target_ids)</span><br><span class="line">            loss = outputs.loss</span><br><span class="line">            total_loss += loss.item()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反向传播</span></span><br><span class="line">            loss.backward()</span><br><span class="line">            <span class="comment"># 训练过程中添加梯度裁剪</span></span><br><span class="line">            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=<span class="number">1.0</span>)</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出每个 epoch 的损失</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>, Loss: <span class="subst">&#123;total_loss / <span class="built_in">len</span>(data_loader)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 学习率调度</span></span><br><span class="line">        scheduler.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存训练好的模型</span></span><br><span class="line">    torch.save(model.state_dict(), <span class="string">&quot;trained_model/model.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tokenizer.save_pretrained(<span class="string">&quot;trained_model&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-inference-py"><a href="#6-inference-py" class="headerlink" title="6. inference.py"></a>6. <strong>inference.py</strong></h2><p>这是推理脚本，用于加载训练好的模型并进行推理（生成预测）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inference.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Adding to sys.path:&quot;</span>, project_root)</span><br><span class="line">sys.path.append(project_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.gpt <span class="keyword">import</span> GPT</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_model</span>():</span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model = GPT(vocab_size=<span class="number">50000</span>, embed_size=<span class="number">256</span>, num_layers=<span class="number">6</span>, num_heads=<span class="number">8</span>, max_length=<span class="number">512</span>)</span><br><span class="line">    model.load_state_dict(torch.load(<span class="string">&quot;trained_model/model.pth&quot;</span>), strict=<span class="literal">False</span>)</span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载分词器</span></span><br><span class="line">    tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;gpt2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model, tokenizer  <span class="comment"># 返回模型和分词器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat</span>():</span><br><span class="line">    model, tokenizer = load_model()  <span class="comment"># 加载模型和分词器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        text = <span class="built_in">input</span>(<span class="string">&quot;Input: &quot;</span>)  <span class="comment"># 获取用户输入</span></span><br><span class="line">        <span class="keyword">if</span> text.lower() == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对输入文本进行编码</span></span><br><span class="line">        input_ids = tokenizer.encode(text, return_tensors=<span class="string">&#x27;pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成文本</span></span><br><span class="line">        generated_ids = model.generate(input_ids, max_length=<span class="number">100</span>, temperature=<span class="number">1.0</span>, top_k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解码并打印生成的文本</span></span><br><span class="line">        output_text = tokenizer.decode(generated_ids[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;GPT: <span class="subst">&#123;output_text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    chat()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 train/train.py</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501292344755.png" alt="1738165457988.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python312 inference.py</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501292343248.png" alt="1738165422521.png"></p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-课程总结</title>
      <link href="/2025/01/19/Android-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/19/Android-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>参考</p><p>正己老师的《安卓逆向这档事》</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="与手机建立连接"><a href="#与手机建立连接" class="headerlink" title="与手机建立连接"></a>与手机建立连接</h3><h4 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:端口号</span><br><span class="line">adb devices</span><br><span class="line">adb -s 127.0.0.1:端口号 shell</span><br></pre></td></tr></table></figure><p>注意：我的是mumu模拟器，每次都要到多开器里面查看adb端口建立连接，但是正常应该可以直接adb devices&amp;adb shell。模拟器是这样的TT</p><h4 id="真机"><a href="#真机" class="headerlink" title="真机"></a>真机</h4><p>手机开开发者版本和USB调试，然后通过数据线连接</p><ul><li>有一些数据线只能充电，第一次连接电脑的时候手机上会弹出要求允许 USB 调试访问。确保你点击了“允许”按钮。</li><li>如果没弹出就换一根数据线/重启。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb shell</span><br></pre></td></tr></table></figure><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><h4 id="传文件进windows"><a href="#传文件进windows" class="headerlink" title="传文件进windows"></a>传文件进windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb -s 127.0.0.1:16384 shell pm list packages</span><br><span class="line">adb -s 127.0.0.1:16384 shell pm path com.chaoxing.mobile</span><br><span class="line">adb -s 127.0.0.1:16384 pull /data/app/~~EerlSikM2HRGxvcqMsmfIg==/com.chaoxing.mobile-_E7VgeY662xxYG0tGxtKrQ==/base.apk D:\桌面\xuexitong</span><br></pre></td></tr></table></figure><h4 id="推送文件至模拟器"><a href="#推送文件至模拟器" class="headerlink" title="推送文件至模拟器"></a>推送文件至模拟器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push &quot;D:\LeStoreDownload\网页\frida-clr-16.5.7-windows-x86_64.dll\frida-clr-16.5.7-windows-x86_64.dll&quot; /data/local/tmp/</span><br><span class="line">adb shell ls /data/local/tmp/</span><br></pre></td></tr></table></figure><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install  a.apk</span><br></pre></td></tr></table></figure><h3 id="初识APK"><a href="#初识APK" class="headerlink" title="初识APK"></a>初识APK</h3><p><strong>APK</strong>：全称Android Package，相当于压缩文件，把.apk后缀改为.zip就可以解压</p><ul><li><strong>assets目录 </strong>：存放apk静态资源，视频图片等。</li><li><strong>lib目录</strong>：armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件。</li><li><strong>META-INF目录</strong>：存放签名信息，用来验证APK的完整性。</li><li><strong>res文件</strong>：资源文件，图片字符串等（会转为二进制格式）</li><li><strong>AndroidMainfest.xml文件</strong>：APK的应用清单，描述应用名字版本等</li><li><strong>classes.dex文件</strong>：classes.dex是Java源码编码后的java字节码，<strong>APK运行的主要逻辑</strong></li><li><strong>resources.arsc</strong>：resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</li></ul><p><strong>assets和res有什么不同？</strong></p><p>assets主要存放的是应用内显示出来的图片，不会转为二进制格式</p><p>res是ui设计相关的文件，会转为二进制格式，经过压缩优化</p><h3 id="JVM、Dalvik、ART"><a href="#JVM、Dalvik、ART" class="headerlink" title="JVM、Dalvik、ART"></a>JVM、Dalvik、ART</h3><p>JVM是JAVA虚拟机，运行JAVA字节码程序<br>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)<br>Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异</p><h3 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h3><div class="table-container"><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Activity(活动)</td><td style="text-align:left">在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。</td></tr><tr><td style="text-align:left">Service(服务)</td><td style="text-align:left">Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。</td></tr><tr><td style="text-align:left">Broadcast Receiver(广播接收器)</td><td style="text-align:left">一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。</td></tr><tr><td style="text-align:left">Content Provider(内容提供者)</td><td style="text-align:left">作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等）</td></tr></tbody></table></div><h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><div class="table-container"><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">onCreate()</td><td style="text-align:left">一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td style="text-align:left">onStart()</td><td style="text-align:left">当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td style="text-align:left">onResume()</td><td style="text-align:left">这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td style="text-align:left">onPause()</td><td style="text-align:left">这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td style="text-align:left">onStop()</td><td style="text-align:left">这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td style="text-align:left">onDestroy()</td><td style="text-align:left">这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td style="text-align:left">onRestart()</td><td style="text-align:left">当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501190150532.png" alt="1737222612157.png"></p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><h4 id="1-修改debug权限"><a href="#1-修改debug权限" class="headerlink" title="1.修改debug权限"></a>1.修改debug权限</h4><p><strong>方法一</strong>:在AndroidManifest.xml里添加可调试权限（在application里）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:debuggable=&quot;true&quot;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：XappDebug模块hook对应的app</p><p><a href="https://github.com/Palatis/XAppDebug">XappDebug</a></p><p><strong>方法三</strong>：Magisk命令(重启失效)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>  adb shell #adb进入命令行模式</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span>  su #切换至超级用户</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span>  magisk resetprop ro.debuggable 1</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span>  stop;start; #一定要通过该方式重启</span><br></pre></td></tr></table></figure><p><strong>方法四</strong>:刷入MagiskHide Props Config模块</p><p>一般来说，在4选项中如果有ro.debuggable那就直接修改<br>没有的话就选5<br><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501211617314.png" alt="1737447405593.png"></p><p>修改ro.debuggable的值为1</p><h4 id="2-端口转发以及开启adb权限"><a href="#2-端口转发以及开启adb权限" class="headerlink" title="2.端口转发以及开启adb权限"></a>2.端口转发以及开启adb权限</h4><p>版本号点击七次开启开发者模式并开启adb调试权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:9999 tcp:9999</span><br></pre></td></tr></table></figure><h4 id="3-下段点"><a href="#3-下段点" class="headerlink" title="3.下段点"></a>3.下段点</h4><p>ctrl+b下断点</p><h4 id="4-debug模式启动"><a href="#4-debug模式启动" class="headerlink" title="4.debug模式启动"></a>4.debug模式启动</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n <span class="keyword">com</span>.zj.wuaipojie/.ui.MainActivity</span><br></pre></td></tr></table></figure><p>adb shell am start -D -n<br>adb shell am start -D -n 包名/类名<br>am start -n 表示启动一个activity<br>am start -D 表示将应用设置为可调试模式</p><h4 id="5-Jeb附加调试进程"><a href="#5-Jeb附加调试进程" class="headerlink" title="5.Jeb附加调试进程"></a>5.Jeb附加调试进程</h4><h3 id="Log插桩"><a href="#Log插桩" class="headerlink" title="Log插桩"></a>Log插桩</h3><p>定义：Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;对应寄存器&#125;, <span class="class">Lcom/mtools/LogUtils;</span>-&gt;v(<span class="class">Ljava/lang/Object;</span>)V</span><br></pre></td></tr></table></figure><h2 id="smali及其语法"><a href="#smali及其语法" class="headerlink" title="smali及其语法"></a>smali及其语法</h2><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">.class</td><td style="text-align:left">类名</td></tr><tr><td style="text-align:left">.super</td><td style="text-align:left">父类名，继承的上级类名名称</td></tr><tr><td style="text-align:left">.source</td><td style="text-align:left">源名</td></tr><tr><td style="text-align:left">.field</td><td style="text-align:left">变量</td></tr><tr><td style="text-align:left">.method</td><td style="text-align:left">方法名</td></tr><tr><td style="text-align:left">.register</td><td style="text-align:left">寄存器</td></tr><tr><td style="text-align:left">.end method</td><td style="text-align:left">方法名的结束</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">公有</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">半公开，只有同一家人才能用</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">私有，只能自己使用</td></tr><tr><td style="text-align:left">.parameter</td><td style="text-align:left">方法参数</td></tr><tr><td style="text-align:left">.prologue</td><td style="text-align:left">方法开始</td></tr><tr><td style="text-align:left">.line xxx</td><td style="text-align:left">位于第xxx行</td></tr></tbody></table></div><h3 id="数据类型对应"><a href="#数据类型对应" class="headerlink" title="数据类型对应"></a>数据类型对应</h3><div class="table-container"><table><thead><tr><th style="text-align:left">smali类型</th><th style="text-align:left">java类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">V</td><td style="text-align:left">void</td><td style="text-align:left">无返回值</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">boolean</td><td style="text-align:left">布尔值类型，返回0或1</td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">byte</td><td style="text-align:left">字节类型，返回字节</td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">short</td><td style="text-align:left">短整数类型，返回数字</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">char</td><td style="text-align:left">字符类型，返回字符</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">int</td><td style="text-align:left">整数类型，返回数字</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">long （64位 需要2个寄存器存储）</td><td style="text-align:left">长整数类型，返回数字</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">float</td><td style="text-align:left">单浮点类型，返回数字</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">double （64位 需要2个寄存器存储）</td><td style="text-align:left">双浮点类型，返回数字</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">String</td><td style="text-align:left">文本类型，返回字符串</td></tr><tr><td style="text-align:left">Lxxx/xxx/xxx</td><td style="text-align:left">object</td><td style="text-align:left">对象类型，返回对象</td></tr></tbody></table></div><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container"><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">const</td><td style="text-align:left">重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td style="text-align:left">const-string</td><td style="text-align:left">重写字符串内容</td></tr><tr><td style="text-align:left">const-wide</td><td style="text-align:left">重写长整数类型，多用于修改到期时间。</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">返回指令</td></tr><tr><td style="text-align:left">if-eq</td><td style="text-align:left">全称equal(a=b)，比较寄存器ab内容，相同则跳</td></tr><tr><td style="text-align:left">if-ne</td><td style="text-align:left">全称not equal(a!=b)，ab内容不相同则跳</td></tr><tr><td style="text-align:left">if-eqz</td><td style="text-align:left">全称equal zero(a=0)，z即是0的标记，a等于0则跳</td></tr><tr><td style="text-align:left">if-nez</td><td style="text-align:left">全称not equal zero(a!=0)，a不等于0则跳</td></tr><tr><td style="text-align:left">if-ge</td><td style="text-align:left">全称greater equal(a&gt;=b)，a大于或等于则跳</td></tr><tr><td style="text-align:left">if-le</td><td style="text-align:left">全称little equal(a&lt;=b)，a小于或等于则跳</td></tr><tr><td style="text-align:left">goto</td><td style="text-align:left">强制跳到指定位置</td></tr><tr><td style="text-align:left">switch</td><td style="text-align:left">分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td style="text-align:left">iget</td><td style="text-align:left">获取寄存器数据</td></tr></tbody></table></div><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>在smail里所有操作通过寄存器来进行</p><ul><li><strong>本地寄存器</strong>：v开头数字结尾 v0</li><li><strong>参数寄存器</strong>：p开头数字结尾 p0</li></ul><p><strong>Q</strong> ：p0一定是第一个参数吗？</p><p><strong>A</strong>：在static函数中p0对应第一个参数（因为java语法里没有static语法）</p><p>在非static函数中，p0代指 <strong>“this”</strong>，p1表示函数的第一个参数</p><h2 id="实战原理"><a href="#实战原理" class="headerlink" title="实战原理"></a>实战原理</h2><h3 id="双开原理"><a href="#双开原理" class="headerlink" title="双开原理"></a>双开原理</h3><ul><li><strong>修改包名</strong>：让手机系统认为这是2个APP实现，改变了应用的签名信息，如果有签名校验则可能闪退崩溃</li><li><strong>修改Framework</strong></li><li><strong>通过虚拟化技术实现</strong></li><li><strong>以插件机制运行</strong>：利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。</li></ul><h3 id="去广告"><a href="#去广告" class="headerlink" title="去广告"></a>去广告</h3><p>启动广告流程：</p><ul><li>启动Activity-&gt;广告Activity-&gt;主页Activity</li></ul><p>修改方法：</p><ul><li>修改加载时间</li><li>Acitivity切换定位，修改Intent的Activity类名</li></ul><h3 id="弹窗定位-amp-堆栈分析"><a href="#弹窗定位-amp-堆栈分析" class="headerlink" title="弹窗定位&amp;堆栈分析"></a>弹窗定位&amp;堆栈分析</h3><p>修改方法：<br>1.修改xml中的versiocode<br>2.Hook弹窗(推荐算法助手开启弹窗定位)<br>3.修改dex弹窗代码<br>4.抓包修改响应体(也可以路由器拦截)</p><h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>1.开发者助手抓布局<br>2.MT管理器xml搜索定位<br>3.修改xml代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility=&quot;gone&quot;</span><br></pre></td></tr></table></figure><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件结构学习</title>
      <link href="/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/05/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>资料来源：《逆向工程核心原理》和<a href="https://www.youtube.com/watch?v=oSpeXGHaKAk&amp;t=15123s">PE文件结构格式详解（完整版）【逆向编程】 (youtube.com)</a></p><h1 id="一、PE文件基础"><a href="#一、PE文件基础" class="headerlink" title="一、PE文件基础"></a>一、PE文件基础</h1><h2 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h2><p>Windows：PE</p><p>Linux: elf</p><h2 id="2-PE文件特征"><a href="#2-PE文件特征" class="headerlink" title="2.PE文件特征"></a>2.PE文件特征</h2><p>PE文件指纹</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011858080.png" alt="1735729100495.png"></p><h2 id="3-PE结构"><a href="#3-PE结构" class="headerlink" title="3.PE结构"></a>3.PE结构</h2><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859756.png" alt="1735729120355.png"></p><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><ul><li><strong>DOS MZ头</strong>  <strong>IMAGE_DOS_HEADER(64字节)</strong></li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011859938.png" alt="1735729155568.png"></p><p><strong>e_magic</strong>：4D5A是DOS签名，不可改</p><p><strong>e_lfanew</strong>：78指向PE头开始位置，要改要一起改。</p><p>上面两个是<strong>PE指纹</strong>，操作系统用来<strong>识别是否是PE文件</strong>，其他地方可以随便改，因为<em>IMAGE_DOS_HEADER</em>是给16位平台看的，而我们现在的环境大部分是32位或者64位。</p><ul><li><strong>MS_DOS Stu</strong>，DOS存根，用来给链接器插入数据，随便改</li></ul><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011900211.png" alt="1735729196266.png"></p><h3 id="NT头-IMAGE-NT-HEADERS"><a href="#NT头-IMAGE-NT-HEADERS" class="headerlink" title="NT头 IMAGE_NT_HEADERS"></a>NT头 IMAGE_NT_HEADERS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line"> DWORD Signature; ``<span class="comment">// PE标识</span></span><br><span class="line"> IMAGE_FILE_HEADER FileHeader; ``<span class="comment">// 标准PE头</span></span><br><span class="line"> IMAGE_OPTIONAL_HEADER32 OptionalHeader; ``<span class="comment">// 扩展PE头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h4 id="PE标识-Signature-4字节"><a href="#PE标识-Signature-4字节" class="headerlink" title="PE标识 Signature 4字节"></a>PE标识 Signature 4字节</h4><p><strong><u>不可改</u></strong>,操作系统启动程序的时候识别这个标识。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011901322.png" alt="1735729196266.png"></p><h4 id="标准PE头-IMAGE-FILE-HEADER-20字节"><a href="#标准PE头-IMAGE-FILE-HEADER-20字节" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER(20字节)"></a>标准PE头 <strong>IMAGE_FILE_HEADER</strong>(20字节)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line"> WORD Machine; <span class="comment">// 可以运行在什么样的CPU上</span></span><br><span class="line"> WORD NumberOfSections; <span class="comment">// 表示节的数量</span></span><br><span class="line"> DWORD TimeDateStamp; <span class="comment">// 编译器填写的时间戳</span></span><br><span class="line"> DWORD PointerToSymbolTable; <span class="comment">// 调试相关</span></span><br><span class="line"> DWORD NumberOfSymbols; <span class="comment">// 调试相关</span></span><br><span class="line"> WORD SizeOfOptionalHeader; <span class="comment">// 扩展PE头的大小</span></span><br><span class="line"> WORD Characteristics; <span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902971.png" alt="1735729302371.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902440.png" alt="1735729314190.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011902205.png" alt="1735729331600.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">64 86 -&gt;8664 代表在x64上运行</span><br><span class="line">0F 00 有0x0F个节区</span><br><span class="line">84 D7 68 65 编译器写的时间戳，和文件无关，随便改</span><br><span class="line">调试不管</span><br><span class="line">F0 00 扩展PE头大小，可改</span><br><span class="line">22 00-&gt;0022-&gt; 0000 0000 0010 0010 第2位，第6位有值 对应数据位1，5 分别代表文件可执行，应用程序可以处理大于2GB的地址（代表64位）</span><br></pre></td></tr></table></figure><h4 id="扩展PE头-IMAGE-OPTIONAL-HEADER"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER" class="headerlink" title="扩展PE头  IMAGE_OPTIONAL_HEADER"></a>扩展PE头  IMAGE_OPTIONAL_HEADER</h4><h5 id="扩展PE头结构-amp-不同编译器上的差异"><a href="#扩展PE头结构-amp-不同编译器上的差异" class="headerlink" title="扩展PE头结构&amp;不同编译器上的差异"></a>扩展PE头结构&amp;不同编译器上的差异</h5><p>32位上是224字节（E0)（可扩展）</p><p>64位是F0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位为例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER32</span> &#123;</span></span><br><span class="line">    WORD    Magic;                  <span class="comment">// 标志：PE32 是 0x10B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;     <span class="comment">// 链接器的主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;     <span class="comment">// 链接器的次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;             <span class="comment">// 代码段的大小（没用）</span></span><br><span class="line">    DWORD   SizeOfInitializedData;  <span class="comment">// 初始化数据段的大小（没用）</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">// 未初始化数据段的大小（没用）</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;    <span class="comment">// 程序入口点的 RVA</span></span><br><span class="line">    DWORD   BaseOfCode;             <span class="comment">// 代码段的起始 RVA（没用）</span></span><br><span class="line">    DWORD   BaseOfData;             <span class="comment">// 数据段的起始 RVA（没用）</span></span><br><span class="line">    DWORD   ImageBase;              <span class="comment">// 内存镜像基址</span></span><br><span class="line">    DWORD   SectionAlignment;       <span class="comment">// 内存对齐</span></span><br><span class="line">    DWORD   FileAlignment;          <span class="comment">// 文件对齐</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion; <span class="comment">// OS 主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion; <span class="comment">// OS 次版本号</span></span><br><span class="line">    DWORD   SizeOfImage;            <span class="comment">// 镜像的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;          <span class="comment">// 头+节表按照文件对齐后的总大小</span></span><br><span class="line">    DWORD   CheckSum;               <span class="comment">// 校验和</span></span><br><span class="line">    WORD    Subsystem;              <span class="comment">// 子系统（如 GUI、CUI）</span></span><br><span class="line">    WORD    DllCharacteristics;    <span class="comment">// DLL 属性</span></span><br><span class="line">    DWORD   SizeOfStackReserve;     <span class="comment">// 堆栈保留大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;      <span class="comment">// 堆栈提交大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;      <span class="comment">// 堆保留大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;       <span class="comment">// 堆提交大小</span></span><br><span class="line">    DWORD   LoaderFlags;            <span class="comment">// 装载器标志（通常为 0）</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;    <span class="comment">// 数据目录项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">16</span>]; <span class="comment">// 表，结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>字段名称</strong></th><th><strong>32 位 PE（PE32）</strong></th><th><strong>64 位 PE（PE32+）</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>Magic</code></td><td><code>0x10B</code></td><td><code>0x20B</code></td><td>标识 PE 文件是 32 位（PE32）还是 64 位（PE32+）。</td></tr><tr><td><code>AddressOfEntryPoint</code></td><td>存在</td><td>存在</td><td>程序入口点的 RVA（相对虚拟地址）。</td></tr><tr><td><code>BaseOfCode</code></td><td>存在</td><td>存在</td><td>代码段的起始 RVA。</td></tr><tr><td><code>BaseOfData</code></td><td>存在</td><td><strong>不存在</strong></td><td>数据段的起始 RVA，<strong>仅在 PE32 中存在</strong>。</td></tr><tr><td><code>ImageBase</code></td><td>32 位地址（默认 0x00400000）</td><td>64 位地址（默认 0x0000000140000000）</td><td>可执行文件加载到内存中的首地址。</td></tr><tr><td><code>SizeOfStackReserve</code></td><td>32 位值</td><td>64 位值</td><td>为线程的堆栈预留的大小。</td></tr><tr><td><code>SizeOfHeapReserve</code></td><td>32 位值</td><td>64 位值</td><td>为堆分配的保留大小。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011903423.png" alt="1735729389033.png"></p><ul><li><strong>Magic</strong></li></ul><p>2个字节，文件的标志</p><p>32 位：10B</p><p>64 位：20B </p><ul><li><strong>AddressOfEntryPoint</strong></li></ul><p>4个字节，程序的入口点地址，即执行开始的位置。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904115.png" alt="1735729398902.png"></p><ul><li><strong>ImageBase</strong></li></ul><p>4个字节，程序加载的基地址。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904366.png" alt="1735729409663.png"></p><p>AddressOfEntryPoint：<u>042CE910</u></p><p>imagebase:<u>00000010</u></p><p>程序执行入口：（EIP)042CE910+00000010=042CE920</p><ul><li><strong>SectionAlignment</strong></li></ul><p>节区的内存对齐大小，节区在<strong>内存</strong>中的最小大小。</p><ul><li><strong>FileAlignment</strong></li></ul><p>节区的文件对齐大小，节区在<strong>磁盘文件</strong>中的最小单位。</p><ul><li><strong>SizeOfImage</strong></li></ul><p>表示在内存中<strong>整个</strong>PE文件映射的大小（包括所有节区和头信息），可比实际的值大。内存对齐以后是SectionAlignment或者FileAlignment的整数倍。</p><ul><li><strong>SizeOfHeaders</strong></li></ul><p>PE 文件头的大小。是<strong>FileAlignment的整数倍</strong>。</p><ul><li><strong>CheckSum</strong></li></ul><p>校验和，系统用来检测文件是否被修改</p><ul><li><strong>Subsystem</strong></li></ul><p>程序的子系统类型（例如，Windows GUI 或控制台应用程序），用来表示PE文件的特性。</p><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p><strong>IMAGE_SECTION_HEADER</strong> (40字节)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[<span class="number">8</span>];               <span class="comment">// 节名称（最多 8 字节，可能没有结束符）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   PhysicalAddress;   <span class="comment">// 实际已弃用，常为 0</span></span><br><span class="line">        DWORD   VirtualSize;       <span class="comment">// 节的实际大小（内存中的大小）</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;        <span class="comment">// 节在内存中的 RVA（相对虚拟地址）</span></span><br><span class="line">    DWORD   SizeOfRawData;         <span class="comment">// 节在文件中的大小（以 FileAlignment 对齐）</span></span><br><span class="line">    DWORD   PointerToRawData;      <span class="comment">// 节在文件中的偏移（以 FileAlignment 对齐）</span></span><br><span class="line">    DWORD   PointerToRelocations; <span class="comment">// 重定位表的文件偏移（通常为 0，已弃用）</span></span><br><span class="line">    DWORD   PointerToLinenumbers; <span class="comment">// 调试信息的文件偏移（通常为 0）</span></span><br><span class="line">    WORD    NumberOfRelocations;  <span class="comment">// 重定位条目数量（通常为 0）</span></span><br><span class="line">    WORD    NumberOfLinenumbers;  <span class="comment">// 调试行号条目数量（通常为 0）</span></span><br><span class="line">    DWORD   Characteristics;      <span class="comment">// 节的属性标志（权限、类型等）</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>红色框出来的是扩展PE头，下面就是节表</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011904634.png" alt="1735729466460.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905916.png" alt="1735729479345.png"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501011905144.png" alt=""></p><ul><li><h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4></li></ul><p>8字节，当前节的名字，可以随意更改。</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106081.png" alt="image"></h5><p>当前这个节未对齐时的大小，即实际大小。</p><p>实际大小有可能会比Size of Raw Data大，因为未初始化的全局变量在文件中是不占空间的，但是在内存里是有位置的。</p><p><strong>Q</strong>：在内存中展开时以什么为基准呢？</p><p><strong>A</strong>：谁大按谁，如果Vitual Size&gt;Size of Raw Data,则按照Vitual Size展开，反之则按照Size of Raw Data。</p><ul><li><h4 id="VirtualAddress（RVA）"><a href="#VirtualAddress（RVA）" class="headerlink" title="VirtualAddress（RVA）"></a>VirtualAddress（RVA）</h4></li></ul><p>在内存中的偏移地址，加上ImageBase则是内存中的真实地址。</p><ul><li><h4 id="Raw-Size-Size-of-Raw-Data"><a href="#Raw-Size-Size-of-Raw-Data" class="headerlink" title="Raw Size(Size of Raw Data)"></a>Raw Size(Size of Raw Data)</h4></li></ul><p>文件对齐后的大小</p><ul><li><h4 id="Raw-Address-File-Pointer-to-Raw-Data"><a href="#Raw-Address-File-Pointer-to-Raw-Data" class="headerlink" title="Raw Address(File Pointer to Raw Data)"></a><strong>Raw Address</strong>(File Pointer to Raw Data)</h4></li></ul><p>当前节在文件中起始位置</p><ul><li><h4 id="Reloc-Address"><a href="#Reloc-Address" class="headerlink" title="Reloc Address"></a><strong>Reloc Address</strong></h4></li></ul><p>节的重定位表（如果有的话）在文件中的偏移地址。</p><ul><li><h4 id="Line-Numbers、Relocation-Number、Line-Number-Numbers"><a href="#Line-Numbers、Relocation-Number、Line-Number-Numbers" class="headerlink" title="Line Numbers、Relocation Number、Line Number Numbers"></a><strong>Line Numbers</strong>、<strong>Relocation Number</strong>、<strong>Line Number Numbers</strong></h4></li></ul><p>与调试信息和重定位表相关。</p><ul><li><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4></li></ul><p>节区属性</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106048.png" alt="image"></p><h3 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h3><p>文件对齐和内存对齐的差异：</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052106850.png" alt="image"></p><h2 id="4、RVA和FOA的转换"><a href="#4、RVA和FOA的转换" class="headerlink" title="4、RVA和FOA的转换"></a>4、RVA和FOA的转换</h2><p><strong>VA</strong>：虚拟内存的绝对地址。</p><p><strong>RVA</strong>：相对虚拟地址，从ImageBase开始的相对地址。</p><p><strong>FOA</strong>：文件偏移地址</p><p><strong>Q</strong>：想改边一个全局变量的初始值，应该怎么做？</p><p><strong>A</strong>：先区分全局变量有无初始值。如果有初始值，全局变量储存在文件中，如果没有初始值，在文件里就没有位置，在内存展开时才会分配位置。</p><p><1>、判断RVA是否在头部，在的话直接返回</p><p>FOA=RVA</p><p><2>、判断RVA在哪一个节</p><p>RVA&gt;=节.VA</p><p>RVA&lt;=节.VA+当前节内存对其后大小</p><p>差值=RVA-节.VA</p><p><4>、FOA=节.PointerToRawData+差值</p><p>看一下书上的例子，实例下面导入表的计算也有提到</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052107891.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108166.png" alt="image"></p><p><strong>算完RAW记得查看是否和内存中在同一节区！！！</strong>如上图Q3</p><h2 id="5、手撕PE文件"><a href="#5、手撕PE文件" class="headerlink" title="5、手撕PE文件"></a>5、手撕PE文件</h2><h3 id="（1）在空白区添加代码"><a href="#（1）在空白区添加代码" class="headerlink" title="（1）在空白区添加代码"></a>（1）在空白区添加代码</h3><h3 id="（2）扩大节"><a href="#（2）扩大节" class="headerlink" title="（2）扩大节"></a>（2）扩大节</h3><h3 id="（3）删除节"><a href="#（3）删除节" class="headerlink" title="（3）删除节"></a>（3）删除节</h3><h3 id="（4）新添节"><a href="#（4）新添节" class="headerlink" title="（4）新添节"></a>（4）新添节</h3><h3 id="（5）合并节"><a href="#（5）合并节" class="headerlink" title="（5）合并节"></a>（5）合并节</h3><h2 id="6、导出表-amp-导入表"><a href="#6、导出表-amp-导入表" class="headerlink" title="6、导出表&amp;导入表"></a>6、导出表&amp;导入表</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先明白，一个可执行程序是有<strong>多个pe文件组成</strong>的。</p><p><strong>导入表（IMP)</strong>：PE文件引用了哪些文件</p><ul><li><strong>导入地址表IAT</strong>：储存导入函数在内存里的实际应用。</li><li><strong>导入名称表INT</strong>：每个dll导入描述符，储存函数名或者序号，用于加载解析函数地址。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>组件</strong></th><th style="text-align:left"><strong>内容（磁盘）</strong></th><th style="text-align:left"><strong>内容（内存）</strong></th><th style="text-align:left"><strong>作用</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>导入表（IMP）</strong></td><td style="text-align:left">所有导入DLL的描述信息</td><td style="text-align:left">不变</td><td style="text-align:left">管理所有导入的DLL和函数引用</td></tr><tr><td style="text-align:left"><strong>导入名称表（INT）</strong></td><td style="text-align:left">函数名称/序号的RVA</td><td style="text-align:left">不变（或不存在于内存）</td><td style="text-align:left">提供加载时解析函数地址的线索</td></tr><tr><td style="text-align:left"><strong>导入地址表（IAT）</strong></td><td style="text-align:left">初始为函数名称/序号的RVA</td><td style="text-align:left">实际函数地址</td><td style="text-align:left">运行时跳转到目标函数的地址表</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Import Table (IMP)</span><br><span class="line">├─ IMAGE_IMPORT_DESCRIPTOR 1 (DLL1)</span><br><span class="line">│  ├─ OriginalFirstThunk → INT (函数名称/序号)</span><br><span class="line">│  └─ FirstThunk → IAT (初始同INT，加载后为地址)</span><br><span class="line">├─ IMAGE_IMPORT_DESCRIPTOR 2 (DLL2)</span><br><span class="line">│  ├─ OriginalFirstThunk → INT</span><br><span class="line">│  └─ FirstThunk → IAT</span><br><span class="line">└─ ...</span><br></pre></td></tr></table></figure><p><strong>导出表(EAT)</strong>：当前的PE文件储存了哪些函数给其他文件用。</p><p><strong>Q</strong>：导出表在哪？</p><p><strong>A</strong>：再扩展PE头最后一个成员</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052108437.png" alt="image"></p><h4 id="Dll"><a href="#Dll" class="headerlink" title="Dll"></a>Dll</h4><p>动态链接库</p><p>加载DLL的两种方式</p><ul><li><strong>显式链接</strong>：程序使用DLL时候加载，使用完释放内存。</li><li><strong>隐式链接</strong>：程序开始时一同加载DLL，程序终止时释放内存。</li></ul><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052109509.png" alt="image"></h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052110010.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111005.png" alt="image"></p><p>先找到导出表位置</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111830.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052111561.png" alt="image"></p><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>确定依赖的函数</p><p><strong>导入表位置</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112545.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112232.png" alt="image"></p><p><strong>导入表结构</strong></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052112548.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113698.png" alt="image"></p><h4 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h4><p>字符串指针，指向导入函数所属的库文件名字。</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113795.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052113568.png" alt="image"></p><p>RVA要转成FOA，参考下面的实际计算</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114790.png" alt="image"></p><p>因为指向的是assic码的字符串，所以到第一个00结束</p><h4 id="OringinalFirstThunk-INT"><a href="#OringinalFirstThunk-INT" class="headerlink" title="OringinalFirstThunk-INT"></a>OringinalFirstThunk-INT</h4><p>导入名称表<img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052114717.png" alt="image"></p><h4 id="FirstThunk-IAT"><a href="#FirstThunk-IAT" class="headerlink" title="FirstThunk-IAT"></a>FirstThunk-IAT</h4><p>导入地址表</p><h3 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h3><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052115276.png" alt="image"></p><p>Export Directory RVA：93 5D 82 09-&gt;0x09825D93(imagebase:0x00000010)查了一下再rdata段-&gt;FOA：0x09825D83</p><p>Export Directory Size：00033669</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116225.png" alt="image"></p><p>看了010半天不对，dumpbin /headers看了一下，然后又开了个exe，发现这个爆红的意思是typora.exe没有导入表导出表。。。(也有可能有加壳？die看了一下没有，但是这个地址太大了不正常)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /headers &quot;D:\Typora\Typora\Typora.exe&quot;</span><br></pre></td></tr></table></figure><p>换个文件来</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116588.png" alt="image"></p><p>Import Directory RVA：0x00003824，在.rdata段，rdata段的RVA是0x00003000，所以相对地址就是0x00000824，rdata段的raw address是0x00001A00，所以FOA是0x00002224，大小是C8字节</p><p><strong>Import Directory RVA</strong>：0x00003824</p><p><strong>.rdata段的 RVA</strong>：0x00003000</p><p><strong>.rdata段的 Raw Address</strong>：0x00001A00</p><p><strong>.rdata段的 Raw Size</strong>：C8 字节（即 200 字节）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相对地址 <span class="operator">=</span> <span class="built_in">Import</span> <span class="built_in">Directory</span> <span class="variable">RVA</span> <span class="operator">-</span> <span class="operator">.</span><span class="variable">rdata</span>段的 <span class="variable">RVA</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00003824</span> <span class="operator">-</span> <span class="number">0</span><span class="variable">x00003000</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00000824</span></span><br><span class="line"></span><br><span class="line"><span class="variable">FOA</span> <span class="operator">=</span> <span class="operator">.</span><span class="variable">rdata</span>段的 <span class="variable">Raw</span> <span class="variable">Address</span> <span class="operator">+</span> 相对地址 <span class="operator">=</span><span class="number">0</span><span class="variable">x00001A00</span> <span class="operator">+</span> <span class="number">0</span><span class="variable">x00000824</span> <span class="operator">=</span> <span class="number">0</span><span class="variable">x00002224</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501052116426.png" alt="image"></p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF</title>
      <link href="/2025/01/05/NSSCTF/"/>
      <url>/2025/01/05/NSSCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="easyRE（虚函数表-反调试-内联函数）"><a href="#easyRE（虚函数表-反调试-内联函数）" class="headerlink" title="easyRE（虚函数表+反调试+内联函数）"></a>easyRE（虚函数表+反调试+内联函数）</h2><p><a href="https://www.nssctf.cn/problem/43">[SWPU 2019]easyRE | NSSCTF</a></p><p>没做出来，看了佬的wp才理清思路<a href="https://bbs.kanxue.com/thread-271798.htm#msg_header_h3_2">[原创] SWPUCTF 2019 easyRE-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD v4[<span class="number">30</span>]; <span class="comment">// [esp-6Ch] [ebp-F8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+Ch] [ebp-80h]</span></span><br><span class="line">  _DWORD v6[<span class="number">27</span>]; <span class="comment">// [esp+10h] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+88h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_40EF90</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                                   <span class="comment">// 反调试</span></span><br><span class="line">  <span class="built_in">sub_4026C0</span>(<span class="number">0x6Cu</span>);</span><br><span class="line">  <span class="built_in">sub_401FE0</span>(v6);                               <span class="comment">// vftable虚函数表</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v4[<span class="number">29</span>] = v4;</span><br><span class="line">  <span class="built_in">sub_40F360</span>(v4, v6);</span><br><span class="line">  <span class="built_in">sub_40F080</span>(v4[<span class="number">0</span>], v4[<span class="number">1</span>]);</span><br><span class="line">  v4[<span class="number">28</span>] = v4;</span><br><span class="line">  <span class="built_in">sub_40F360</span>(v4, v6);</span><br><span class="line">  <span class="built_in">sub_40F150</span>(argc, (<span class="type">int</span>)argv);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sub_4021C0</span>(v6);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反调试patch掉就行</p><h4 id="sub-401FE0"><a href="#sub-401FE0" class="headerlink" title="sub_401FE0"></a>sub_401FE0</h4><p>这里创建了一个虚函数表，下面的偏移是对比用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD *__thiscall <span class="title">sub_401FE0</span><span class="params">(_DWORD *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> = &amp;EASYRE::`vftable<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">  this[1] = 0;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 52) = 8;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 53) = 0xEA;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 54) = 0x58;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 55) = 0xDE;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 56) = 0x94;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 57) = 0xD0;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 58) = 0x3B;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 59) = 0xBE;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 60) = 0x88;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 61) = 0xD4;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 62) = 0x32;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 63) = 0xB6;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 64) = 0x14;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 65) = 0x82;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 66) = 0xB7;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 67) = 0xAF;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 68) = 0x14;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 69) = 0x54;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 70) = 0x7F;</span></span><br><span class="line"><span class="string">  *((_BYTE *)this + 71) = 0xCF;</span></span><br><span class="line"><span class="string">  qmemcpy(this + 0x12, &quot;  03\&quot;3   0 203\&quot;   $ &quot;, 20);</span></span><br><span class="line"><span class="string">  sub_4030A0(this + 0x17);</span></span><br><span class="line"><span class="string">  sub_402DE0(this + 0x1A);</span></span><br><span class="line"><span class="string">  for ( i = 0; i &lt; 40; ++i )</span></span><br><span class="line"><span class="string">    *((_BYTE *)this + i + 12) = 0;</span></span><br><span class="line"><span class="string">  return this;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.rdata:004124E4 90 21 40 00                   ??_7EASYRE@@6B@ dd offset sub_402190    ; DATA XREF: sub_401FE0+2B↑o</span><br><span class="line">.rdata:004124E4                                                                       ; sub_4021C0+A↑o</span><br><span class="line">.rdata:004124E4                                                                       ; sub_40F360+C↑o</span><br><span class="line">.rdata:004124E8 F0 21 40 00                   dd offset sub_4021F0</span><br><span class="line">.rdata:004124EC B0 24 40 00                   dd offset sub_4024B0</span><br><span class="line">.rdata:004124F0 00 25 40 00                   dd offset sub_402500</span><br><span class="line">.rdata:004124F4 F0 22 40 00                   dd offset sub_4022F0</span><br><span class="line">.rdata:004124F8 A0 23 40 00                   dd offset sub_4023A0</span><br><span class="line">.rdata:004124FC E0 26 40 00                   dd offset sub_4026E0</span><br><span class="line">.rdata:00412500 30 27 40 00                   dd offset sub_402730</span><br><span class="line">.rdata:00412504 E0 23 40 00                   dd offset sub_4023E0</span><br><span class="line">.rdata:00412508 A0 28 40 00                   dd offset sub_4028A0</span><br><span class="line">.rdata:0041250C 00 2A 40 00                   dd offset sub_402A00</span><br><span class="line">.rdata:00412510 40 24 40 00                   dd offset sub_402440</span><br><span class="line">.rdata:00412514 00 00 00 00                   align 8</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="sub-40F150"><a href="#sub-40F150" class="headerlink" title="sub_40F150"></a>sub_40F150</h4><p>找到对比函数</p><p> if ( sub_A124B0(va, input) )输出congratulations说明sub_A124B0是我们主要关注的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_40F150</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">10</span>]; <span class="comment">// [esp+Ch] [ebp-38h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+40h] [ebp-4h]</span></span><br><span class="line">  va_list va; <span class="comment">// [esp+54h] [ebp+10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span>(va, a2);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="built_in">sizeof</span>(v6));</span><br><span class="line">  v2 = <span class="built_in">printf</span>(std::cout, <span class="string">&quot;Please input your flag : &quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, sub_40F8F0);</span><br><span class="line">  <span class="built_in">sub_40F930</span>(std::cin, v6);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_4024B0</span>(v6) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">printf</span>(std::cout, &amp;unk_4122F0);        <span class="comment">// congratulations</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, sub_40F8F0);</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sub_4021C0</span>(va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">printf</span>(std::cout, &amp;unk_41231C);        <span class="comment">// sorry，try again</span></span><br><span class="line">    std::ostream::<span class="keyword">operator</span>&lt;&lt;(v5, sub_40F8F0);</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sub_4021C0</span>(va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sub-4024B0"><a href="#sub-4024B0" class="headerlink" title="sub_4024B0"></a>sub_4024B0</h4><p>对照虚函数表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL __thiscall <span class="title">sub_D724B0</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">2</span>] = a2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0xC</span>))(<span class="keyword">this</span>) )<span class="comment">// sub_402500 00D72500</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="built_in">void</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0x18</span>))(<span class="keyword">this</span>);<span class="comment">// sub_4026E0 00D824FC</span></span><br><span class="line">    <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__thiscall **)(_DWORD *))(*<span class="keyword">this</span> + <span class="number">0x28</span>))(<span class="keyword">this</span>) )<span class="comment">// sub_402A00 00D72A00</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化一下就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sub_402500（）</span><br><span class="line">    sub_<span class="number">4026E0</span>（）</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">sub_402A00</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 1</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> 0</span></span><br></pre></td></tr></table></figure><h4 id="sub-D72500"><a href="#sub-D72500" class="headerlink" title="sub_D72500"></a>sub_D72500</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __thiscall <span class="title">sub_D72500</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-B0h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// [esp+14h] [ebp-A8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+24h] [ebp-98h]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">56</span>]; <span class="comment">// [esp+30h] [ebp-8Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">20</span>]; <span class="comment">// [esp+68h] [ebp-54h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">48</span>]; <span class="comment">// [esp+7Ch] [ebp-40h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+B8h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = &amp;<span class="keyword">this</span>[<span class="number">2</span>][<span class="built_in">strlen</span>(<span class="keyword">this</span>[<span class="number">2</span>])];</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">&quot;Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_D726C0</span>(v6, <span class="number">0x38u</span>);                        <span class="comment">// 初始化v6</span></span><br><span class="line">  <span class="built_in">sub_D72B00</span>(v6);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i )</span><br><span class="line">    v8[i] ^= <span class="number">0x10u</span>;                             <span class="comment">// ^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span></span><br><span class="line">  <span class="built_in">sub_D726C0</span>(v7, <span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">sub_D72A70</span>(v8, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v9) = <span class="number">1</span>;</span><br><span class="line">  v2 = (<span class="type">unsigned</span> __int8)<span class="built_in">sub_D74260</span>(<span class="keyword">this</span>[<span class="number">2</span>], v3, v6, v7, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">LOBYTE</span>(v9) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">sub_D72A50</span>(v7);</span><br><span class="line">  v9 = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sub_D726A0</span>();</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501031630537.png" alt="1735892999415.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^swpuctf\&#123;\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\-\w&#123;4&#125;\&#125;</span><br></pre></td></tr></table></figure><p>有点像正则表达式，估计是flag格式</p><h4 id="sub-A12730"><a href="#sub-A12730" class="headerlink" title="sub_A12730"></a>sub_A12730</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __thiscall <span class="title">sub_A12730</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// bl</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// t2</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+Ch] [ebp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+14h] [ebp-28h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+1Ch] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+20h] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp+24h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp+28h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+2Ch] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp+30h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp+34h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="keyword">this</span>[<span class="number">2</span>] + <span class="number">5</span> * a2 + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i )</span><br><span class="line">    *(&amp;v13 + i) = *(i + v10);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(&amp;v13 + v2);                          <span class="comment">// 取单个字符</span></span><br><span class="line">    _DL = v4;</span><br><span class="line">    __asm &#123; rcl     dl, <span class="number">1</span> &#125;                     <span class="comment">// 循环左移直到CF为1</span></span><br><span class="line">    *(&amp;v15 + v2) = <span class="number">1</span>;                           <span class="comment">// 将1写入v15 v2个字节的位置</span></span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>                                          <span class="comment">// v8=v6左移7位</span></span><br><span class="line">                                                <span class="comment">// v6=v4最低位</span></span><br><span class="line">                                                <span class="comment">// v4去掉最低有效位</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v6 &lt;&lt; <span class="number">7</span>;</span><br><span class="line">      v6 = v4 &amp; <span class="number">1</span>;</span><br><span class="line">      v4 = (v4 &gt;&gt; <span class="number">1</span>) | v8;</span><br><span class="line">      ++v7;                                     <span class="comment">// v7计算v4中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 );                               <span class="comment">// 如果v6为1 即v4的当前最低有效位是 1，继续循环，</span></span><br><span class="line">                                                <span class="comment">// v6为0则结束循环</span></span><br><span class="line">    *(&amp;v16 + v2++) = v7 - <span class="number">1</span>;                    <span class="comment">// 位宽度v16=v7-1</span></span><br><span class="line">    --v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 );</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    *(&amp;v14 + j) = *(&amp;v16 + j) + *(&amp;v15 + j);    <span class="comment">// 右边0的个数+左移至进位个数</span></span><br><span class="line">    *(&amp;v17 + j) = *(&amp;v13 + j) &lt;&lt; *(&amp;v15 + j);   <span class="comment">// flag&lt;&lt;左移至进位个数</span></span><br><span class="line">    *(&amp;v18 + j) = (*(&amp;v13 + j) &lt;&lt; (<span class="number">8</span> - *(&amp;v16 + j))) | ((*(&amp;v13 + j) &gt;&gt; (<span class="number">8</span> - *(&amp;v15 + j))) &lt;&lt; *(&amp;v15 + j));</span><br><span class="line">  &#125;                                             <span class="comment">// [flag&lt;&lt;（8-右边0的个数）]|&#123;[flag&gt;&gt;(8-左移至进位个数）]&lt;&lt;左移至进位个数&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_A12F80</span>(&amp;v13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外面的dowhile其实是在计算左移几位CF为1，里面的dowhile是在计算右边0的个数</p><h4 id="sub-A128A0"><a href="#sub-A128A0" class="headerlink" title="sub_A128A0"></a>sub_A128A0</h4><p>不想看了，大概看看感觉能爆破，不行再回来看</p><p>好吧还是得看</p><p>for循环嵌套if else，大概把上面加密完的flag分为两个部分处理。</p><p>前四次循环走else，对 <code>v15 + i + 20</code> 赋值</p><p>后四次走if，对 <code>v17 + 0x1A</code> 进行操作，更新 <code>v14</code> 并对 <code>v15</code> 执行位操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v17 = this;</span><br><span class="line">v15 = this + 3;</span><br><span class="line">*v15 |= *(v10 + i + 0x10) &lt;&lt; v14;</span><br><span class="line">*v15 |= *(v5 + i + 0x10) &lt;&lt; v14;</span><br><span class="line">*(v15 + i + 20) = *(v8 + i + 0xC) | v7;</span><br></pre></td></tr></table></figure><p>因为我们前面得到了flag格式，可以判断出来while走5次。</p><p>一个参与了加密一个没参与</p><p>这里用了佬简化完的加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;</span><br><span class="line">    v9 = sub_402DC0(v17 + <span class="number">26</span>);</span><br><span class="line">    v14 -= *(<span class="type">unsigned</span> __int8 *)(v9 + i); <span class="comment">// v14的初始值为0x20</span></span><br><span class="line">    *v15 |= res3 &lt;&lt; v14;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    v14 -= <span class="number">8</span> - res1;</span><br><span class="line">    *v15 |= res2 &lt;&lt; v14;</span><br><span class="line">    *((_BYTE *)v15 + i + <span class="number">20</span>) = <span class="number">0</span>的个数 | (<span class="number">16</span> * 左移进位位数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理一下逻辑</p><ul><li>校验flag格式</li><li>加密</li><li>5次循环处理加密，两种结果，一个受字符影响一个独立存在。</li><li>对比</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查左移进位位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_1</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = c &lt;&lt; <span class="number">1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">0x100</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查右边0的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_0</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        c = c &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标识符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_0</span>(<span class="params">c</span>):</span><br><span class="line">    res1 = check_0(c) + check_1(c)</span><br><span class="line">    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1</span><br><span class="line">    res3 = ((c &gt;&gt; (<span class="number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="number">8</span> - check_0(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1)</span><br><span class="line">    <span class="keyword">return</span> [res1, res2, res3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_part</span>(<span class="params">c,s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查字符的分类，并返回符合条件的字符&quot;&quot;&quot;</span></span><br><span class="line">    tmp = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))</span><br><span class="line">    tmp2=check_0(c) | (<span class="number">16</span>*check_1(c))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s2):</span><br><span class="line">        <span class="keyword">if</span> tmp2 ==<span class="built_in">ord</span>(i):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>():</span><br><span class="line">    for_each=string.ascii_lowercase+string.ascii_uppercase+string.digits</span><br><span class="line">    second_part_res = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">    d=<span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)):</span><br><span class="line">        d[i]=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> for_each:</span><br><span class="line">        tmp=check_part(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            d[tmp].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">c,v14</span>):</span><br><span class="line">    exam=&#123;c:generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14=v14-(<span class="number">8</span>-exam[c][<span class="number">0</span>])</span><br><span class="line">    tmp=exam[c][<span class="number">1</span>]&lt;&lt;v14</span><br><span class="line">    <span class="keyword">return</span> tmp,v14</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">c,v14</span>):</span><br><span class="line">    exam=&#123;c:generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14=v14-exam[c][<span class="number">0</span>]</span><br><span class="line">    tmp=exam[c][<span class="number">2</span>]&lt;&lt;v14</span><br><span class="line">    <span class="keyword">return</span> tmp,v14</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查左移进位位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_1</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = c &lt;&lt; <span class="number">1</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">0x100</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查右边0的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_0</span>(<span class="params">c</span>): </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        c = c &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标识符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_0</span>(<span class="params">c</span>):</span><br><span class="line">    res1 = check_0(c) + check_1(c)</span><br><span class="line">    res2 = ((c &lt;&lt; check_1(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1</span><br><span class="line">    res3 = ((c &gt;&gt; (<span class="number">8</span> - check_1(c))) &lt;&lt; check_1(c)) | ((c &lt;&lt; (<span class="number">8</span> - check_0(c)) &amp; <span class="number">0xff</span>) &gt;&gt; res1)</span><br><span class="line">    <span class="keyword">return</span> [res1, res2, res3]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_part</span>(<span class="params">c</span>):</span><br><span class="line">    tmp = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span>))</span><br><span class="line">    tmp2 = check_0(c) | (<span class="number">16</span> * check_1(c))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">        <span class="keyword">if</span> tmp2 == <span class="built_in">ord</span>(i):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>():</span><br><span class="line">    for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits</span><br><span class="line">    second_part_res = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(second_part_res)):</span><br><span class="line">        d[i] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> for_each:</span><br><span class="line">        tmp = check_part(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            d[tmp].append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">c, v14</span>):</span><br><span class="line">    exam = &#123;c: generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14 = v14 - (<span class="number">8</span> - exam[c][<span class="number">0</span>])</span><br><span class="line">    tmp = exam[c][<span class="number">1</span>] &lt;&lt; v14</span><br><span class="line">    <span class="keyword">return</span> tmp, v14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">c, v14</span>):</span><br><span class="line">    exam = &#123;c: generate_0(<span class="built_in">ord</span>(c))&#125;</span><br><span class="line">    v14 = v14 - exam[c][<span class="number">0</span>]</span><br><span class="line">    tmp = exam[c][<span class="number">2</span>] &lt;&lt; v14</span><br><span class="line">    <span class="keyword">return</span> tmp, v14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算第一个部分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_first_part</span>(<span class="params">s</span>):</span><br><span class="line">    v14 = <span class="number">0x20</span></span><br><span class="line">    tmp, v14 = test_1(s[<span class="number">0</span>], v14)</span><br><span class="line">    tmp2, v14 = test_1(s[<span class="number">1</span>], v14)</span><br><span class="line">    tmp3, v14 = test_1(s[<span class="number">2</span>], v14)</span><br><span class="line">    tmp4, v14 = test_1(s[<span class="number">3</span>], v14)</span><br><span class="line">    tmp5, v14 = test_2(s[<span class="number">0</span>], v14)</span><br><span class="line">    tmp6, v14 = test_2(s[<span class="number">1</span>], v14)</span><br><span class="line">    tmp7, v14 = test_2(s[<span class="number">2</span>], v14)</span><br><span class="line">    tmp8, v14 = test_2(s[<span class="number">3</span>], v14)</span><br><span class="line">    <span class="keyword">return</span> tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查第一个部分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_first_part</span>(<span class="params">second_part, first_part, d</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> d[second_part[<span class="number">0</span>]]:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> d[second_part[<span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> d[second_part[<span class="number">2</span>]]:</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> d[second_part[<span class="number">3</span>]]:</span><br><span class="line">                    tmp = i + j + k + m</span><br><span class="line">                    <span class="keyword">if</span> calc_first_part(tmp) == first_part:</span><br><span class="line">                        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line">d = classify()</span><br><span class="line">s2 = <span class="string">&#x27;  03\&quot;3   0 203\&quot;   $ &#x27;</span></span><br><span class="line">s = [<span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;EA&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;DE&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;3B&#x27;</span>, <span class="string">&#x27;BE&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;D4&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;B6&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;B7&#x27;</span>, <span class="string">&#x27;AF&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;7F&#x27;</span>, <span class="string">&#x27;CF&#x27;</span>]</span><br><span class="line">flag = <span class="string">&#x27;swpuctf&#123;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    first_part = <span class="built_in">int</span>(s[<span class="number">3</span> + <span class="number">4</span> * i] + s[<span class="number">2</span> + <span class="number">4</span> * i] + s[<span class="number">1</span> + <span class="number">4</span> * i] + s[<span class="number">4</span> * i], <span class="number">16</span>)</span><br><span class="line">    second_part = s2[i * <span class="number">4</span>:i * <span class="number">4</span> + <span class="number">4</span>]</span><br><span class="line">    res = check_first_part(second_part, first_part, d)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        flag += res</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    flag += res + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">flag += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#swpuctf&#123;we18-l8co-m1e4-58to-swpu&#125;</span></span><br></pre></td></tr></table></figure><h2 id="EasiestRe（双进程-自修改-背包加密）"><a href="#EasiestRe（双进程-自修改-背包加密）" class="headerlink" title="EasiestRe（双进程+自修改+背包加密）"></a>EasiestRe（双进程+自修改+背包加密）</h2><p><a href="https://www.nssctf.cn/problem/40">[SWPU 2019]EasiestRe | NSSCTF</a></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h4><p>进来先看到IsDebuggerPresent，运行一下发现和直接打开的结果不一样，双进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( IsDebuggerPresent() )  <span class="comment">//调试器进程</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">if</span> ( CreateProcessA(Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )  <span class="comment">//正常进程</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  PVOID lpBaseAddress; <span class="comment">// [esp+18h] [ebp-558h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+1Fh] [ebp-551h]</span></span><br><span class="line">  DWORD dwContinueStatus; <span class="comment">// [esp+20h] [ebp-550h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> <span class="title">DebugEvent</span>;</span> <span class="comment">// [esp+28h] [ebp-548h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// [esp+8Fh] [ebp-4E1h]</span></span><br><span class="line">  CONTEXT Context; <span class="comment">// [esp+94h] [ebp-4DCh] BYREF</span></span><br><span class="line">  HANDLE hThread; <span class="comment">// [esp+364h] [ebp-20Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+368h] [ebp-208h]</span></span><br><span class="line">  SIZE_T NumberOfBytesRead[<span class="number">3</span>]; <span class="comment">// [esp+370h] [ebp-200h] BYREF</span></span><br><span class="line">  SIZE_T NumberOfBytesWritten[<span class="number">3</span>]; <span class="comment">// [esp+37Ch] [ebp-1F4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> Buffer[<span class="number">60</span>]; <span class="comment">// [esp+388h] [ebp-1E8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v15[<span class="number">40</span>]; <span class="comment">// [esp+3C4h] [ebp-1ACh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16[<span class="number">16</span>]; <span class="comment">// [esp+3ECh] [ebp-184h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> <span class="title">StartupInfo</span>;</span> <span class="comment">// [esp+3FCh] [ebp-174h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> <span class="title">ProcessInformation</span>;</span> <span class="comment">// [esp+448h] [ebp-128h] BYREF</span></span><br><span class="line">  CHAR Filename[<span class="number">267</span>]; <span class="comment">// [esp+460h] [ebp-110h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;ProcessInformation, <span class="number">0</span>, <span class="keyword">sizeof</span>(ProcessInformation));</span><br><span class="line">  j__memset(&amp;StartupInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(StartupInfo));</span><br><span class="line">  v16[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v16[<span class="number">1</span>] = <span class="number">0x83</span>;</span><br><span class="line">  v16[<span class="number">2</span>] = <span class="number">0x7D</span>;</span><br><span class="line">  v16[<span class="number">3</span>] = <span class="number">0xF8</span>;</span><br><span class="line">  v16[<span class="number">4</span>] = <span class="number">0x18</span>;</span><br><span class="line">  v16[<span class="number">5</span>] = <span class="number">0x7D</span>;</span><br><span class="line">  v16[<span class="number">6</span>] = <span class="number">0x11</span>;</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v15[<span class="number">1</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">2</span>] = <span class="number">0xB6</span>;</span><br><span class="line">  v15[<span class="number">3</span>] = <span class="number">0x55</span>;</span><br><span class="line">  v15[<span class="number">4</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">5</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">6</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">  v15[<span class="number">8</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">9</span>] = <span class="number">4</span>;</span><br><span class="line">  v15[<span class="number">10</span>] = <span class="number">0x90</span>;</span><br><span class="line">  v15[<span class="number">11</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">12</span>] = <span class="number">0xAF</span>;</span><br><span class="line">  v15[<span class="number">13</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">14</span>] = <span class="number">0xFC</span>;</span><br><span class="line">  v15[<span class="number">15</span>] = <span class="number">0x33</span>;</span><br><span class="line">  v15[<span class="number">16</span>] = <span class="number">0xD2</span>;</span><br><span class="line">  v15[<span class="number">17</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">18</span>] = <span class="number">0x75</span>;</span><br><span class="line">  v15[<span class="number">19</span>] = <span class="number">0xF8</span>;</span><br><span class="line">  v15[<span class="number">20</span>] = <span class="number">0xF</span>;</span><br><span class="line">  v15[<span class="number">21</span>] = <span class="number">0xB6</span>;</span><br><span class="line">  v15[<span class="number">22</span>] = <span class="number">0x4D</span>;</span><br><span class="line">  v15[<span class="number">23</span>] = <span class="number">0xF7</span>;</span><br><span class="line">  v15[<span class="number">24</span>] = <span class="number">0x8B</span>;</span><br><span class="line">  v15[<span class="number">25</span>] = <span class="number">0x45</span>;</span><br><span class="line">  v15[<span class="number">26</span>] = <span class="number">0xC</span>;</span><br><span class="line">  v15[<span class="number">27</span>] = <span class="number">0x89</span>;</span><br><span class="line">  v15[<span class="number">28</span>] = <span class="number">0x14</span>;</span><br><span class="line">  v15[<span class="number">29</span>] = <span class="number">0x88</span>;</span><br><span class="line">  j__memset(Buffer, <span class="number">0</span>, <span class="number">0x32u</span>);</span><br><span class="line">  NumberOfBytesWritten[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( IsDebuggerPresent() )                    <span class="comment">// 调试器进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetStartupInfoA(&amp;StartupInfo);</span><br><span class="line">    GetModuleFileNameA(<span class="number">0</span>, Filename, <span class="number">0x104u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( CreateProcessA(Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation) )<span class="comment">// 创建新进程</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="number">1</span>;</span><br><span class="line">LABEL_6:</span><br><span class="line">      <span class="keyword">while</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">        WaitForDebugEvent(&amp;DebugEvent, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        <span class="keyword">switch</span> ( DebugEvent.dwDebugEventCode )  <span class="comment">// 处理调试事件</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">            <span class="keyword">if</span> ( DebugEvent.u.Exception.ExceptionRecord.ExceptionCode == <span class="number">0x80000003</span> )<span class="comment">// 遇到调试断点</span></span><br><span class="line">            &#123;</span><br><span class="line">              v8 = <span class="number">1</span>;                           <span class="comment">// 继续执行程序，跳过当前异常</span></span><br><span class="line">              dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">              lpBaseAddress = DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress;<span class="comment">// 保存异常的地址（即断点地址）</span></span><br><span class="line">              ReadProcessMemory(                <span class="comment">// 读取 35 字节的内存数据到buffer里</span></span><br><span class="line">                ProcessInformation.hProcess,</span><br><span class="line">                DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,</span><br><span class="line">                Buffer,</span><br><span class="line">                <span class="number">0x23u</span>,</span><br><span class="line">                NumberOfBytesRead);</span><br><span class="line">              <span class="keyword">if</span> ( NumberOfBytesRead[<span class="number">0</span>] )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">35</span> &amp;&amp; Buffer[i] == <span class="number">0x90</span>; ++i )<span class="comment">// 检查nop</span></span><br><span class="line">                  ;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> ( i == <span class="number">1</span> )</span><br><span class="line">                v8 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v8 )                         <span class="comment">// v8非0则继续执行，v8为0则跳转到dwContinueStatus = 0x80010001;</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( i )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    Context.ContextFlags = <span class="number">65543</span>;</span><br><span class="line">                    hThread = OpenThread(<span class="number">0x1FFFFFu</span>, <span class="number">0</span>, DebugEvent.dwThreadId);</span><br><span class="line">                    <span class="keyword">if</span> ( !GetThreadContext(hThread, &amp;Context) )</span><br><span class="line">                      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">                    ++Context.Eip;</span><br><span class="line">                    <span class="keyword">if</span> ( SetThreadContext(hThread, &amp;Context) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      dwContinueStatus = <span class="number">0x10002</span>;</span><br><span class="line">                      CloseHandle(hThread);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">LABEL_31:</span><br><span class="line">                    ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x80010001</span>);</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">7</span>:                       <span class="comment">// 将v16的数据写入lpBaseAddress</span></span><br><span class="line">                                                <span class="comment">// 然后读取lpBaseAddress 处的数据并存储在 Buffer 中</span></span><br><span class="line">                                                <span class="comment">// 成功写入 7 字节数据则继续执行程序</span></span><br><span class="line">                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="number">7u</span>, NumberOfBytesWritten);</span><br><span class="line">                    <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">7</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="number">7u</span>, NumberOfBytesRead);</span><br><span class="line">                      dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">30</span>:                      <span class="comment">// v15 中的 30 字节数据写入lpBaseAddress</span></span><br><span class="line">                    WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v15, <span class="number">0x1Eu</span>, NumberOfBytesWritten);</span><br><span class="line">                    <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">30</span> )</span><br><span class="line">                      dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                  <span class="keyword">default</span>:                      <span class="comment">// i！=4，5，7，30</span></span><br><span class="line">                    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              dwContinueStatus = <span class="number">0x80010001</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">            v5 = <span class="number">0</span>;</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002u</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">LABEL_33:</span><br><span class="line">            ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinueStatus);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_F53922();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sub-F58A40"><a href="#sub-F58A40" class="headerlink" title="sub_F58A40"></a>sub_F58A40</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text:00F58AF8                 int     3               ; Trap to Debugger</span><br><span class="line">text:00F58AF9                 nop</span><br><span class="line">text:00F58AFA                 nop</span><br><span class="line">text:00F58AFB                 nop</span><br><span class="line">text:00F58AFC                 nop</span><br><span class="line">text:00F58AFD                 nop</span><br><span class="line">text:00F58AFE                 nop</span><br><span class="line">text:00F58AFF                 push    offset aYouAreTooShort ; &quot;you are too short!&quot;</span><br><span class="line">text:00F58B04                 call    printf</span><br></pre></td></tr></table></figure><p>根据上面的分析，遇到int 3会写入v16 7字节的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:                      </span><br><span class="line">                   WriteProcessMemory(ProcessInformation.hProcess, lpBaseAddress, v16, <span class="number">7u</span>, NumberOfBytesWritten);</span><br><span class="line">                   <span class="keyword">if</span> ( NumberOfBytesWritten[<span class="number">0</span>] == <span class="number">7</span> )</span><br><span class="line">                   &#123;</span><br><span class="line">                     ReadProcessMemory(ProcessInformation.hProcess, lpBaseAddress, Buffer, <span class="number">7u</span>, NumberOfBytesRead);</span><br><span class="line">                     dwContinueStatus = <span class="number">65538</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">goto</span> LABEL_33;</span><br></pre></td></tr></table></figure><p>paste data就行</p><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501051651130.png" alt="image"></p><h4 id="sub-F587E0"><a href="#sub-F587E0" class="headerlink" title="sub_F587E0"></a>sub_F587E0</h4><p><img src="https://raw.githubusercontent.com/QYQS1/picture/main/test/202501080247609.png" alt="1736275603403.png"></p><p>30字节的有点长，idapython吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取的字节位置范围：从 0xF58C45 到 0xF58D10</span></span><br><span class="line">start_addr = <span class="number">0x00F58C45</span>  <span class="comment"># 起始地址</span></span><br><span class="line">end_addr = <span class="number">0x00F58D10</span>    <span class="comment"># 结束地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储字节的列表</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历指定地址范围</span></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(start_addr, end_addr + <span class="number">1</span>):  <span class="comment"># 按字节逐个读取</span></span><br><span class="line">    byte = idaapi.get_byte(addr)  <span class="comment"># 获取当前地址的字节</span></span><br><span class="line">    <span class="keyword">if</span> byte != -<span class="number">1</span>:  <span class="comment"># 确保字节有效</span></span><br><span class="line">        data.append(byte)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只提取存储到内存中的字节（每条 mov 指令的最后一个字节）</span></span><br><span class="line">stored_values = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data) - <span class="number">6</span>, <span class="number">7</span>):  <span class="comment"># 每条指令为 7 字节，确保有足够字节</span></span><br><span class="line">    stored_values.append(data[i + <span class="number">6</span>])  <span class="comment"># 存储每条 mov 指令的最后一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印提取的存储字节值作为数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stored values in array:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[&quot;</span> + <span class="string">&quot;, &quot;</span>.join(<span class="string">&quot;0x&#123;:02X&#125;&quot;</span>.<span class="built_in">format</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> stored_values) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[0x90, 0x0F, 0xB6, 0x55, 0xF7, 0x8B, 0x45, 0x08, 0x8B, 0x04, 0x90, 0x0F, 0xAF, 0x45, 0xFC, 0x33, 0xD2, 0xF7, 0x75, 0xF8, 0x0F, 0xB6, 0x4D, 0xF7, 0x8B, 0x45, 0x0C, 0x89, 0x14，0x88]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span>*</span><br><span class="line">data=[<span class="number">0x90</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x55</span>, <span class="number">0xF7</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x08</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x90</span>, <span class="number">0x0F</span>, <span class="number">0xAF</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x33</span>, <span class="number">0xD2</span>, <span class="number">0xF7</span>, <span class="number">0x75</span>, <span class="number">0xF8</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x4D</span>, <span class="number">0xF7</span>, <span class="number">0x8B</span>, <span class="number">0x45</span>, <span class="number">0x0C</span>, <span class="number">0x89</span>, <span class="number">0x14</span>,<span class="number">0x88</span>]</span><br><span class="line">b=<span class="number">0x0F58824</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    ida_bytes.patch_byte(b+i,data[i])</span><br></pre></td></tr></table></figure><p>修完</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __cdecl <span class="title function_">sub_F587E0</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 i; <span class="comment">// [esp+3h] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8u</span>; ++i )</span><br><span class="line">    *(a2 + <span class="number">4</span> * i) = <span class="number">41</span> * *(a1 + <span class="number">4</span> * i) % <span class="number">0x1EBu</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要个in3+3个nop，根据主函数分析不管它</p><h4 id="sub-F583C0"><a href="#sub-F583C0" class="headerlink" title="sub_F583C0"></a>sub_F583C0</h4><p>in3+4个nop，对应case4，main里的处理是eip+1跳过异常</p><p><del>在int3那里下个断点，动调一下看看程序咋处理这里的</del></p><p>忘了双线程了，apply patch to programm，然后运行一下exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:0069842B                               ;   __try &#123; // __except at loc_69845A</span><br><span class="line">.text:0069842B C7 45 FC 00 00 00 00          mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00698432 CC                            int     3                               ; Trap to Debugger</span><br><span class="line">.text:00698433 90                            nop</span><br><span class="line">.text:00698434 90                            nop</span><br><span class="line">.text:00698435 90                            nop</span><br><span class="line">.text:00698436 90                            nop</span><br><span class="line">....</span><br><span class="line">.text:0069845A                               loc_69845A:                             ; DATA XREF: .rdata:stru_7783E8↓o</span><br><span class="line">.text:0069845A                               ;   __except(loc_698454) // owned by 69842B</span><br><span class="line">.text:0069845A 8B 65 E8                      mov     esp, [ebp+ms_exc.old_esp]</span><br></pre></td></tr></table></figure><p>这里直接跳到了loc_69845A，有点像密文密钥之类的，同样的我们keypatch in3 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 3 -&gt; jmp loc_69845A</span><br></pre></td></tr></table></figure><p>然后就是解密了，背包加密网上随便找个脚本改改</p><p>swpuctf{y0u_@re_s0_coo1}</p><h2 id="zer0pts-2020-vmlog（vm）"><a href="#zer0pts-2020-vmlog（vm）" class="headerlink" title="[zer0pts 2020]vmlog（vm）"></a>[zer0pts 2020]vmlog（vm）</h2><p><a href="https://www.nssctf.cn/problem/61">[zer0pts 2020]vmlog | NSSCTF</a></p><p>拿到vm.py和log.txt，vm.py实现了一个自定义的指令集，行为取决于program变量和输入。做vm题的常规思路就是把汇编打印出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> program <span class="keyword">import</span> program</span><br><span class="line"></span><br><span class="line">reg = <span class="number">0</span></span><br><span class="line">mem = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">p = <span class="number">0</span></span><br><span class="line">pc = <span class="number">0</span></span><br><span class="line">buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(program)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> pc &lt; <span class="built_in">len</span>(program):</span><br><span class="line">    op = program[pc]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        reg += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> add reg 1 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        reg -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> sub reg 1 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        reg *= mem[p]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mul reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;%&quot;</span>:</span><br><span class="line">        reg = mem[p] % reg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mod reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        reg = mem[p]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov reg mem[<span class="subst">&#123;p&#125;</span>] #reg=<span class="subst">&#123;reg&#125;</span>,p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;s&quot;</span>:</span><br><span class="line">        mem[p] = reg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov mem[<span class="subst">&#123;p&#125;</span>] reg #mem=<span class="subst">&#123;mem&#125;</span>,p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        p = (p + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> inc p 1 #p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        p = (p - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> dec p 1 #p=<span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">        a = sys.stdin.buffer.read(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> getchar&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">            reg = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov, reg 0 #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            reg += <span class="built_in">ord</span>(a)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> mov, reg <span class="subst">&#123;<span class="built_in">ord</span>(a)&#125;</span> #input #reg=<span class="subst">&#123;reg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;p&quot;</span>:</span><br><span class="line">        buf += <span class="built_in">str</span>(reg)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> buf+=str(reg)&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> cmp reg 0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg == <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">                pc += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> jz &quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> cmp reg 0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> reg != <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt != <span class="number">0</span>:</span><br><span class="line">                pc -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> program[pc] == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pc&#125;</span> jnz &quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;M&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(mem)</span><br><span class="line"></span><br><span class="line">    pc += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------------------&quot;</span>)</span><br><span class="line"><span class="comment">#print(f&quot;PC: &#123;pc&#125;, OP: &#123;op&#125;, REG: &#123;reg&#125;, MEM: &#123;mem&#125;, P: &#123;p&#125;, BUF: &#x27;&#123;buf&#125;&#x27;&quot;)</span></span><br></pre></td></tr></table></figure><p>给的log.txt是program+运行日志</p><p>自己再定义一个program.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program = <span class="string">&quot;M+s+&gt;s&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[s&lt;&lt;l&gt;*&lt;s&gt;&gt;l-]&lt;&lt;l-s&gt;l*-s*-s*-s*-s*-s*-s&gt;l*+++++s*-----s****s&gt;&gt;l+s[Ml-s&lt;&lt;l&gt;,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s&gt;&gt;l&lt;s&gt;l+s&lt;l]&gt;l]&lt;&lt;lp&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M+s+&gt;s&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[s&lt;&lt;l&gt;*&lt;s&gt;&gt;l-]&lt;&lt;l-s</span><br><span class="line">&gt;l*-s*-s*-s*-s*-s*-s</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>M</code></strong>：打印初始内存状态，便于调试。</p></li><li><p><code>s</code> 和 <code>l</code></p><p>：将值存储到内存或加载到寄存器。</p><ul><li><code>mem[0]</code> 被设置为一个大值（262−12^{62} - 1262−1），通常用于模运算。</li><li><code>mem[1]</code> 被设置为 2（基数 <code>r</code>）。</li><li><code>mem[2]</code> 被设置为 1（初始哈希值 <code>h</code>）。</li></ul></li><li><p>推断</p><ul><li>这种初始化方式非常典型，常见于滚动哈希算法的实现。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s</span><br></pre></td></tr></table></figure><ul><li><strong><code>[ ,</code></strong>：开始读取输入字符。</li><li><strong><code>&lt;&lt;\*</code></strong>：当前哈希值 <code>h</code> 加上输入字符后，乘以基数 <code>r</code>。</li><li><strong><code>%</code></strong>：对模数 <code>m</code> 取模，防止哈希值溢出。</li><li>推断<ul><li>这是滚动哈希算法的核心公式： h=(h+input)⋅rmod  mh = (h + \text{input}) \cdot r \mod mh=(h+input)⋅rmodm</li></ul></li></ul><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ml-s&lt;&lt;l&gt;,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s&gt;&gt;l&lt;s&gt;l+s&lt;l]&gt;l]&lt;&lt;lp</span><br></pre></td></tr></table></figure><ul><li>循环核心<ul><li><code>[Ml-s&lt;&lt;l&gt;</code>：开始新一轮的哈希值更新，标志位控制。</li><li><code>,[&lt;&lt;*&gt;&gt;s&lt;&lt;&lt;l&gt;&gt;&gt;%&lt;s</code>：对每个输入字符进行滚动哈希更新。</li><li><code>&gt;l+s&lt;l]</code>：设置标志位，继续下一轮输入处理。</li></ul></li><li>推断<ul><li>滚动哈希的本质是对输入字符的逐个处理，结合乘法、加法和模运算。</li></ul></li></ul><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;lp</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>输出最终的哈希值 <code>h</code>（存储在 <code>mem[2]</code>）。</li></ul></li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\LeStoreDownload\webpage\CTF\nssctf\[zer0pts 2020]vmlog\tmp\log.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    prev_h = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            arr = <span class="built_in">eval</span>(l.strip())</span><br><span class="line">            <span class="keyword">if</span> arr[<span class="number">4</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> prev_h:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                        <span class="keyword">if</span> (prev_h + i) * arr[<span class="number">1</span>] % arr[<span class="number">0</span>] == arr[<span class="number">2</span>]:</span><br><span class="line">                            flag += <span class="built_in">chr</span>(i)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                prev_h = arr[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#zer0pts&#123;3asy_t0_f0110w_th3_l0g?&#125;</span></span><br></pre></td></tr></table></figure><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDApython学习</title>
      <link href="/2024/12/30/%E5%88%9D%E8%AF%86IDApython/"/>
      <url>/2024/12/30/%E5%88%9D%E8%AF%86IDApython/</url>
      
        <content type="html"><![CDATA[<h1 id="IDApython-amp-IDC"><a href="#IDApython-amp-IDC" class="headerlink" title="IDApython&amp;IDC"></a><strong>IDApython&amp;IDC</strong></h1><p>IDApython 官方文档：<a href="https://docs.hex-rays.com/developer-guide/idapython">IDAPython | Hex-Rays Docs</a></p><p>IDC 官方文档：<a href="https://docs.hex-rays.com/developer-guide/idc">IDC | Hex-Rays Docs</a></p><h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a><strong>常用模块</strong></h1><h2 id="1-IDC"><a href="#1-IDC" class="headerlink" title="1.IDC"></a><strong>1.IDC</strong></h2><p>与 IDA 命令行进行交互的模块，提供了很多 IDA 中指令相关的函数。</p><ul><li><strong><code>idc.get_name(ea)</code></strong>：获取地址 <code>ea</code> 处的名称。</li><li><strong><code>idc.get_func_name(ea)</code></strong>：获取函数地址处的函数名称。</li><li><strong><code>idc.set_name(ea, name)</code></strong>：为地址 <code>ea</code> 设置一个新的名称。</li><li><strong><code>idc.add_entry(ea, name, start, end)</code></strong>：在 <code>ea</code> 处添加一个入口点。</li><li><strong><code>idc.get_func(ea)</code></strong>：获取 <code>ea</code> 处的函数结构。</li></ul><h2 id="2-IDAAPI"><a href="#2-IDAAPI" class="headerlink" title="2.IDAAPI"></a><strong>2.IDAAPI</strong></h2><p>与 IDA 的核心 API 交互的主要模块。包括了对 IDA 核心对象的访问，涵盖了地址、函数、节等许多底层操作。</p><ul><li><strong><code>idaapi.get_func(ea)</code></strong>：返回地址 <code>ea</code> 处的函数对象。</li><li><strong><code>idaapi.get_flags(ea)</code></strong>：返回地址 <code>ea</code> 的标志，表示它是代码、数据还是其他类型。</li><li><strong><code>idaapi.create_data(ea, size, type)</code></strong>：在地址 <code>ea</code> 处创建数据。</li><li><strong><code>idaapi.get_strlit_contents(ea)</code></strong>：获取 <code>ea</code> 处的字符串内容。</li><li><strong><code>idaapi.add_func(ea)</code></strong>：将地址 <code>ea</code> 添加为一个函数。</li></ul><h2 id="3-IDAUTILS"><a href="#3-IDAUTILS" class="headerlink" title="3.IDAUTILS"></a><strong>3.IDAUTILS</strong></h2><p>工具函数，帮助在反汇编中自动化和简化分析过程。</p><ul><li><strong><code>idautils.Functions(start, end)</code></strong>：遍历在 <code>start</code> 到 <code>end</code> 地址范围内的所有函数。</li><li><strong><code>idautils.DecodeInstruction(ea)</code></strong>：解码地址 <code>ea</code> 处的指令。</li><li><strong><code>idautils.FindBinary(start, end, pattern, flags)</code></strong>：在指定范围内查找与模式匹配的二进制数据。</li><li><strong><code>idautils.Heads(start, end)</code></strong>：遍历地址范围内的所有指令地址。</li></ul><h2 id="4-ida-bytes"><a href="#4-ida-bytes" class="headerlink" title="4.ida_bytes"></a><strong>4.ida_bytes</strong></h2><p><code>ida_bytes</code> 提供了对内存区域字节级别操作的函数。</p><ul><li><strong><code>ida_bytes.get_byte(ea)</code></strong>：获取 <code>ea</code> 处的一个字节</li><li><strong><code>ida_bytes.get_word(ea)</code></strong>：获取 <code>ea</code> 处的一个字.</li><li><strong><code>ida_bytes.get_dword(ea)</code></strong>：获取 <code>ea</code> 处的一个双字。</li></ul><h2 id="5-ida-struct"><a href="#5-ida-struct" class="headerlink" title="5.ida_struct"></a><strong>5.ida_struct</strong></h2><p><code>ida_struct</code> 处理 IDA 中的结构体。你可以使用它来读取、创建、修改和设置结构体。</p><ul><li><strong><code>ida_struct.get_struc_name(struc)</code></strong>：获取结构体的名称。</li><li><strong><code>ida_struct.add_struc()</code></strong>：添加一个新的结构体。</li><li><strong><code>ida_struct.set_struc_member()</code></strong>：设置结构体成员的属性。</li></ul><h2 id="6-ida-diskio"><a href="#6-ida-diskio" class="headerlink" title="6.ida_diskio"></a><strong>6.ida_diskio</strong></h2><p><code>ida_diskio</code> 提供了与磁盘 IO 操作相关的函数，例如读取或写入文件。</p><ul><li><strong><code>ida_diskio.get_input_file_path()</code></strong>：获取当前输入文件的路径。</li><li><strong><code>ida_diskio.save_input_file()</code></strong>：保存当前输入文件。</li></ul><h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a><strong>常用技巧</strong></h1><h2 id="获取基本块-ida-get-bb"><a href="#获取基本块-ida-get-bb" class="headerlink" title="获取基本块 ida_get_bb"></a><strong>获取基本块 ida_get_bb</strong></h2><p><code>ida_get_bb</code> 函数的功能是获取指定地址 <code>ea</code> 所在的基本块（Basic Block）。基本块是指在程序中连续的一组指令序列，这些指令在程序的控制流图上不会被中断，只有从头到尾的顺序执行，并且只有在块的结束处才能跳出这个块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ida_get_bb</span>(<span class="params">ea</span>):</span><br><span class="line">    f_blocks = idaapi.FlowChart(idaapi.get_func(ea), flags=idaapi.FC_PREDS)</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> f_blocks:</span><br><span class="line">        <span class="keyword">if</span> block.start_ea &lt;= ea <span class="keyword">and</span> ea &lt; block.end_ea:</span><br><span class="line">            <span class="keyword">return</span> block</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="函数功能概述"><a href="#函数功能概述" class="headerlink" title="函数功能概述"></a><strong>函数功能概述</strong></h3><ul><li><strong>输入</strong>：虚拟地址 (<code>ea</code>)，即目标指令的地址。</li><li><strong>输出</strong>：包含该地址的基本块 (<code>block</code>) 或者 <code>None</code>（如果未找到）。</li></ul><h3 id="函数逻辑"><a href="#函数逻辑" class="headerlink" title="函数逻辑"></a><strong>函数逻辑</strong></h3><ol><li>利用 IDA Pro 的 <code>idaapi.FlowChart</code> 类生成当前函数的控制流图（Flow Chart），即函数内的所有基本块。</li><li>遍历每个基本块，检查该基本块的起始地址 (<code>start_ea</code>) 和结束地址 (<code>end_ea</code>)，判断目标地址 (<code>ea</code>) 是否在该基本块范围内。</li><li>如果找到符合条件的基本块，则返回该基本块对象。</li><li>如果遍历完所有基本块都没有找到符合条件的，返回 <code>None</code>。</li></ol><h2 id="创建-删除函数"><a href="#创建-删除函数" class="headerlink" title="创建 / 删除函数"></a><strong>创建 / 删除函数</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idc.add_func(<span class="number">0x401000</span>, <span class="number">0x401050</span>)  <span class="comment"># Create a function starting at 0x401000 and ending at 0x401050</span></span><br><span class="line">idc.del_func(<span class="number">0x401000</span>)  <span class="comment"># Delete the function at 0x401000</span></span><br></pre></td></tr></table></figure><h2 id="获取函数的名称"><a href="#获取函数的名称" class="headerlink" title="获取函数的名称"></a><strong>获取函数的名称</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_func_name(ea)</span><br></pre></td></tr></table></figure><h2 id="遍历所有函数并打印其有效地址和名称"><a href="#遍历所有函数并打印其有效地址和名称" class="headerlink" title="遍历所有函数并打印其有效地址和名称"></a><strong>遍历所有函数并打印其有效地址和名称</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions(): </span><br><span class="line">func_name = idc.get_func_name(func_ea)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(func_ea), func_name)</span><br></pre></td></tr></table></figure><h2 id="列出地址的交叉引用："><a href="#列出地址的交叉引用：" class="headerlink" title="列出地址的交叉引用："></a><strong>列出地址的交叉引用：</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsFrom(<span class="number">0x401000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Xref from 0x401000 to <span class="subst">&#123;<span class="built_in">hex</span>(xref.to)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="遍历所有交叉引用并打印"><a href="#遍历所有交叉引用并打印" class="headerlink" title="遍历所有交叉引用并打印"></a><strong>遍历所有交叉引用并打印</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ref in idautils.XrefsTo(ea):</span><br><span class="line">  print(hex(ref.frm))</span><br></pre></td></tr></table></figure><h2 id="获取段地址"><a href="#获取段地址" class="headerlink" title="获取段地址"></a>获取段地址</h2><p><code>idautils.Segments()</code> 返回 <strong>所有段的起始地址</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    seg_name = idc.get_segm_name(seg)</span><br><span class="line">    <span class="keyword">if</span> seg_name != <span class="string">&quot;.text&quot;</span> <span class="keyword">and</span> seg_name != <span class="string">&quot;UPX0&quot;</span>:</span><br><span class="line">        <span class="comment"># print(f&quot;跳过段: &#123;seg_name&#125; (0x&#123;seg:X&#125;)&quot;)</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在处理段: <span class="subst">&#123;seg_name&#125;</span> (0x<span class="subst">&#123;seg:X&#125;</span>)&quot;</span>)</span><br><span class="line">    start_ea = seg</span><br><span class="line">    end_ea = idc.get_segm_end(seg) <span class="comment">#返回段的结束地址。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文本-指令搜索"><a href="#文本-指令搜索" class="headerlink" title="文本 / 指令搜索"></a><strong>文本 / 指令搜索</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索整个内存区域的字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_string</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> idautils.Strings():</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> ea:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found string at <span class="subst">&#123;<span class="built_in">hex</span>(ea)&#125;</span>: <span class="subst">&#123;ea&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 &quot;Hello&quot; 字符串</span></span><br><span class="line">search_string(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#搜索汇编指令</span></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_asm_instruction</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="comment"># 遍历整个程序的所有指令</span></span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> idautils.Heads(idc.get_segm_by_name(<span class="string">&quot;.text&quot;</span>), idc.get_segm_end(idc.get_segm_by_name(<span class="string">&quot;.text&quot;</span>))):</span><br><span class="line">        disasm = idc.GetDisasm(ea)  <span class="comment"># 获取地址处的反汇编指令</span></span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> disasm:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found instruction at <span class="subst">&#123;<span class="built_in">hex</span>(ea)&#125;</span>: <span class="subst">&#123;disasm&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 &quot;mov eax, ebx&quot; 指令</span></span><br><span class="line">search_asm_instruction(<span class="string">&quot;mov eax, ebx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="循环左移-右移"><a href="#循环左移-右移" class="headerlink" title="循环左移 / 右移"></a><strong>循环左移 / 右移</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ROR</span>(<span class="params">i,index</span>):<span class="comment">#循环又移</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].rjust(<span class="number">8</span>,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        tmp = tmp[-<span class="number">1</span>] + tmp[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ROL</span>(<span class="params">i,index</span>):<span class="comment">#循环左移</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        tmp = tmp[<span class="number">1</span>:] + tmp[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实例</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def ROR(i,index):</span><br><span class="line">    tmp = bin(i)[2:].rjust(8,&quot;0&quot;)</span><br><span class="line">    for _ in range(index):</span><br><span class="line">        tmp = tmp[-1] + tmp[:-1]</span><br><span class="line">    return int(tmp, 2)</span><br><span class="line">    </span><br><span class="line">addr1=0x140001085</span><br><span class="line">addr2=0x140001d00</span><br><span class="line">for i in range(addr2-addr1):</span><br><span class="line">    PatchByte(addr1+i,ROR(Byte(addr1+i),3)^90)</span><br><span class="line">print(&#x27;successful&#x27;)</span><br></pre></td></tr></table></figure><h2 id="列出-segment-函数（以及它们的交叉引用）"><a href="#列出-segment-函数（以及它们的交叉引用）" class="headerlink" title="列出 segment 函数（以及它们的交叉引用）"></a><strong>列出 segment 函数（以及它们的交叉引用）</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_xref</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ida_auto.auto_wait()  <span class="comment"># 确保 IDA 完成自动分析</span></span><br><span class="line">    ea = ida_kernwin.get_screen_ea()</span><br><span class="line">    seg = ida_segment.getseg(ea)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> seg:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No segment found at 0x%x&quot;</span> % ea)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    func = ida_funcs.get_func(seg.start_ea)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">        func = ida_funcs.get_next_func(seg.start_ea)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> func <span class="keyword">and</span> func.start_ea &lt; seg.end_ea:</span><br><span class="line">        funcea = func.start_ea</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Function %s at 0x%x&quot;</span> % (ida_funcs.get_func_name(funcea), funcea))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查找对 funcea 的交叉引用</span></span><br><span class="line">        xb = ida_xref.xrefblk_t()</span><br><span class="line">        <span class="keyword">if</span> xb.first_to(funcea, ida_xref.XREF_ALL):</span><br><span class="line">            <span class="keyword">while</span> xb.iscode:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  called from %s(0x%x)&quot;</span> % (ida_funcs.get_func_name(xb.frm), xb.frm))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> xb.next_to():</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        func = ida_funcs.get_next_func(funcea)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="列出-segment-中的所有函数-（和交叉引用）"><a href="#列出-segment-中的所有函数-（和交叉引用）" class="headerlink" title="列出 segment 中的所有函数 （和交叉引用）"></a><strong>列出 segment 中的所有函数 （和交叉引用）</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_idaapi</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Get current ea</span></span><br><span class="line">    ea = ida_kernwin.get_screen_ea()</span><br><span class="line">    <span class="keyword">if</span> ea == ida_idaapi.BADADDR:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Could not get get_screen_ea()&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    seg = ida_segment.getseg(ea)</span><br><span class="line">    <span class="keyword">if</span> seg:</span><br><span class="line">        <span class="comment"># Loop from start to end in the current segment</span></span><br><span class="line">        <span class="keyword">for</span> funcea <span class="keyword">in</span> idautils.Functions(seg.start_ea, seg.end_ea):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Function %s at 0x%x&quot;</span> % (ida_funcs.get_func_name(funcea), funcea))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Find all code references to funcea</span></span><br><span class="line">            <span class="keyword">for</span> ref <span class="keyword">in</span> idautils.CodeRefsTo(funcea, <span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  called from %s(0x%x)&quot;</span> % (ida_funcs.get_func_name(ref), ref))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please position the cursor within a segment&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="获取并打印当前光标所在函数（或代码块）的详细信息"><a href="#获取并打印当前光标所在函数（或代码块）的详细信息" class="headerlink" title="获取并打印当前光标所在函数（或代码块）的详细信息"></a>获取并打印当前光标所在函数（或代码块）的详细信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_flags</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的标志信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数标志: %08X&quot;</span> % fn.flags)</span><br><span class="line">    <span class="keyword">if</span> fn.is_far():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  远函数&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fn.does_return():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数不会返回&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_FRAME:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数使用帧指针&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_THUNK:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数是 Thunk 函数&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_LUMINA:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数信息由 Lumina 提供&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> fn.flags &amp; ida_funcs.FUNC_OUTLINE:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  该函数是伪代码函数（非真实函数）&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_regvars</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数中的重命名寄存器信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(pfn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个重命名寄存器&quot;</span> % pfn.regvarqty)</span><br><span class="line">    <span class="keyword">for</span> rv <span class="keyword">in</span> pfn.regvars:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%08X..%08X &#x27;%s&#x27;-&gt;&#x27;%s&#x27;&quot;</span> % (rv.start_ea, rv.end_ea, rv.canon, rv.user))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_regargs</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印寄存器传递的参数信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(pfn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个寄存器参数&quot;</span> % pfn.regargqty)</span><br><span class="line">    <span class="keyword">for</span> ra <span class="keyword">in</span> pfn.regargs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  寄存器编号=%d, 参数名称=\&quot;%s\&quot;, (序列化类型)=\&quot;%s\&quot;&quot;</span> % (</span><br><span class="line">            ra.reg,</span><br><span class="line">            ra.name,</span><br><span class="line">            binascii.hexlify(ra.<span class="built_in">type</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_tails</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的尾块信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(pfn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个尾块&quot;</span> % pfn.tailqty)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pfn.tailqty):</span><br><span class="line">        ft = pfn.tails[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  尾块 %i: %08X..%08X&quot;</span> % (i, ft.start_ea, ft.end_ea))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_stkpnts</span>(<span class="params">pfn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的栈调整点信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该函数有 %d 个栈调整点&quot;</span> % pfn.pntqty)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pfn.pntqty):</span><br><span class="line">        pnt = pfn.points[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  栈调整点 %i @%08X: %d&quot;</span> % (i, pnt.ea, pnt.spd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_frame</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数的栈帧信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_entry(fn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;帧结构 ID: %08X&quot;</span> % fn.frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;局部变量区大小: %8X&quot;</span> % fn.frsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;保存寄存器区大小: %8X&quot;</span> % fn.frregs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;返回时清理的字节数: %8X&quot;</span> % fn.argsize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;帧指针偏移量: %8X&quot;</span> % fn.fpd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_parents</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印函数尾块的所有者和引用信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> ida_funcs.is_func_tail(fn)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所属函数: %08X&quot;</span> % fn.owner)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该尾块被 %d 个函数引用&quot;</span> % fn.refqty)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fn.refqty):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  引用者 %i: %08X&quot;</span> % (i, fn.referers[i]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_func_info</span>(<span class="params">ea</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印指定地址所在的函数信息&quot;&quot;&quot;</span></span><br><span class="line">    pfn = ida_funcs.get_fchunk(ea)</span><br><span class="line">    <span class="keyword">if</span> pfn <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;该地址 %08X 处没有函数！&quot;</span> % ea)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前代码块范围: %08X..%08X&quot;</span> % (pfn.start_ea, pfn.end_ea))</span><br><span class="line">    dump_flags(pfn)</span><br><span class="line">    <span class="keyword">if</span> ida_funcs.is_func_entry(pfn):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是一个入口代码块&quot;</span>)</span><br><span class="line">        dump_tails(pfn)</span><br><span class="line">        dump_frame(pfn)</span><br><span class="line">        dump_regvars(pfn)</span><br><span class="line">        dump_regargs(pfn)</span><br><span class="line">        dump_stkpnts(pfn)</span><br><span class="line">    <span class="keyword">elif</span> ida_funcs.is_func_tail(pfn):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是一个尾代码块&quot;</span>)</span><br><span class="line">        dump_parents(pfn)</span><br><span class="line"></span><br><span class="line">ea = ida_kernwin.get_screen_ea()</span><br><span class="line">dump_func_info(ea)</span><br></pre></td></tr></table></figure><h2 id="向现有函数帧添加新成员"><a href="#向现有函数帧添加新成员" class="headerlink" title="向现有函数帧添加新成员"></a><strong>向现有函数帧添加新成员</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_frame</span><br><span class="line"><span class="keyword">import</span> ida_typeinf</span><br><span class="line"><span class="keyword">import</span> ida_range</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_frame_member</span>(<span class="params">func_ea</span>):</span><br><span class="line">    name = <span class="string">&quot;my_stkvar&quot;</span></span><br><span class="line"></span><br><span class="line">    tif = ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT64) </span><br><span class="line">    <span class="comment">#创建了一个 64 位整数 (uint64_t) 的 tinfo_t 类型对象。</span></span><br><span class="line">    tif.create_ptr(tif)</span><br><span class="line">    <span class="comment"># 将其转换为指针类型，即 uint64_t*。</span></span><br><span class="line">    </span><br><span class="line">    func = ida_funcs.get_func(func_ea)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Failed to get function!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Function @ <span class="subst">&#123;func.start_ea:x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    frame_tif = ida_typeinf.tinfo_t()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ida_frame.get_func_frame(frame_tif, func):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Failed to get frame!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;frame_tif._<span class="built_in">print</span>()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    rs = ida_range.rangeset_t()</span><br><span class="line">    sp_offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> frame_tif.calc_gaps(rs):</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">range</span> <span class="keyword">in</span> rs:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">range</span>.start_ea &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> (<span class="built_in">range</span>.end_ea - <span class="built_in">range</span>.start_ea) &gt;= tif.get_size():</span><br><span class="line">                sp_offset = <span class="built_in">range</span>.start_ea</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Range [<span class="subst">&#123;<span class="built_in">range</span>.start_ea:x&#125;</span>, <span class="subst">&#123;<span class="built_in">range</span>.end_ea:x&#125;</span>[ selected.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sp_offset &gt; <span class="number">0</span>:</span><br><span class="line">        sval = ida_frame.calc_frame_offset(func, sp_offset, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 计算在IDA 栈帧结构中的偏移量</span></span><br><span class="line">        <span class="keyword">if</span> ida_frame.add_frame_member(func, name, sval, tif):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Frame member added at frame offset <span class="subst">&#123;sval&#125;</span>!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Failed adding frame member&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Could not find gaps in current frame...&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_frame_member(idc.here())</span><br></pre></td></tr></table></figure><h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><p><code>idaapi.MinEA()</code>：获取载入程序的最小的有效地址。</p><p><code>idaapi.MaxEA()</code>：获取载入的程序最大的有效地址。</p><p><code>idaapi.Assemble(head, line)</code>：从head地址开始反汇编，寻找直到遇到line这条指令时停止，返回两个变量，一个表示是否成功，另外一个是最后这条line指令的字节表示，例如：<code>ret</code>就会是<code>&#39;\xc3&#39;</code>这一个字节来表示，有些指令可能由多个字节表示。</p><p><code>idaapi.GetMnem(addr)</code>：获取addr地址处的指令。</p><p><code>idaapi.MakeCode(addr)</code>：从addr地址开始尝试将数据转换为汇编代码。</p><p><code>idaapi.next_not_tail(addr)</code>：往下走一个指令，如果不是尾部，则返回下一条指令的起始地址。</p><p><code>idaapi.GetDisasm(addr)</code>：获取addr地址开始的一条汇编指令。</p><p><code>idaapi.GetFlags(addr)</code>：获取addr地址处的一系列标志位，可用来<em>判断属于code还是data</em>。</p><p><code>idaapi.isCode(Flags)</code>：通过Flags判断是否是汇编代码。</p><p><code>idaapi.MakeUnkn(addr, size)</code>：取消对addr地址处的size大小的定义，暂不清楚该地址是代码还是数据时可以使用。</p><p><code>idaapi.GetOpnd(addr, index)</code>：取addr地址处的指令的第index个操作数，从零开始，从左开始，依次为intel汇编语法中的目的操作数、源操作数。</p><p><code>idaapi.get_name_ea(min_ea, name)</code>：从min_ea地址开始，寻找名为name的有效地址，该name可以为函数名、label名。</p><p><code>idaapi.get_dword(addr)</code>：从addr地址处获取一个dword数据。</p><p><code>idaapi.MakeDword(addr)</code>：将addr开始的一个DWORD大小的数据定义为双字形式，举一反三，Q代表四字节数据，API形式一致。</p><p><code>idaapi.Segname(addr)</code>：得到addr地址所处的区段名。</p><p><code>idaapi.MakeFunction(addr)</code>：将addr地址处定义为一个函数，相当于快捷键P。</p><p>BADADDR: 常量，代表错误的地址。</p><p><code>idaapi.GetSpd(addr)</code>：获取addr地址处的栈指针SP的值，而在IDA中显示的值则是SP到BP基址针的差值，例如获取到的值为-4，在IDA中显示栈指针的情况时则为4。</p><p><code>idaapi.SetSpDiff(addr, diff)</code>：设置addr地址处的Sp指针与Bp指针的差值，在平衡堆栈时需要用到。</p><p><code>idaapi.next_head(head, BADADDR)</code>：遍历下一条指令，除非遇到BADADDR，返回下一条指令的地址。</p><p><code>idaapi.ua_mnem(addr)</code>：返回addr地址处的指令类型。</p><p><code>idaapi.MakeName(addr, &#39;&#39;)</code>：给addr地址处一个标记label。</p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA, Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识TCP</title>
      <link href="/2024/12/27/%E5%88%9D%E8%AF%86TCP/"/>
      <url>/2024/12/27/%E5%88%9D%E8%AF%86TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="一、TCP特点"><a href="#一、TCP特点" class="headerlink" title="一、TCP特点"></a>一、TCP特点</h3><ol><li><p>面向连接的协议，在传输数据前需要建立一条可靠连接</p></li><li><p>流式协议，TCP将数据看作字节流。传输过程中数据是可以被分割为多个数据包在接收端重新组装的。</p></li><li><p>TCP通过校验和\序列号和确认应答来确保数据的可靠传输，出错回重新传输。</p></li><li><p>服务器被动连接，客户端主动连接。</p></li></ol><h3 id="二、TCP编程"><a href="#二、TCP编程" class="headerlink" title="二、TCP编程"></a>二、TCP编程</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><h5 id="1-创建套接字socket"><a href="#1-创建套接字socket" class="headerlink" title="1.创建套接字socket()"></a>1.创建套接字socket()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"> </span><br><span class="line">功能：</span><br><span class="line">    创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">    domain：通信域，协议族</span><br><span class="line">      AF_UNIX 本地通信</span><br><span class="line">      AF_INET ipv4网络协议</span><br><span class="line">      AF_INET6 ipv6网络协议</span><br><span class="line">      AF_PACKET 底层接口</span><br><span class="line">    type：套接字的类型</span><br><span class="line">      SOCK_STREAM 流式套接字（tcp）</span><br><span class="line">      SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line">      SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line">    protocol：附加协议，如果不需要，则设置为<span class="number">0</span></span><br><span class="line"> </span><br><span class="line">返回值：</span><br><span class="line">    成功：文件描述符</span><br><span class="line">    失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-绑定套接字bind"><a href="#2-绑定套接字bind" class="headerlink" title="2.绑定套接字bind()"></a>2.绑定套接字bind()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：</span><br><span class="line">    将套接字与网络信息结构体绑定</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket的返回值</span><br><span class="line">    addr：网络信息结构体</span><br><span class="line">      通用结构体（一般不用）</span><br><span class="line">      struct sockaddr</span><br><span class="line">      网络信息结构体 sockaddr_in</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">addrlen：</span><br><span class="line">    addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure><h5 id="3-监听套接字listen"><a href="#3-监听套接字listen" class="headerlink" title="3.监听套接字listen()"></a>3.监听套接字listen()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将套接字设置为被动监听状态，这样做之后就可以接收到连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数返回值</span><br><span class="line">    backlog：允许通信连接的主机个数，一般设置为<span class="number">5</span>、<span class="number">10</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="4-接收连接accept"><a href="#4-接收连接accept" class="headerlink" title="4.接收连接accept()"></a>4.接收连接accept()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数的返回值</span><br><span class="line">    addr：接收到的客户端的信息结构体（自动填充，定义变量即可）</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，这个新的文件描述符专门与指定的客户端进行通信的）</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="5-通信recv-send"><a href="#5-通信recv-send" class="headerlink" title="5.通信recv()/send()"></a>5.通信recv()/send()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">功能：</span><br><span class="line">    接收数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符</span><br><span class="line">客户端：socket函数的返回值</span><br><span class="line">服务器：accept函数的返回值</span><br><span class="line">    buf：保存接收到的数据</span><br><span class="line">    len：buf的长度</span><br><span class="line">    flags：标志位</span><br><span class="line">      <span class="number">0</span> 阻塞</span><br><span class="line">      MSG_DONTWAIT 非阻塞</span><br><span class="line">返回值：</span><br><span class="line">    成功：接收的字节数</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line">如果发送端关闭文件描述符或者关闭进程，则recv函数会返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"> </span><br><span class="line">功能：</span><br><span class="line">    发送数据</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符</span><br><span class="line"> </span><br><span class="line">客户端：</span><br><span class="line">    socket函数的返回值</span><br><span class="line">服务器：</span><br><span class="line">    accept函数的返回值</span><br><span class="line"> </span><br><span class="line">     buf：发送的数据</span><br><span class="line">     len：buf的长度</span><br><span class="line">     flags：标志位</span><br><span class="line">       <span class="number">0</span> 阻塞</span><br><span class="line">       MSG_DONTWAIT 非阻塞</span><br><span class="line"> </span><br><span class="line">返回值：</span><br><span class="line">    成功：发送的字节数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6.关闭套接字()"></a>6.关闭套接字()</h5><h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><h5 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket()"></a>1.socket()</h5><h5 id="2-connect"><a href="#2-connect" class="headerlink" title="2.connect()"></a>2.connect()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给服务器发送客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">    sockfd：文件描述符，socket函数的返回值</span><br><span class="line">    addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line">    addrlen：add的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="3-send-recv"><a href="#3-send-recv" class="headerlink" title="3.send()/recv()"></a>3.send()/recv()</h5><h5 id="4-close"><a href="#4-close" class="headerlink" title="4.close()"></a>4.close()</h5><h3 id="三、OSI模型"><a href="#三、OSI模型" class="headerlink" title="三、OSI模型"></a>三、OSI模型</h3><div class="table-container"><table><thead><tr><th>应用层</th><th>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等等</th></tr></thead><tbody><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP、等等</td></tr><tr><td>会话层</td><td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等等</td></tr><tr><td>传输层</td><td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等等</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等等</td></tr><tr><td>物理层</td><td>例如铜缆、网线、光缆、无线电等等</td></tr></tbody></table></div><p><img src="C:\Users\zmycm\AppData\Roaming\Typora\typora-user-images\image-20241124204619077.png" alt="image-20241124204619077"></p><h2 id="DTLS"><a href="#DTLS" class="headerlink" title="DTLS"></a>DTLS</h2><h3 id="1-1DTLS特点作用"><a href="#1-1DTLS特点作用" class="headerlink" title="1.1DTLS特点作用"></a>1.1DTLS特点作用</h3><p><strong>DTLS</strong>: 是一种面向<strong>无连接</strong>的协议，<strong>基于 UDP</strong>，<strong>作用</strong>为给UDP提供端到端的安全通道，就像SSL/TLS对TCP的作用一样。</p><p>SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。</p><p>没用到，用到再来补充</p><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86汇编&amp;内联汇编</title>
      <link href="/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/12/27/X86%E6%B1%87%E7%BC%96and%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h2 id="X86汇编学习"><a href="#X86汇编学习" class="headerlink" title="X86汇编学习"></a>X86汇编学习</h2><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>CPU控制整个计算机运作和运算。要想让CPU工作，就需要向它提供<strong>指令</strong>和<strong>数据</strong>。</p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><h5 id="（1）-汇编指令"><a href="#（1）-汇编指令" class="headerlink" title="（1）.汇编指令"></a>（1）.汇编指令</h5><p>直接被CPU执行的指令</p><h5 id="（2）-伪指令"><a href="#（2）-伪指令" class="headerlink" title="（2）.伪指令"></a>（2）.伪指令</h5><p>指导汇编器工作的指令，不生成机械码。</p><ul><li>段定义指令：如SEGMENT、ENDS，用于定义和结束一个段。</li><li>数据定义指令：如DB、DW，用于定义字节或字数据。</li><li>常量定义指令：如EQU，用于定义常量。</li></ul><h5 id="3-符号指令"><a href="#3-符号指令" class="headerlink" title="(3).符号指令"></a>(3).符号指令</h5><p>用于标识变量、常量、代码段等，在汇编过程中被替换为具体的地址或值。它们没有对应的机器码。</p><ul><li><p><strong>标签</strong>：用于标识代码中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">LABEL</span>: ; 定义一个标签<span class="selector-tag">LABEL</span></span><br></pre></td></tr></table></figure></li><li><p><strong>宏定义</strong>：如<code>MACRO</code>，用于定义宏，简化代码编写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYMACRO MACRO ; 宏定义内容 ENDM</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-CPU对存储器的读写"><a href="#3-CPU对存储器的读写" class="headerlink" title="3.CPU对存储器的读写"></a>3.CPU对存储器的读写</h4><ol><li>存储单元的地址</li><li>控制信息</li><li>读或者写的数据</li></ol><h4 id="4-地址总线"><a href="#4-地址总线" class="headerlink" title="4.地址总线"></a>4.地址总线</h4><p>CPU通过地址总线来<strong>指定存储器单元</strong>。</p><p>一个CPU有N根地址线，则它的地址总线宽度为N，最多可以寻找2的N次方给内存单元。</p><p>CPU通过地址总线传入存储器的必须是一个内存单元的<strong>物理地址</strong>。</p><h4 id="5-数据总线"><a href="#5-数据总线" class="headerlink" title="5.数据总线"></a>5.数据总线</h4><p>CPU与内存或其他器件之间<strong>数据传送</strong>是通过数据总线进行的。</p><h4 id="6-控制总线"><a href="#6-控制总线" class="headerlink" title="6.控制总线"></a>6.控制总线</h4><p>CPU<strong>对外部器件的控制</strong>是通过控制总线进行的。</p><h4 id="7-内存地址空间"><a href="#7-内存地址空间" class="headerlink" title="7.内存地址空间"></a>7.内存地址空间</h4><p>8086CPU地址总线宽度为20，可以定位2的20次方个内存单元，那么内存地址空间为1MB。</p><h3 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h3><h4 id="（一）、通用寄存器"><a href="#（一）、通用寄存器" class="headerlink" title="（一）、通用寄存器"></a>（一）、通用寄存器</h4><h5 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="1.数据寄存器"></a>1.数据寄存器</h5><h6 id="（1）作为完整的32位数据寄存器"><a href="#（1）作为完整的32位数据寄存器" class="headerlink" title="（1）作为完整的32位数据寄存器"></a>（1）作为完整的32位数据寄存器</h6><ul><li>EAX，EBX，ECX，EDX</li></ul><h6 id="（2）下半部分作为16位寄存器"><a href="#（2）下半部分作为16位寄存器" class="headerlink" title="（2）下半部分作为16位寄存器"></a>（2）下半部分作为16位寄存器</h6><ul><li>AX：累加器</li><li>BX：基址寄存器</li><li>CX：计数寄存器</li><li>DX：数据寄存器</li></ul><h6 id="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"><a href="#（3）16位寄存器的下半部分和上半部分再作为8位寄存器" class="headerlink" title="（3）16位寄存器的下半部分和上半部分再作为8位寄存器"></a>（3）16位寄存器的下半部分和上半部分再作为8位寄存器</h6><ul><li>AH,AL,BLH,BL</li><li>CH,CL,DH,DL</li></ul><h5 id="2-指针寄存器"><a href="#2-指针寄存器" class="headerlink" title="2.指针寄存器"></a>2.指针寄存器</h5><ul><li>指令指针（IP）</li><li>堆栈指针（SP）</li><li>基本指针（BP）</li></ul><h5 id="3-索引寄存器"><a href="#3-索引寄存器" class="headerlink" title="3.索引寄存器"></a>3.索引寄存器</h5><ul><li>源索引（SI）</li><li>DI</li></ul><h5 id="4-数据寄存器"><a href="#4-数据寄存器" class="headerlink" title="4.数据寄存器"></a>4.数据寄存器</h5><h4 id="（二）、控制寄存器"><a href="#（二）、控制寄存器" class="headerlink" title="（二）、控制寄存器"></a>（二）、控制寄存器</h4><p>将32位指令指针寄存器和32位标志寄存器组合。</p><h5 id="通用标志位"><a href="#通用标志位" class="headerlink" title="通用标志位"></a>通用标志位</h5><ul><li><strong>溢出标志（OF）</strong> -<u>有符号</u>算术运算后数据的高阶位（最左位）的溢出。</li><li><strong>方向标记（DF）</strong> -DF值为0时，字符串操作为从左至右的方向；当DF值为1时，字符串操作为从右至左的方向。</li><li><strong>中断标志（IF）</strong> -当值为0时，它禁用外部中断，而当值为1时，它使能中断。</li><li><strong>陷阱标志（TF）</strong> -允许在单步模式下设置处理器的操作。我们使用的DEBUG程序设置了陷阱标志，因此我们可以一次逐步执行一条指令。</li><li><strong>符号标志（SF）</strong> -正结果将SF的值清除为0，负结果将其设置为1。</li><li><strong>零标志（ZF）</strong> -非零结果将零标志清零，零结果将其清零。</li><li><strong>辅助进位标志（AF）</strong> -包含经过算术运算后从位3到位4的进位；用于专业算术。当1字节算术运算引起从第3位到第4位的进位时，将设置AF。</li><li><strong>奇偶校验标志（PF）</strong> -偶数个1位将奇偶校验标志清为0，奇数个1位将奇偶校验标志清为1。</li><li><strong>进位标志（CF）</strong> -在算术运算后，它包含一个高位（最左边）的0或1进位。</li></ul><h4 id="（三）、段寄存器"><a href="#（三）、段寄存器" class="headerlink" title="（三）、段寄存器"></a>（三）、段寄存器</h4><ul><li><strong>CS</strong>：<u><strong>代码段寄存器</strong></u>，包含当前正在执行的代码的段基址。</li><li><strong>DS</strong>：<strong><u>数据段寄存器</u></strong>，通常包含程序正在操作的数据的段基址。</li><li><strong>SS</strong>：<strong><u>堆栈段寄存器</u></strong>，包含当前堆栈的段基址。</li><li><strong>ES</strong>：<strong><u>附加段寄存器</u></strong>，用于存储其他数据段的基址。</li><li><strong>FS</strong></li><li><strong>GS</strong></li></ul><h4 id="（四）8086CPU给出物理地址的方法"><a href="#（四）8086CPU给出物理地址的方法" class="headerlink" title="（四）8086CPU给出物理地址的方法"></a>（四）8086CPU给出物理地址的方法</h4><p><strong>物理地址=段地址x16+偏移地址</strong></p><p>用两个16位地址（段地址、偏移地址）合成一个20位物理地址</p><p>段地址 x 16 是十六进制<strong>段地址数据左移一位</strong></p><h3 id="（三）、内存和寻址"><a href="#（三）、内存和寻址" class="headerlink" title="（三）、内存和寻址"></a>（三）、内存和寻址</h3><h4 id="段分布"><a href="#段分布" class="headerlink" title="段分布"></a>段分布</h4><ul><li><strong>text</strong>: 存放的是二进制机器码，用于存储程序中已初始化的全局变量和静态变量，只读</li><li><strong>.data</strong>: 用于存储程序中已初始化的全局变量和静态变量。非默认值</li><li><strong>.bss</strong>：存放未初始化的全局变量，或者默认初始化的全局变量。这一部分在二进制文件中不占硬盘空间，即不会真实存储这些为初始化的变量，而是在程序加载到内存时再分配。当然肯定需要有个标识，告诉该怎么分配内存</li><li><strong>.rodata</strong>：存放只读数据，如常量数据</li></ul><h4 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h4><p>.DATA声明静态数据区</p><p><strong>在汇编中只有一维数组</strong>，只有没有二维和多维数组。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li><strong>立即寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 123 ; rax = 123</span><br></pre></td></tr></table></figure><ul><li><strong>寄存器寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rax, rbx ; rax = rax + rbx</span><br></pre></td></tr></table></figure><ul><li><strong>直接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [someVariable] ; eax = contents of memory at address someVariable</span><br></pre></td></tr></table></figure><ul><li><strong>间接寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx] ; eax = contents of memory at address stored in rbx</span><br></pre></td></tr></table></figure><ul><li><strong>基址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+4] ; eax = contents of memory at address (rbx + 4)</span><br></pre></td></tr></table></figure><ul><li><strong>索引寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+rcx*4] ; eax = contents of memory at address (rbx + rcx*4)</span><br></pre></td></tr></table></figure><ul><li><strong>基址变址寻址</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbx+rcx+4] ; eax = contents of memory at address (rbx + rcx + 4)</span><br></pre></td></tr></table></figure><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。</p><p>它由起始地址开始，从低位（地址）向高位（地址）增长。</p><p>Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt="img"></p><h3 id="（五）、指令"><a href="#（五）、指令" class="headerlink" title="（五）、指令"></a>（五）、指令</h3><h4 id="lea和mov指令"><a href="#lea和mov指令" class="headerlink" title="lea和mov指令"></a>lea和mov指令</h4><p>LEA指令将其第二个操作对象指定的地址放入其第一个操作对象指定的寄存器中。</p><p>MOV指令将其第二操作对象（即寄存器内容、内存内容或常量值）所引用的数据项复制到其第一操作对象（即寄存器或内存）所引用的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebx]     ; 将EBX中的地址所指向的内存中的4个字节移动到EAX中</span><br><span class="line">mov [var], ebx     ; 将EBX的内容移到内存地址var的4个字节中(注意，不加中括号的var是一个32位地址常量，加中括号才是取地址指向的内容)</span><br><span class="line">mov eax, [esi-4] ; 将内存地址ESI+(-4)上的4个字节移入EAX</span><br><span class="line">mov [esi+eax], cl ; 将CL的内容移到地址为ESI+EAX的单字节中</span><br><span class="line">mov edx, [esi+4*ebx] ; 将地址为ESI+4*EBX的4字节数据移动到EDX中</span><br></pre></td></tr></table></figure><h4 id="ADD、SUB指令"><a href="#ADD、SUB指令" class="headerlink" title="ADD、SUB指令"></a>ADD、SUB指令</h4><p>用于对字节，字和双字大小的二进制数据进行简单的加/减，即分别用于添加或减去8位，16位或32位操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">add &lt;mem&gt;,&lt;con&gt;</span><br><span class="line">sub al, ah ; AL ← AL - AH</span><br><span class="line">sub eax, 216 ; 从存储在EAX中的值中减去216</span><br></pre></td></tr></table></figure><h4 id="INC和DEC指令"><a href="#INC和DEC指令" class="headerlink" title="INC和DEC指令"></a>INC和DEC指令</h4><p>目标操作数可以是8位，16位或32位操作数。</p><p>INC指令用于将操作数加1。</p><p>DEC指令用于将操作数减1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INC EBX      ;  32-bit 寄存器 自增1</span><br><span class="line">INC DL       ;  8-bit 寄存器 自增1</span><br><span class="line">INC [count]  ;  变量count  自增1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="imul、idiv"><a href="#imul、idiv" class="headerlink" title="imul、idiv"></a>imul、idiv</h4><p>整数乘除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">imul &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;mem&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;</span><br><span class="line">imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中</span><br><span class="line">imul esi, edi, 25 ; ESI → EDI * 25</span><br><span class="line"></span><br><span class="line">idiv &lt;reg32&gt;</span><br><span class="line">idiv &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中</span><br><span class="line">idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="and-or-xor指令"><a href="#and-or-xor指令" class="headerlink" title="and, or, xor指令"></a><strong>and, or, xor</strong>指令</h4><p>按位与、或和异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line">and &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;,&lt;con&gt;</span><br><span class="line">and &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br><span class="line">and eax, 0fH ; 清除EAX的除最后4位以外的所有位</span><br><span class="line">xor edx, edx ; 将EDX的内容设置为零</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="not、neg指令"><a href="#not、neg指令" class="headerlink" title="not、neg指令"></a>not、neg指令</h4><p>NOT 指令触发（翻转）操作对象中的所有位。其结果被称为反码。</p><p>NEG是汇编指令中的求补指令，对操作对象执行求补运算：用零减去操作对象，然后结果返回操作对象。</p><p>（将操作对象按位取反后加1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">not &lt;reg&gt;</span><br><span class="line">not &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="shl-shr指令"><a href="#shl-shr指令" class="headerlink" title="shl, shr指令"></a><strong>shl, shr</strong>指令</h4><p> 左移，右移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line">shl &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line">shl &lt;reg&gt;,&lt;cl&gt;</span><br><span class="line">shl &lt;mem&gt;,&lt;cl&gt;</span><br><span class="line"></span><br><span class="line">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）</span><br><span class="line">shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值</span><br></pre></td></tr></table></figure><h4 id="JMP及衍生"><a href="#JMP及衍生" class="headerlink" title="JMP及衍生"></a>JMP及衍生</h4><p>无条件跳转</p><div class="table-container"><table><thead><tr><th>JMP</th><th>无条件跳转指令</th></tr></thead><tbody><tr><td><strong>JC</strong></td><td>进位时跳转</td></tr><tr><td><strong>JO</strong></td><td>溢出时跳转</td></tr><tr><td><strong>JE</strong>/<strong>JZ</strong></td><td>相等/零时跳转</td></tr><tr><td><strong>JS</strong></td><td>负数时跳转</td></tr><tr><td><strong>JP</strong>/<strong>JPE</strong></td><td>奇偶校验时跳转</td></tr><tr><td></td></tr></tbody></table></div><h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><p>比较两个操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP DX, 00  ; 将DX值与0进行比较</span><br><span class="line">JE  L7      ; 如果等于，则跳转到标签L7</span><br></pre></td></tr></table></figure><h4 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h4><p>实现循环（计数型循环）</p><p>CX = CX -1</p><p>判断CX中的值，不为0则继续跳转；为0则向下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOOP    label</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="六-、调用约定"><a href="#六-、调用约定" class="headerlink" title="(六)、调用约定"></a>(六)、调用约定</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><strong>系统调用</strong></h4><p>操作系统为用户态运行的进程与硬件设备之间进行交互提供了一组接口。</p><p>实质上就是<strong><em>\</em>函数调用**</strong>，只不过调用的是<strong><em>\</em>系统函数**</strong>，处于内核态而已</p><p>在Linux中，EAX寄存器是负责传递系统调用号的。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><h3 id="（一）、内联函数"><a href="#（一）、内联函数" class="headerlink" title="（一）、内联函数"></a>（一）、内联函数</h3><p>内联汇编是指在高级语言中嵌入汇编代码，，减少函数调用。</p><h3 id="（二）、内联汇编语法"><a href="#（二）、内联汇编语法" class="headerlink" title="（二）、内联汇编语法"></a>（二）、内联汇编语法</h3><h4 id="1-在-GCC-中"><a href="#1-在-GCC-中" class="headerlink" title="1. 在 GCC 中"></a>1. 在 GCC 中</h4><p>使用 <code>asm</code> 或 <code>__asm__</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly-code&quot;</span> : output : input : clobbered_registers);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, result;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;addl %%ebx, %%eax&quot;</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span>(result)           <span class="comment">// 输出约束，`a` 表示使用 EAX 寄存器</span></span><br><span class="line">    : <span class="string">&quot;a&quot;</span>(a), <span class="string">&quot;b&quot;</span>(b)         <span class="comment">// 输入约束，`b` 表示使用 EBX 寄存器</span></span><br><span class="line">    : <span class="string">&quot;cc&quot;</span>);                 <span class="comment">// 通知编译器条件码被修改</span></span><br></pre></td></tr></table></figure><h4 id="关键约束："><a href="#关键约束：" class="headerlink" title="关键约束："></a>关键约束：</h4><ul><li><strong>操作数约束</strong>：<ul><li><code>&quot;r&quot;</code>：任意寄存器</li><li><code>&quot;m&quot;</code>：内存操作数</li><li><code>&quot;i&quot;</code>：立即数</li><li><code>&quot;a&quot;</code>：EAX</li><li><code>&quot;b&quot;</code>：EBX 等</li></ul></li><li><strong>修饰符</strong>：<ul><li><code>=：</code>：表示写入输出</li><li><code>+：</code>：表示读写操作</li><li><code>&amp;：</code>：表示早期释放寄存器</li></ul></li></ul><h4 id="2-在-MSVC-中"><a href="#2-在-MSVC-中" class="headerlink" title="2. 在 MSVC 中"></a>2. 在 MSVC 中</h4><p>使用 <code>__asm</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">    mov eax, <span class="number">1</span></span><br><span class="line">    add eax, <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>, result;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, a</span><br><span class="line">        add eax, b</span><br><span class="line">        mov result, eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-常用指令示例"><a href="#三-常用指令示例" class="headerlink" title="(三)常用指令示例"></a>(三)常用指令示例</h3><h4 id="1-数据传送"><a href="#1-数据传送" class="headerlink" title="1. 数据传送"></a>1. 数据传送</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 10       ; 将 10 送入 EAX 寄存器</span><br><span class="line">mov ebx, eax      ; 将 EAX 的值传给 EBX</span><br></pre></td></tr></table></figure><h4 id="2-算术运算"><a href="#2-算术运算" class="headerlink" title="2. 算术运算"></a>2. 算术运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add eax, ebx      ; EAX = EAX + EBX</span><br><span class="line">sub eax, 5        ; EAX = EAX - 5</span><br><span class="line">mul ebx           ; EAX = EAX * EBX</span><br><span class="line">div ecx           ; EAX = EAX / ECX</span><br></pre></td></tr></table></figure><h4 id="3-条件跳转"><a href="#3-条件跳转" class="headerlink" title="3. 条件跳转"></a>3. 条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, ebx      ; 比较 EAX 和 EBX</span><br><span class="line">je equal_label    ; 如果相等，则跳转到 equal_label</span><br><span class="line">jg greater_label  ; 如果大于，则跳转到 greater_label</span><br></pre></td></tr></table></figure><h4 id="4-栈操作"><a href="#4-栈操作" class="headerlink" title="4. 栈操作"></a>4. 栈操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push eax          ; 将 EAX 压入栈</span><br><span class="line">pop ebx           ; 从栈中弹出值到 EBX</span><br></pre></td></tr></table></figure><script src="https://giscus.app/client.js"        data-repo="Samsara-lo/Samsara-lo.github.io"        data-repo-id="R_kgDONimTFg"        data-category="General"        data-category-id="DIC_kwDONimTFs4CorbM"        data-mapping="pathname"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="light_high_contrast"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
